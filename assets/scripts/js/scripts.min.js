var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        var t, e, i, n, r, o, s, a, l, c, h, u, d, p, f, m;
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                var n = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    r = function(t, e, i) {
                        var n, r, o = t.cycle;
                        for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                        delete t.cycle
                    },
                    o = function(t, e, n) {
                        i.call(this, t, e, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = o.prototype.render
                    },
                    s = 1e-10,
                    a = i._internals,
                    l = a.isSelector,
                    c = a.isArray,
                    h = o.prototype = i.to({}, .1, {}),
                    u = [];
                o.version = "2.0.2", h.constructor = o, h.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, h.invalidate = function() {
                    return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
                }, h.updateTo = function(t, e) {
                    var n, r = this.ratio,
                        o = this.vars.immediateRender || t.immediateRender;
                    for (n in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[n] = t[n];
                    if (this._initted || o)
                        if (e) this._initted = !1, o && this.render(0, !0, !0);
                        else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                        var s = this._totalTime;
                        this.render(0, !0, !1), this._initted = !1, this.render(s, !0, !1)
                    } else if (this._initted = !1, this._init(), this._time > 0 || o)
                        for (var a, l = 1 / (1 - r), c = this._firstPT; c;) a = c.s + c.c, c.c *= l, c.s = a - c.c, c = c._next;
                    return this
                }, h.render = function(t, e, n) {
                    this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                    var r, o, l, c, h, u, d, p, f, m = this._dirty ? this.totalDuration() : this._totalDuration,
                        g = this._time,
                        v = this._totalTime,
                        y = this._cycle,
                        _ = this._duration,
                        x = this._rawPrevTime;
                    if (t >= m - 1e-7 && t >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = _, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, o = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === _ && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (0 > x || 0 >= t && t >= -1e-7 || x === s && "isPause" !== this.data) && x !== t && (n = !0, x > s && (o = "onReverseComplete")), this._rawPrevTime = p = !e || t || x === t ? t : s)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === _ && x > 0) && (o = "onReverseComplete", r = this._reversed), 0 > t && (this._active = !1, 0 === _ && (this._initted || !this.vars.lazy || n) && (x >= 0 && (n = !0), this._rawPrevTime = p = !e || t || x === t ? t : s)), this._initted || (n = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = _ + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && t >= v && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = _ - this._time, (f = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== f || this._initted ? this._yoyoEase = f = !0 === f ? this._ease : f instanceof Ease ? f : Ease.map[f] : (f = this.vars.ease, this._yoyoEase = f = f ? f instanceof Ease ? f : "function" == typeof f ? new Ease(f, this.vars.easeParams) : Ease.map[f] || i.defaultEase : i.defaultEase)), this.ratio = f ? 1 - f.getRatio((_ - this._time) / _) : 0)), this._time > _ ? this._time = _ : this._time < 0 && (this._time = 0)), this._easeType && !f ? (h = this._time / _, (1 === (u = this._easeType) || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === (d = this._easePower) ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), 1 === u ? this.ratio = 1 - h : 2 === u ? this.ratio = h : this._time / _ < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2) : f || (this.ratio = this._ease.getRatio(this._time / _))), g !== this._time || n || y !== this._cycle) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = g, this._totalTime = v, this._rawPrevTime = x, this._cycle = y, a.lazyTweens.push(this), void(this._lazy = [t, e]);
                            !this._time || r || f ? r && this._ease._calcEnd && !f && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / _)
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== g && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : o || (o = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === _) && (e || this._callback("onStart"))), l = this._firstPT; l;) l.f ? l.t[l.p](l.c * this.ratio + l.s) : l.t[l.p] = l.c * this.ratio + l.s, l = l._next;
                        this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, !0, n), e || (this._totalTime !== v || o) && this._callback("onUpdate")), this._cycle !== y && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (!this._gc || n) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o), 0 === _ && this._rawPrevTime === s && p !== s && (this._rawPrevTime = 0))
                    } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                }, o.to = function(t, e, i) {
                    return new o(t, e, i)
                }, o.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
                }, o.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new o(t, e, n)
                }, o.staggerTo = o.allTo = function(t, e, s, a, h, d, p) {
                    a = a || 0;
                    var f, m, g, v, y = 0,
                        _ = [],
                        x = function() {
                            s.onComplete && s.onComplete.apply(s.onCompleteScope || this, arguments), h.apply(p || s.callbackScope || this, d || u)
                        },
                        w = s.cycle,
                        b = s.startAt && s.startAt.cycle;
                    for (c(t) || ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = n(t))), t = t || [], 0 > a && ((t = n(t)).reverse(), a *= -1), f = t.length - 1, g = 0; f >= g; g++) {
                        for (v in m = {}, s) m[v] = s[v];
                        if (w && (r(m, t, g), null != m.duration && (e = m.duration, delete m.duration)), b) {
                            for (v in b = m.startAt = {}, s.startAt) b[v] = s.startAt[v];
                            r(m.startAt, t, g)
                        }
                        m.delay = y + (m.delay || 0), g === f && h && (m.onComplete = x), _[g] = new o(t[g], e, m), y += a
                    }
                    return _
                }, o.staggerFrom = o.allFrom = function(t, e, i, n, r, s, a) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, n, r, s, a)
                }, o.staggerFromTo = o.allFromTo = function(t, e, i, n, r, s, a, l) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, n, r, s, a, l)
                }, o.delayedCall = function(t, e, i, n, r) {
                    return new o(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, o.set = function(t, e) {
                    return new o(t, 0, e)
                }, o.isTweening = function(t) {
                    return i.getTweensOf(t, !0).length > 0
                };
                var d = function(t, e) {
                        for (var n = [], r = 0, o = t._first; o;) o instanceof i ? n[r++] = o : (e && (n[r++] = o), r = (n = n.concat(d(o, e))).length), o = o._next;
                        return n
                    },
                    p = o.getAllTweens = function(e) {
                        return d(t._rootTimeline, e).concat(d(t._rootFramesTimeline, e))
                    };
                o.killAll = function(t, i, n, r) {
                    null == i && (i = !0), null == n && (n = !0);
                    var o, s, a, l = p(0 != r),
                        c = l.length,
                        h = i && n && r;
                    for (a = 0; c > a; a++) s = l[a], (h || s instanceof e || (o = s.target === s.vars.onComplete) && n || i && !o) && (t ? s.totalTime(s._reversed ? 0 : s.totalDuration()) : s._enabled(!1, !1))
                }, o.killChildTweensOf = function(t, e) {
                    if (null != t) {
                        var r, s, h, u, d, p = a.tweenLookup;
                        if ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = n(t)), c(t))
                            for (u = t.length; --u > -1;) o.killChildTweensOf(t[u], e);
                        else {
                            for (h in r = [], p)
                                for (s = p[h].target.parentNode; s;) s === t && (r = r.concat(p[h].tweens)), s = s.parentNode;
                            for (d = r.length, u = 0; d > u; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                        }
                    }
                };
                var f = function(t, i, n, r) {
                    i = !1 !== i, n = !1 !== n;
                    for (var o, s, a = p(r = !1 !== r), l = i && n && r, c = a.length; --c > -1;) s = a[c], (l || s instanceof e || (o = s.target === s.vars.onComplete) && n || i && !o) && s.paused(t)
                };
                return o.pauseAll = function(t, e, i) {
                    f(!0, t, e, i)
                }, o.resumeAll = function(t, e, i) {
                    f(!1, t, e, i)
                }, o.globalTimeScale = function(e) {
                    var n = t._rootTimeline,
                        r = i.ticker.time;
                    return arguments.length ? (e = e || s, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
                }, h.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                }, h.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                }, h.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                }, h.duration = function(e) {
                    return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                }, h.totalDuration = function(t) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                }, h.repeat = function(t) {
                    return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                }, h.repeatDelay = function(t) {
                    return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                }, h.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, o
            }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                var n = function(t) {
                        e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                        var i, n, r = this.vars;
                        for (n in r) i = r[n], l(i) && -1 !== i.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(i));
                        l(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                    },
                    r = 1e-10,
                    o = i._internals,
                    s = n._internals = {},
                    a = o.isSelector,
                    l = o.isArray,
                    c = o.lazyTweens,
                    h = o.lazyRender,
                    u = _gsScope._gsDefine.globals,
                    d = function(t) {
                        var e, i = {};
                        for (e in t) i[e] = t[e];
                        return i
                    },
                    p = function(t, e, i) {
                        var n, r, o = t.cycle;
                        for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                        delete t.cycle
                    },
                    f = s.pauseCallback = function() {},
                    m = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    g = n.prototype = new e;
                return n.version = "2.0.2", g.constructor = n, g.kill()._gc = g._forcingPlayhead = g._hasPause = !1, g.to = function(t, e, n, r) {
                    var o = n.repeat && u.TweenMax || i;
                    return e ? this.add(new o(t, e, n), r) : this.set(t, n, r)
                }, g.from = function(t, e, n, r) {
                    return this.add((n.repeat && u.TweenMax || i).from(t, e, n), r)
                }, g.fromTo = function(t, e, n, r, o) {
                    var s = r.repeat && u.TweenMax || i;
                    return e ? this.add(s.fromTo(t, e, n, r), o) : this.set(t, r, o)
                }, g.staggerTo = function(t, e, r, o, s, l, c, h) {
                    var u, f, g = new n({
                            onComplete: l,
                            onCompleteParams: c,
                            callbackScope: h,
                            smoothChildTiming: this.smoothChildTiming
                        }),
                        v = r.cycle;
                    for ("string" == typeof t && (t = i.selector(t) || t), a(t = t || []) && (t = m(t)), 0 > (o = o || 0) && ((t = m(t)).reverse(), o *= -1), f = 0; f < t.length; f++)(u = d(r)).startAt && (u.startAt = d(u.startAt), u.startAt.cycle && p(u.startAt, t, f)), v && (p(u, t, f), null != u.duration && (e = u.duration, delete u.duration)), g.to(t[f], e, u, f * o);
                    return this.add(g, s)
                }, g.staggerFrom = function(t, e, i, n, r, o, s, a) {
                    return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, s, a)
                }, g.staggerFromTo = function(t, e, i, n, r, o, s, a, l) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, s, a, l)
                }, g.call = function(t, e, n, r) {
                    return this.add(i.delayedCall(0, t, e, n), r)
                }, g.set = function(t, e, n) {
                    return n = this._parseTimeOrLabel(n, 0, !0), null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused), this.add(new i(t, 0, e), n)
                }, n.exportRoot = function(t, e) {
                    null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                    var r, o, s, a, l = new n(t),
                        c = l._timeline;
                    for (null == e && (e = !0), c._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = c._time, s = c._first; s;) a = s._next, e && s instanceof i && s.target === s.vars.onComplete || (0 > (o = s._startTime - s._delay) && (r = 1), l.add(s, o)), s = a;
                    return c.add(l, 0), r && l.totalDuration(), l
                }, g.add = function(r, o, s, a) {
                    var c, h, u, d, p, f;
                    if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
                        if (r instanceof Array || r && r.push && l(r)) {
                            for (s = s || "normal", a = a || 0, c = o, h = r.length, u = 0; h > u; u++) l(d = r[u]) && (d = new n({
                                tweens: d
                            })), this.add(d, c), "string" != typeof d && "function" != typeof d && ("sequence" === s ? c = d._startTime + d.totalDuration() / d._timeScale : "start" === s && (d._startTime -= d.delay())), c += a;
                            return this._uncache(!0)
                        }
                        if ("string" == typeof r) return this.addLabel(r, o);
                        if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                        r = i.delayedCall(0, r)
                    }
                    if (e.prototype.add.call(this, r, o), r._time && (c = Math.max(0, Math.min(r.totalDuration(), (this.rawTime() - r._startTime) * r._timeScale)), Math.abs(c - r._totalTime) > 1e-5 && r.render(c, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                        for (f = (p = this).rawTime() > r._startTime; p._timeline;) f && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
                    return this
                }, g.remove = function(e) {
                    if (e instanceof t) {
                        this._remove(e, !1);
                        var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                        return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                    }
                    if (e instanceof Array || e && e.push && l(e)) {
                        for (var n = e.length; --n > -1;) this.remove(e[n]);
                        return this
                    }
                    return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                }, g._remove = function(t, i) {
                    return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                }, g.append = function(t, e) {
                    return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                }, g.insert = g.insertMultiple = function(t, e, i, n) {
                    return this.add(t, e || 0, i, n)
                }, g.appendMultiple = function(t, e, i, n) {
                    return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                }, g.addLabel = function(t, e) {
                    return this._labels[t] = this._parseTimeOrLabel(e), this
                }, g.addPause = function(t, e, n, r) {
                    var o = i.delayedCall(0, f, n, r || this);
                    return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                }, g.removeLabel = function(t) {
                    return delete this._labels[t], this
                }, g.getLabelTime = function(t) {
                    return null != this._labels[t] ? this._labels[t] : -1
                }, g._parseTimeOrLabel = function(e, i, n, r) {
                    var o, s;
                    if (r instanceof t && r.timeline === this) this.remove(r);
                    else if (r && (r instanceof Array || r.push && l(r)))
                        for (s = r.length; --s > -1;) r[s] instanceof t && r[s].timeline === this && this.remove(r[s]);
                    if (o = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - o : 0, n);
                    if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o);
                    else {
                        if (-1 === (s = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = o + i : i : this._labels[e] + i;
                        i = parseInt(e.charAt(s - 1) + "1", 10) * Number(e.substr(s + 1)), e = s > 1 ? this._parseTimeOrLabel(e.substr(0, s - 1), 0, n) : o
                    }
                    return Number(e) + i
                }, g.seek = function(t, e) {
                    return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
                }, g.stop = function() {
                    return this.paused(!0)
                }, g.gotoAndPlay = function(t, e) {
                    return this.play(t, e)
                }, g.gotoAndStop = function(t, e) {
                    return this.pause(t, e)
                }, g.render = function(t, e, i) {
                    this._gc && this._enabled(!0, !1);
                    var n, o, s, a, l, u, d, p = this._time,
                        f = this._dirty ? this.totalDuration() : this._totalDuration,
                        m = this._startTime,
                        g = this._timeScale,
                        v = this._paused;
                    if (p !== this._time && (t += this._time - p), t >= f - 1e-7 && t >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (o = !0, a = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= t && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > r && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = f + 1e-4;
                    else if (1e-7 > t)
                        if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (a = "onReverseComplete", o = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = o = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                        else {
                            if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, 0 === t && o)
                                for (n = this._first; n && 0 === n._startTime;) n._duration || (o = !1), n = n._next;
                            t = 0, this._initted || (l = !0)
                        }
                    else {
                        if (this._hasPause && !this._forcingPlayhead && !e) {
                            if (t >= p)
                                for (n = this._first; n && n._startTime <= t && !u;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (u = n), n = n._next;
                            else
                                for (n = this._last; n && n._startTime >= t && !u;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (u = n), n = n._prev;
                            u && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                        }
                        this._totalTime = this._time = this._rawPrevTime = t
                    }
                    if (this._time !== p && this._first || i || l || u) {
                        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (d = this._time) >= p)
                            for (n = this._first; n && (s = n._next, d === this._time && (!this._paused || v));)(n._active || n._startTime <= d && !n._paused && !n._gc) && (u === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = s;
                        else
                            for (n = this._last; n && (s = n._prev, d === this._time && (!this._paused || v));) {
                                if (n._active || n._startTime <= p && !n._paused && !n._gc) {
                                    if (u === n) {
                                        for (u = n._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, i), u = u._prev;
                                        u = null, this.pause()
                                    }
                                    n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                }
                                n = s
                            }
                        this._onUpdate && (e || (c.length && h(), this._callback("onUpdate"))), a && (this._gc || (m === this._startTime || g !== this._timeScale) && (0 === this._time || f >= this.totalDuration()) && (o && (c.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a)))
                    }
                }, g._hasPausedChild = function() {
                    for (var t = this._first; t;) {
                        if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                        t = t._next
                    }
                    return !1
                }, g.getChildren = function(t, e, n, r) {
                    r = r || -9999999999;
                    for (var o = [], s = this._first, a = 0; s;) s._startTime < r || (s instanceof i ? !1 !== e && (o[a++] = s) : (!1 !== n && (o[a++] = s), !1 !== t && (a = (o = o.concat(s.getChildren(!0, e, n))).length))), s = s._next;
                    return o
                }, g.getTweensOf = function(t, e) {
                    var n, r, o = this._gc,
                        s = [],
                        a = 0;
                    for (o && this._enabled(!0, !0), r = (n = i.getTweensOf(t)).length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (s[a++] = n[r]);
                    return o && this._enabled(!1, !0), s
                }, g.recent = function() {
                    return this._recent
                }, g._contains = function(t) {
                    for (var e = t.timeline; e;) {
                        if (e === this) return !0;
                        e = e.timeline
                    }
                    return !1
                }, g.shiftChildren = function(t, e, i) {
                    i = i || 0;
                    for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                    if (e)
                        for (n in o) o[n] >= i && (o[n] += t);
                    return this._uncache(!0)
                }, g._kill = function(t, e) {
                    if (!t && !e) return this._enabled(!1, !1);
                    for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                    return r
                }, g.clear = function(t) {
                    var e = this.getChildren(!1, !0, !0),
                        i = e.length;
                    for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                    return !1 !== t && (this._labels = {}), this._uncache(!0)
                }, g.invalidate = function() {
                    for (var e = this._first; e;) e.invalidate(), e = e._next;
                    return t.prototype.invalidate.call(this)
                }, g._enabled = function(t, i) {
                    if (t === this._gc)
                        for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
                    return e.prototype._enabled.call(this, t, i)
                }, g.totalTime = function(e, i, n) {
                    this._forcingPlayhead = !0;
                    var r = t.prototype.totalTime.apply(this, arguments);
                    return this._forcingPlayhead = !1, r
                }, g.duration = function(t) {
                    return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                }, g.totalDuration = function(t) {
                    if (!arguments.length) {
                        if (this._dirty) {
                            for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (i = r._startTime + r._totalDuration / r._timeScale) > n && (n = i), r = e;
                            this._duration = this._totalDuration = n, this._dirty = !1
                        }
                        return this._totalDuration
                    }
                    return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                }, g.paused = function(e) {
                    if (!e)
                        for (var i = this._first, n = this._time; i;) i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                    return t.prototype.paused.apply(this, arguments)
                }, g.usesFrames = function() {
                    for (var e = this._timeline; e._timeline;) e = e._timeline;
                    return e === t._rootFramesTimeline
                }, g.rawTime = function(t) {
                    return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                }, n
            }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                var n = function(e) {
                        t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
                    },
                    r = 1e-10,
                    o = e._internals,
                    s = o.lazyTweens,
                    a = o.lazyRender,
                    l = _gsScope._gsDefine.globals,
                    c = new i(null, null, 1, 0),
                    h = n.prototype = new t;
                return h.constructor = n, h.kill()._gc = !1, n.version = "2.0.2", h.invalidate = function() {
                    return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                }, h.addCallback = function(t, i, n, r) {
                    return this.add(e.delayedCall(0, t, n, r), i)
                }, h.removeCallback = function(t, e) {
                    if (t)
                        if (null == e) this._kill(null, t);
                        else
                            for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                    return this
                }, h.removePause = function(e) {
                    return this.removeCallback(t._internals.pauseCallback, e)
                }, h.tweenTo = function(t, i) {
                    i = i || {};
                    var n, r, o, s = {
                            ease: c,
                            useFrames: this.usesFrames(),
                            immediateRender: !1,
                            lazy: !1
                        },
                        a = i.repeat && l.TweenMax || e;
                    for (r in i) s[r] = i[r];
                    return s.time = this._parseTimeOrLabel(t), n = Math.abs(Number(s.time) - this._time) / this._timeScale || .001, o = new a(this, n, s), s.onStart = function() {
                        o.target.paused(!0), o.vars.time === o.target.time() || n !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || o, i.onStartParams || [])
                    }, o
                }, h.tweenFromTo = function(t, e, i) {
                    i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                        onComplete: this.seek,
                        onCompleteParams: [t],
                        callbackScope: this
                    }, i.immediateRender = !1 !== i.immediateRender;
                    var n = this.tweenTo(e, i);
                    return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                }, h.render = function(t, e, i) {
                    this._gc && this._enabled(!0, !1);
                    var n, o, l, c, h, u, d, p, f = this._time,
                        m = this._dirty ? this.totalDuration() : this._totalDuration,
                        g = this._duration,
                        v = this._totalTime,
                        y = this._startTime,
                        _ = this._timeScale,
                        x = this._rawPrevTime,
                        w = this._paused,
                        b = this._cycle;
                    if (f !== this._time && (t += this._time - f), t >= m - 1e-7 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, c = "onComplete", h = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= t && t >= -1e-7 || 0 > x || x === r) && x !== t && this._first && (h = !0, x > r && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = g, t = g + 1e-4);
                    else if (1e-7 > t)
                        if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== f || 0 === g && x !== r && (x > 0 || 0 > t && x >= 0) && !this._locked) && (c = "onReverseComplete", o = this._reversed), 0 > t) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (h = o = !0, c = "onReverseComplete") : x >= 0 && this._first && (h = !0), this._rawPrevTime = t;
                        else {
                            if (this._rawPrevTime = g || !e || t || this._rawPrevTime === t ? t : r, 0 === t && o)
                                for (n = this._first; n && 0 === n._startTime;) n._duration || (o = !1), n = n._next;
                            t = 0, this._initted || (h = !0)
                        }
                    else if (0 === g && 0 > x && (h = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = g + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && t >= v && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 != (1 & this._cycle) && (this._time = g - this._time), this._time > g ? (this._time = g, t = g + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                        if ((t = this._time) >= f || this._repeat && b !== this._cycle)
                            for (n = this._first; n && n._startTime <= t && !d;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (d = n), n = n._next;
                        else
                            for (n = this._last; n && n._startTime >= t && !d;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (d = n), n = n._prev;
                        d && d._startTime < g && (this._time = t = d._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    if (this._cycle !== b && !this._locked) {
                        var T = this._yoyo && 0 != (1 & b),
                            S = T === (this._yoyo && 0 != (1 & this._cycle)),
                            M = this._totalTime,
                            E = this._cycle,
                            A = this._rawPrevTime,
                            P = this._time;
                        if (this._totalTime = b * g, this._cycle < b ? T = !T : this._totalTime += g, this._time = f, this._rawPrevTime = 0 === g ? x - 1e-4 : x, this._cycle = b, this._locked = !0, f = T ? 0 : g, this.render(f, e, 0 === g), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), f !== this._time) return;
                        if (S && (this._cycle = b, this._locked = !0, f = T ? g + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !w) return;
                        this._time = P, this._totalTime = M, this._cycle = E, this._rawPrevTime = A
                    }
                    if (this._time !== f && this._first || i || h || d) {
                        if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (p = this._time) >= f)
                            for (n = this._first; n && (l = n._next, p === this._time && (!this._paused || w));)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (d === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = l;
                        else
                            for (n = this._last; n && (l = n._prev, p === this._time && (!this._paused || w));) {
                                if (n._active || n._startTime <= f && !n._paused && !n._gc) {
                                    if (d === n) {
                                        for (d = n._prev; d && d.endTime() > this._time;) d.render(d._reversed ? d.totalDuration() - (t - d._startTime) * d._timeScale : (t - d._startTime) * d._timeScale, e, i), d = d._prev;
                                        d = null, this.pause()
                                    }
                                    n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                }
                                n = l
                            }
                        this._onUpdate && (e || (s.length && a(), this._callback("onUpdate"))), c && (this._locked || this._gc || (y === this._startTime || _ !== this._timeScale) && (0 === this._time || m >= this.totalDuration()) && (o && (s.length && a(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
                    } else v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
                }, h.getActive = function(t, e, i) {
                    null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                    var n, r, o = [],
                        s = this.getChildren(t, e, i),
                        a = 0,
                        l = s.length;
                    for (n = 0; l > n; n++)(r = s[n]).isActive() && (o[a++] = r);
                    return o
                }, h.getLabelAfter = function(t) {
                    t || 0 !== t && (t = this._time);
                    var e, i = this.getLabelsArray(),
                        n = i.length;
                    for (e = 0; n > e; e++)
                        if (i[e].time > t) return i[e].name;
                    return null
                }, h.getLabelBefore = function(t) {
                    null == t && (t = this._time);
                    for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                        if (e[i].time < t) return e[i].name;
                    return null
                }, h.getLabelsArray = function() {
                    var t, e = [],
                        i = 0;
                    for (t in this._labels) e[i++] = {
                        time: this._labels[t],
                        name: t
                    };
                    return e.sort(function(t, e) {
                        return t.time - e.time
                    }), e
                }, h.invalidate = function() {
                    return this._locked = !1, t.prototype.invalidate.call(this)
                }, h.progress = function(t, e) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                }, h.totalProgress = function(t, e) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                }, h.totalDuration = function(e) {
                    return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                }, h.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                }, h.repeat = function(t) {
                    return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                }, h.repeatDelay = function(t) {
                    return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                }, h.yoyo = function(t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, h.currentLabel = function(t) {
                    return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                }, n
            }, !0), t = 180 / Math.PI, e = [], i = [], n = [], r = {}, o = _gsScope._gsDefine.globals, s = function(t, e, i, n) {
                i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
            }, a = function(t, e, i, n) {
                var r = {
                        a: t
                    },
                    o = {},
                    s = {},
                    a = {
                        c: n
                    },
                    l = (t + e) / 2,
                    c = (e + i) / 2,
                    h = (i + n) / 2,
                    u = (l + c) / 2,
                    d = (c + h) / 2,
                    p = (d - u) / 8;
                return r.b = l + (t - l) / 4, o.b = u + p, r.c = o.a = (r.b + o.b) / 2, o.c = s.a = (u + d) / 2, s.b = d - p, a.b = h + (n - h) / 4, s.c = a.a = (s.b + a.b) / 2, [r, o, s, a]
            }, l = function(t, r, o, s, l) {
                var c, h, u, d, p, f, m, g, v, y, _, x, w, b = t.length - 1,
                    T = 0,
                    S = t[0].a;
                for (c = 0; b > c; c++) h = (p = t[T]).a, u = p.d, d = t[T + 1].d, l ? (_ = e[c], w = ((x = i[c]) + _) * r * .25 / (s ? .5 : n[c] || .5), g = u - ((f = u - (u - h) * (s ? .5 * r : 0 !== _ ? w / _ : 0)) + (((m = u + (d - u) * (s ? .5 * r : 0 !== x ? w / x : 0)) - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : g = u - ((f = u - (u - h) * r * .5) + (m = u + (d - u) * r * .5)) / 2, f += g, m += g, p.c = v = f, p.b = 0 !== c ? S : S = p.a + .6 * (p.c - p.a), p.da = u - h, p.ca = v - h, p.ba = S - h, o ? (y = a(h, S, v, u), t.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, S = m;
                (p = t[T]).b = S, p.c = S + .4 * (p.d - S), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = S - p.a, o && (y = a(p.a, S, p.c, p.d), t.splice(T, 1, y[0], y[1], y[2], y[3]))
            }, c = function(t, n, r, o) {
                var a, l, c, h, u, d, p = [];
                if (o)
                    for (l = (t = [o].concat(t)).length; --l > -1;) "string" == typeof(d = t[l][n]) && "=" === d.charAt(1) && (t[l][n] = o[n] + Number(d.charAt(0) + d.substr(2)));
                if (0 > (a = t.length - 2)) return p[0] = new s(t[0][n], 0, 0, t[0][n]), p;
                for (l = 0; a > l; l++) c = t[l][n], h = t[l + 1][n], p[l] = new s(c, 0, 0, h), r && (u = t[l + 2][n], e[l] = (e[l] || 0) + (h - c) * (h - c), i[l] = (i[l] || 0) + (u - h) * (u - h));
                return p[l] = new s(t[l][n], 0, 0, t[l + 1][n]), p
            }, h = function(t, o, s, a, h, u) {
                var d, p, f, m, g, v, y, _, x = {},
                    w = [],
                    b = u || t[0];
                for (p in h = "string" == typeof h ? "," + h + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == o && (o = 1), t[0]) w.push(p);
                if (t.length > 1) {
                    for (_ = t[t.length - 1], y = !0, d = w.length; --d > -1;)
                        if (p = w[d], Math.abs(b[p] - _[p]) > .05) {
                            y = !1;
                            break
                        } y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                }
                for (e.length = i.length = n.length = 0, d = w.length; --d > -1;) p = w[d], r[p] = -1 !== h.indexOf("," + p + ","), x[p] = c(t, p, r[p], u);
                for (d = e.length; --d > -1;) e[d] = Math.sqrt(e[d]), i[d] = Math.sqrt(i[d]);
                if (!a) {
                    for (d = w.length; --d > -1;)
                        if (r[p])
                            for (v = (f = x[w[d]]).length - 1, m = 0; v > m; m++) g = f[m + 1].da / i[m] + f[m].da / e[m] || 0, n[m] = (n[m] || 0) + g * g;
                    for (d = n.length; --d > -1;) n[d] = Math.sqrt(n[d])
                }
                for (d = w.length, m = s ? 4 : 1; --d > -1;) f = x[p = w[d]], l(f, o, s, a, r[p]), y && (f.splice(0, m), f.splice(f.length - m, m));
                return x
            }, u = function(t, e, i) {
                var n, r, o, a, l, c, h, u, d, p, f, m = {},
                    g = "cubic" === (e = e || "soft") ? 3 : 2,
                    v = "soft" === e,
                    y = [];
                if (v && i && (t = [i].concat(t)), null == t || t.length < g + 1) throw "invalid Bezier data";
                for (d in t[0]) y.push(d);
                for (c = y.length; --c > -1;) {
                    for (m[d = y[c]] = l = [], p = 0, u = t.length, h = 0; u > h; h++) n = null == i ? t[h][d] : "string" == typeof(f = t[h][d]) && "=" === f.charAt(1) ? i[d] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && h > 1 && u - 1 > h && (l[p++] = (n + l[p - 2]) / 2), l[p++] = n;
                    for (u = p - g + 1, p = 0, h = 0; u > h; h += g) n = l[h], r = l[h + 1], o = l[h + 2], a = 2 === g ? 0 : l[h + 3], l[p++] = f = 3 === g ? new s(n, r, o, a) : new s(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                    l.length = p
                }
                return m
            }, d = function(t, e, i) {
                for (var n, r, o, s, a, l, c, h, u, d, p, f = 1 / i, m = t.length; --m > -1;)
                    for (o = (d = t[m]).a, s = d.d - o, a = d.c - o, l = d.b - o, n = r = 0, h = 1; i >= h; h++) n = r - (r = ((c = f * h) * c * s + 3 * (u = 1 - c) * (c * a + u * l)) * c), e[p = m * i + h - 1] = (e[p] || 0) + n * n
            }, p = function(t, e) {
                var i, n, r, o, s = [],
                    a = [],
                    l = 0,
                    c = 0,
                    h = (e = e >> 0 || 6) - 1,
                    u = [],
                    p = [];
                for (i in t) d(t[i], s, e);
                for (r = s.length, n = 0; r > n; n++) l += Math.sqrt(s[n]), p[o = n % e] = l, o === h && (c += l, u[o = n / e >> 0] = p, a[o] = c, l = 0, p = []);
                return {
                    length: c,
                    lengths: a,
                    segments: u
                }
            }, f = _gsScope._gsDefine.plugin({
                propName: "bezier",
                priority: -1,
                version: "1.3.8",
                API: 2,
                global: !0,
                init: function(t, e, i) {
                    this._target = t, e instanceof Array && (e = {
                        values: e
                    }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                    var n, r, o, s, a, l = e.values || [],
                        c = {},
                        d = l[0],
                        f = e.autoRotate || i.vars.orientToBezier;
                    for (n in this._autoRotate = f ? f instanceof Array ? f : [
                            ["x", "y", "rotation", !0 === f ? 0 : Number(f) || 0]
                        ] : null, d) this._props.push(n);
                    for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], c[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), a || c[n] !== l[0][n] && (a = c);
                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? h(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, a) : u(l, e.type, c), this._segCount = this._beziers[n].length, this._timeRes) {
                        var m = p(this._beziers, this._timeRes);
                        this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                    }
                    if (f = this._autoRotate)
                        for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), o = f.length; --o > -1;) {
                            for (s = 0; 3 > s; s++) n = f[o][s], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                            n = f[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                        }
                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                },
                set: function(e) {
                    var i, n, r, o, s, a, l, c, h, u, d = this._segCount,
                        p = this._func,
                        f = this._target,
                        m = e !== this._startRatio;
                    if (this._timeRes) {
                        if (h = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && d - 1 > r) {
                            for (c = d - 1; c > r && (this._l2 = h[++r]) <= e;);
                            this._l1 = h[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                        } else if (e < this._l1 && r > 0) {
                            for (; r > 0 && (this._l1 = h[--r]) >= e;);
                            0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = h[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                        }
                        if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < u.length - 1) {
                            for (c = u.length - 1; c > r && (this._s2 = u[++r]) <= e;);
                            this._s1 = u[r - 1], this._si = r
                        } else if (e < this._s1 && r > 0) {
                            for (; r > 0 && (this._s1 = u[--r]) >= e;);
                            0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                        }
                        a = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                    } else a = (e - (i = 0 > e ? 0 : e >= 1 ? d - 1 : d * e >> 0) * (1 / d)) * d;
                    for (n = 1 - a, r = this._props.length; --r > -1;) o = this._props[r], l = (a * a * (s = this._beziers[o][i]).da + 3 * n * (a * s.ca + n * s.ba)) * a + s.a, this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l;
                    if (this._autoRotate) {
                        var g, v, y, _, x, w, b, T = this._autoRotate;
                        for (r = T.length; --r > -1;) o = T[r][2], w = T[r][3] || 0, b = !0 === T[r][4] ? 1 : t, s = this._beziers[T[r][0]], g = this._beziers[T[r][1]], s && g && (s = s[i], g = g[i], v = s.a + (s.b - s.a) * a, v += ((_ = s.b + (s.c - s.b) * a) - v) * a, _ += (s.c + (s.d - s.c) * a - _) * a, y = g.a + (g.b - g.a) * a, y += ((x = g.b + (g.c - g.b) * a) - y) * a, x += (g.c + (g.d - g.c) * a - x) * a, l = m ? Math.atan2(x - y, _ - v) * b + w : this._initialRotations[r], this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l)
                    }
                }
            }), m = f.prototype, f.bezierThrough = h, f.cubicToQuadratic = a, f._autoCSS = !0, f.quadraticToCubic = function(t, e, i) {
                return new s(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
            }, f._cssRegister = function() {
                var t = o.CSSPlugin;
                if (t) {
                    var e = t._internals,
                        i = e._parseToProxy,
                        n = e._setPluginRatio,
                        r = e.CSSPropTween;
                    e._registerComplexSpecialProp("bezier", {
                        parser: function(t, e, o, s, a, l) {
                            e instanceof Array && (e = {
                                values: e
                            }), l = new f;
                            var c, h, u, d = e.values,
                                p = d.length - 1,
                                m = [],
                                g = {};
                            if (0 > p) return a;
                            for (c = 0; p >= c; c++) u = i(t, d[c], s, a, l, p !== c), m[c] = u.end;
                            for (h in e) g[h] = e[h];
                            return g.values = m, (a = new r(t, "bezier", 0, 0, u.pt, 2)).data = u, a.plugin = l, a.setRatio = n, 0 === g.autoRotate && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (c = !0 === g.autoRotate ? 0 : Number(g.autoRotate), g.autoRotate = null != u.end.left ? [
                                ["left", "top", "rotation", c, !1]
                            ] : null != u.end.x && [
                                ["x", "y", "rotation", c, !1]
                            ]), g.autoRotate && (s._transform || s._enableTransforms(!1), u.autoRotate = s._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, s._overwriteProps.push("rotation")), l._onInitTween(u.proxy, g, s._tween), a
                        }
                    })
                }
            }, m._mod = function(t) {
                for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
            }, m._kill = function(t) {
                var e, i, n = this._props;
                for (e in this._beziers)
                    if (e in t)
                        for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
                if (n = this._autoRotate)
                    for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
                return this._super._kill.call(this, t)
            }, _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                var i, n, r, o, s = function() {
                        t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                    },
                    a = _gsScope._gsDefine.globals,
                    l = {},
                    c = s.prototype = new t("css");
                c.constructor = s, s.version = "2.0.2", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, c = "px", s.suffixMap = {
                    top: c,
                    right: c,
                    bottom: c,
                    left: c,
                    width: c,
                    height: c,
                    fontSize: c,
                    padding: c,
                    margin: c,
                    perspective: c,
                    lineHeight: ""
                };
                var h, u, d, p, f, m, g, v, y = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                    _ = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                    x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                    w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                    b = /(?:\d|\-|\+|=|#|\.)*/g,
                    T = /opacity *= *([^)]*)/i,
                    S = /opacity:([^;]*)/i,
                    M = /alpha\(opacity *=.+?\)/i,
                    E = /^(rgb|hsl)/,
                    A = /([A-Z])/g,
                    P = /-([a-z])/gi,
                    C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                    R = function(t, e) {
                        return e.toUpperCase()
                    },
                    L = /(?:Left|Right|Width)/i,
                    O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                    k = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                    D = /,(?=[^\)]*(?:\(|$))/gi,
                    I = /[\s,\(]/i,
                    N = Math.PI / 180,
                    z = 180 / Math.PI,
                    F = {},
                    B = {
                        style: {}
                    },
                    H = _gsScope.document || {
                        createElement: function() {
                            return B
                        }
                    },
                    U = function(t, e) {
                        return H.createElementNS ? H.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : H.createElement(t)
                    },
                    G = U("div"),
                    j = U("img"),
                    V = s._internals = {
                        _specialProps: l
                    },
                    W = (_gsScope.navigator || {}).userAgent || "",
                    q = function() {
                        var t = W.indexOf("Android"),
                            e = U("a");
                        return d = -1 !== W.indexOf("Safari") && -1 === W.indexOf("Chrome") && (-1 === t || parseFloat(W.substr(t + 8, 2)) > 3), f = d && parseFloat(W.substr(W.indexOf("Version/") + 8, 2)) < 6, p = -1 !== W.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(W) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(W)) && (m = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                    }(),
                    X = function(t) {
                        return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                    },
                    $ = function(t) {
                        _gsScope.console && console.log(t)
                    },
                    Y = "",
                    Z = "",
                    J = function(t, e) {
                        var i, n, r = (e = e || G).style;
                        if (void 0 !== r[t]) return t;
                        for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                        return n >= 0 ? (Y = "-" + (Z = 3 === n ? "ms" : i[n]).toLowerCase() + "-", Z + t) : null
                    },
                    Q = ("undefined" != typeof window ? window : H.defaultView || {
                        getComputedStyle: function() {}
                    }).getComputedStyle,
                    K = s.getStyle = function(t, e, i, n, r) {
                        var o;
                        return q || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || Q(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(A, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : X(t)
                    },
                    tt = V.convertToPixels = function(t, i, n, r, o) {
                        if ("px" === r || !r && "lineHeight" !== i) return n;
                        if ("auto" === r || !n) return 0;
                        var a, l, c, h = L.test(i),
                            u = t,
                            d = G.style,
                            p = 0 > n,
                            f = 1 === n;
                        if (p && (n = -n), f && (n *= 100), "lineHeight" !== i || r)
                            if ("%" === r && -1 !== i.indexOf("border")) a = n / 100 * (h ? t.clientWidth : t.clientHeight);
                            else {
                                if (d.cssText = "border:0 solid red;position:" + K(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[h ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                                else {
                                    if (u = t.parentNode || H.body, -1 !== K(u, "display").indexOf("flex") && (d.position = "absolute"), l = u._gsCache, c = e.ticker.frame, l && h && l.time === c) return l.width * n / 100;
                                    d[h ? "width" : "height"] = n + r
                                }
                                u.appendChild(G), a = parseFloat(G[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), h && "%" === r && !1 !== s.cacheWidths && ((l = u._gsCache = u._gsCache || {}).time = c, l.width = a / n * 100), 0 !== a || o || (a = tt(t, i, n, r, !0))
                            }
                        else l = Q(t).lineHeight, t.style.lineHeight = n, a = parseFloat(Q(t).lineHeight), t.style.lineHeight = l;
                        return f && (a /= 100), p ? -a : a
                    },
                    et = V.calculateOffset = function(t, e, i) {
                        if ("absolute" !== K(t, "position", i)) return 0;
                        var n = "left" === e ? "Left" : "Top",
                            r = K(t, "margin" + n, i);
                        return t["offset" + n] - (tt(t, e, parseFloat(r), r.replace(b, "")) || 0)
                    },
                    it = function(t, e) {
                        var i, n, r, o = {};
                        if (e = e || Q(t, null))
                            if (i = e.length)
                                for (; --i > -1;)(-1 === (r = e[i]).indexOf("-transform") || Ct === r) && (o[r.replace(P, R)] = e.getPropertyValue(r));
                            else
                                for (i in e)(-1 === i.indexOf("Transform") || Pt === i) && (o[i] = e[i]);
                        else if (e = t.currentStyle || t.style)
                            for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(P, R)] = e[i]);
                        return q || (o.opacity = X(t)), n = Gt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, Lt && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
                    },
                    nt = function(t, e, i, n, r) {
                        var o, s, a, l = {},
                            c = t.style;
                        for (s in i) "cssText" !== s && "length" !== s && isNaN(s) && (e[s] !== (o = i[s]) || r && r[s]) && -1 === s.indexOf("Origin") && ("number" == typeof o || "string" == typeof o) && (l[s] = "auto" !== o || "left" !== s && "top" !== s ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[s] || "" === e[s].replace(w, "") ? o : 0 : et(t, s), void 0 !== c[s] && (a = new yt(c, s, c[s], a)));
                        if (n)
                            for (s in n) "className" !== s && (l[s] = n[s]);
                        return {
                            difs: l,
                            firstMPT: a
                        }
                    },
                    rt = {
                        width: ["Left", "Right"],
                        height: ["Top", "Bottom"]
                    },
                    ot = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                    st = function(t, e, i) {
                        if ("svg" === (t.nodeName + "").toLowerCase()) return (i || Q(t))[e] || 0;
                        if (t.getCTM && Bt(t)) return t.getBBox()[e] || 0;
                        var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                            r = rt[e],
                            o = r.length;
                        for (i = i || Q(t, null); --o > -1;) n -= parseFloat(K(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(K(t, "border" + r[o] + "Width", i, !0)) || 0;
                        return n
                    },
                    at = function(t, e) {
                        if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                        (null == t || "" === t) && (t = "0 0");
                        var i, n = t.split(" "),
                            r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                            o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                        if (n.length > 3 && !e) {
                            for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(at(n[i]));
                            return t.join(",")
                        }
                        return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(w, "")), e.oy = parseFloat(o.replace(w, "")), e.v = t), e || t
                    },
                    lt = function(t, e) {
                        return "function" == typeof t && (t = t(v, g)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                    },
                    ct = function(t, e) {
                        "function" == typeof t && (t = t(v, g));
                        var i = "string" == typeof t && "=" === t.charAt(1);
                        return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (i ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? t.substr(2) : t) / 100)), null == t ? e : i ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                    },
                    ht = function(t, e, i, n) {
                        var r, o, s, a, l;
                        return "function" == typeof t && (t = t(v, g)), null == t ? a = e : "number" == typeof t ? a = t : (r = 360, o = t.split("_"), s = ((l = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : z) - (l ? 0 : e), o.length && (n && (n[i] = e + s), -1 !== t.indexOf("short") && ((s %= r) !== s % 180 && (s = 0 > s ? s + r : s - r)), -1 !== t.indexOf("_cw") && 0 > s ? s = (s + 9999999999 * r) % r - (s / r | 0) * r : -1 !== t.indexOf("ccw") && s > 0 && (s = (s - 9999999999 * r) % r - (s / r | 0) * r)), a = e + s), 1e-6 > a && a > -1e-6 && (a = 0), a
                    },
                    ut = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        fuchsia: [255, 0, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    },
                    dt = function(t, e, i) {
                        return 255 * (1 > 6 * (t = 0 > t ? t + 1 : t > 1 ? t - 1 : t) ? e + (i - e) * t * 6 : .5 > t ? i : 2 > 3 * t ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                    },
                    pt = s.parseColor = function(t, e) {
                        var i, n, r, o, s, a, l, c, h, u, d;
                        if (t)
                            if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                            else {
                                if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ut[t]) i = ut[t];
                                else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + n + n + r + r + o + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                                else if ("hsl" === t.substr(0, 3))
                                    if (i = d = t.match(y), e) {
                                        if (-1 !== t.indexOf("=")) return t.match(_)
                                    } else s = Number(i[0]) % 360 / 360, a = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = .5 >= l ? l * (a + 1) : l + a - l * a), i.length > 3 && (i[3] = Number(i[3])), i[0] = dt(s + 1 / 3, n, r), i[1] = dt(s, n, r), i[2] = dt(s - 1 / 3, n, r);
                                else i = t.match(y) || ut.transparent;
                                i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                            }
                        else i = ut.black;
                        return e && !d && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, l = ((c = Math.max(n, r, o)) + (h = Math.min(n, r, o))) / 2, c === h ? s = a = 0 : (u = c - h, a = l > .5 ? u / (2 - c - h) : u / (c + h), s = c === n ? (r - o) / u + (o > r ? 6 : 0) : c === r ? (o - n) / u + 2 : (n - r) / u + 4, s *= 60), i[0] = s + .5 | 0, i[1] = 100 * a + .5 | 0, i[2] = 100 * l + .5 | 0), i
                    },
                    ft = function(t, e) {
                        var i, n, r, o = t.match(mt) || [],
                            s = 0,
                            a = "";
                        if (!o.length) return t;
                        for (i = 0; i < o.length; i++) n = o[i], s += (r = t.substr(s, t.indexOf(n, s) - s)).length + n.length, 3 === (n = pt(n, e)).length && n.push(1), a += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                        return a + t.substr(s)
                    },
                    mt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                for (c in ut) mt += "|" + c + "\\b";
                mt = new RegExp(mt + ")", "gi"), s.colorStringFilter = function(t) {
                    var e, i = t[0] + " " + t[1];
                    mt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = ft(t[0], e), t[1] = ft(t[1], e)), mt.lastIndex = 0
                }, e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                var gt = function(t, e, i, n) {
                        if (null == t) return function(t) {
                            return t
                        };
                        var r, o = e ? (t.match(mt) || [""])[0] : "",
                            s = t.split(o).join("").match(x) || [],
                            a = t.substr(0, t.indexOf(s[0])),
                            l = ")" === t.charAt(t.length - 1) ? ")" : "",
                            c = -1 !== t.indexOf(" ") ? " " : ",",
                            h = s.length,
                            u = h > 0 ? s[0].replace(y, "") : "";
                        return h ? r = e ? function(t) {
                            var e, d, p, f;
                            if ("number" == typeof t) t += u;
                            else if (n && D.test(t)) {
                                for (f = t.replace(D, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                                return f.join(",")
                            }
                            if (e = (t.match(mt) || [o])[0], p = (d = t.split(e).join("").match(x) || []).length, h > p--)
                                for (; ++p < h;) d[p] = i ? d[(p - 1) / 2 | 0] : s[p];
                            return a + d.join(c) + c + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
                        } : function(t) {
                            var e, o, d;
                            if ("number" == typeof t) t += u;
                            else if (n && D.test(t)) {
                                for (o = t.replace(D, "|").split("|"), d = 0; d < o.length; d++) o[d] = r(o[d]);
                                return o.join(",")
                            }
                            if (d = (e = t.match(x) || []).length, h > d--)
                                for (; ++d < h;) e[d] = i ? e[(d - 1) / 2 | 0] : s[d];
                            return a + e.join(c) + l
                        } : function(t) {
                            return t
                        }
                    },
                    vt = function(t) {
                        return t = t.split(","),
                            function(e, i, n, r, o, s, a) {
                                var l, c = (i + "").split(" ");
                                for (a = {}, l = 0; 4 > l; l++) a[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                                return r.parse(e, a, o, s)
                            }
                    },
                    yt = (V._setPluginRatio = function(t) {
                        this.plugin.setRatio(t);
                        for (var e, i, n, r, o, s = this.data, a = s.proxy, l = s.firstMPT; l;) e = a[l.v], l.r ? e = l.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next;
                        if (s.autoRotate && (s.autoRotate.rotation = s.mod ? s.mod.call(this._tween, a.rotation, this.t, this._tween) : a.rotation), 1 === t || 0 === t)
                            for (l = s.firstMPT, o = 1 === t ? "e" : "b"; l;) {
                                if ((i = l.t).type) {
                                    if (1 === i.type) {
                                        for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                        i[o] = r
                                    }
                                } else i[o] = i.s + i.xs0;
                                l = l._next
                            }
                    }, function(t, e, i, n, r) {
                        this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
                    }),
                    _t = (V._parseToProxy = function(t, e, i, n, r, o) {
                        var s, a, l, c, h, u = n,
                            d = {},
                            p = {},
                            f = i._transform,
                            m = F;
                        for (i._transform = null, F = e, n = h = i.parse(t, e, n, r), F = m, o && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                            if (n.type <= 1 && (p[a = n.p] = n.s + n.c, d[a] = n.s, o || (c = new yt(n, "s", a, c, n.r), n.c = 0), 1 === n.type))
                                for (s = n.l; --s > 0;) l = "xn" + s, p[a = n.p + "_" + l] = n.data[l], d[a] = n[l], o || (c = new yt(n, l, a, c, n.rxp[l]));
                            n = n._next
                        }
                        return {
                            proxy: d,
                            end: p,
                            firstMPT: c,
                            pt: h
                        }
                    }, V.CSSPropTween = function(t, e, n, r, s, a, l, c, h, u, d) {
                        this.t = t, this.p = e, this.s = n, this.c = r, this.n = l || e, t instanceof _t || o.push(this.n), this.r = c ? "function" == typeof c ? c : Math.round : c, this.type = a || 0, h && (this.pr = h, i = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + r : d, s && (this._next = s, s._prev = this)
                    }),
                    xt = function(t, e, i, n, r, o) {
                        var s = new _t(t, e, i, n - i, r, -1, o);
                        return s.b = i, s.e = s.xs0 = n, s
                    },
                    wt = s.parseComplex = function(t, e, i, n, r, o, a, l, c, u) {
                        i = i || o || "", "function" == typeof n && (n = n(v, g)), a = new _t(t, e, 0, 0, a, u ? 2 : 1, null, !1, l, i, n), n += "", r && mt.test(n + i) && (n = [i, n], s.colorStringFilter(n), i = n[0], n = n[1]);
                        var d, p, f, m, x, w, b, T, S, M, E, A, P, C = i.split(", ").join(",").split(" "),
                            R = n.split(", ").join(",").split(" "),
                            L = C.length,
                            O = !1 !== h;
                        for ((-1 !== n.indexOf(",") || -1 !== i.indexOf(",")) && (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (C = C.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" ")) : (C = C.join(" ").split(",").join(", ").split(" "), R = R.join(" ").split(",").join(", ").split(" ")), L = C.length), L !== R.length && (L = (C = (o || "").split(" ")).length), a.plugin = c, a.setRatio = u, mt.lastIndex = 0, d = 0; L > d; d++)
                            if (m = C[d], x = R[d] + "", (T = parseFloat(m)) || 0 === T) a.appendXtra("", T, lt(x, T), x.replace(_, ""), !(!O || -1 === x.indexOf("px")) && Math.round, !0);
                            else if (r && mt.test(m)) A = ")" + ((A = x.indexOf(")") + 1) ? x.substr(A) : ""), P = -1 !== x.indexOf("hsl") && q, M = x, m = pt(m, P), x = pt(x, P), (S = m.length + x.length > 6) && !q && 0 === x[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[d]).join("transparent")) : (q || (S = !1), P ? a.appendXtra(M.substr(0, M.indexOf("hsl")) + (S ? "hsla(" : "hsl("), m[0], lt(x[0], m[0]), ",", !1, !0).appendXtra("", m[1], lt(x[1], m[1]), "%,", !1).appendXtra("", m[2], lt(x[2], m[2]), S ? "%," : "%" + A, !1) : a.appendXtra(M.substr(0, M.indexOf("rgb")) + (S ? "rgba(" : "rgb("), m[0], x[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], x[1] - m[1], ",", Math.round).appendXtra("", m[2], x[2] - m[2], S ? "," : A, Math.round), S && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (x.length < 4 ? 1 : x[3]) - m, A, !1))), mt.lastIndex = 0;
                        else if (w = m.match(y)) {
                            if (!(b = x.match(_)) || b.length !== w.length) return a;
                            for (f = 0, p = 0; p < w.length; p++) E = w[p], M = m.indexOf(E, f), a.appendXtra(m.substr(f, M - f), Number(E), lt(b[p], E), "", !(!O || "px" !== m.substr(M + E.length, 2)) && Math.round, 0 === p), f = M + E.length;
                            a["xs" + a.l] += m.substr(f)
                        } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + x : x;
                        if (-1 !== n.indexOf("=") && a.data) {
                            for (A = a.xs0 + a.data.s, d = 1; d < a.l; d++) A += a["xs" + d] + a.data["xn" + d];
                            a.e = A + a["xs" + d]
                        }
                        return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                    },
                    bt = 9;
                for ((c = _t.prototype).l = c.pr = 0; --bt > 0;) c["xn" + bt] = 0, c["xs" + bt] = "";
                c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function(t, e, i, n, r, o) {
                    var s = this,
                        a = s.l;
                    return s["xs" + a] += o && (a || s["xs" + a]) ? " " + t : t || "", i || 0 === a || s.plugin ? (s.l++, s.type = s.setRatio ? 2 : 1, s["xs" + s.l] = n || "", a > 0 ? (s.data["xn" + a] = e + i, s.rxp["xn" + a] = r, s["xn" + a] = e, s.plugin || (s.xfirst = new _t(s, "xn" + a, e, i, s.xfirst || s, 0, s.n, r, s.pr), s.xfirst.xs0 = 0), s) : (s.data = {
                        s: e + i
                    }, s.rxp = {}, s.s = e, s.c = i, s.r = r, s)) : (s["xs" + a] += e + (n || ""), s)
                };
                var Tt = function(t, e) {
                        e = e || {}, this.p = e.prefix && J(t) || t, l[t] = l[this.p] = this, this.format = e.formatter || gt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                    },
                    St = V._registerComplexSpecialProp = function(t, e, i) {
                        "object" != typeof e && (e = {
                            parser: i
                        });
                        var n, r = t.split(","),
                            o = e.defaultValue;
                        for (i = i || [o], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new Tt(r[n], e)
                    },
                    Mt = V._registerPluginProp = function(t) {
                        if (!l[t]) {
                            var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                            St(t, {
                                parser: function(t, i, n, r, o, s, c) {
                                    var h = a.com.greensock.plugins[e];
                                    return h ? (h._cssRegister(), l[n].parse(t, i, n, r, o, s, c)) : ($("Error: " + e + " js file not loaded."), o)
                                }
                            })
                        }
                    };
                (c = Tt.prototype).parseComplex = function(t, e, i, n, r, o) {
                    var s, a, l, c, h, u, d = this.keyword;
                    if (this.multi && (D.test(i) || D.test(e) ? (a = e.replace(D, "|").split("|"), l = i.replace(D, "|").split("|")) : d && (a = [e], l = [i])), l) {
                        for (c = l.length > a.length ? l.length : a.length, s = 0; c > s; s++) e = a[s] = a[s] || this.dflt, i = l[s] = l[s] || this.dflt, d && ((h = e.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? a[s] = a[s].split(d).join("") : -1 === h && (a[s] += " " + d)));
                        e = a.join(", "), i = l.join(", ")
                    }
                    return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
                }, c.parse = function(t, e, i, n, o, s, a) {
                    return this.parseComplex(t.style, this.format(K(t, this.p, r, !1, this.dflt)), this.format(e), o, s)
                }, s.registerSpecialProp = function(t, e, i) {
                    St(t, {
                        parser: function(t, n, r, o, s, a, l) {
                            var c = new _t(t, r, 0, 0, s, 2, r, !1, i);
                            return c.plugin = a, c.setRatio = e(t, n, o._tween, r), c
                        },
                        priority: i
                    })
                }, s.useSVGTransformAttr = !0;
                var Et, At = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                    Pt = J("transform"),
                    Ct = Y + "transform",
                    Rt = J("transformOrigin"),
                    Lt = null !== J("perspective"),
                    Ot = V.Transform = function() {
                        this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(!1 === s.defaultForce3D || !Lt) && (s.defaultForce3D || "auto")
                    },
                    kt = _gsScope.SVGElement,
                    Dt = function(t, e, i) {
                        var n, r = H.createElementNS("http://www.w3.org/2000/svg", t),
                            o = /([a-z])([A-Z])/g;
                        for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                        return e.appendChild(r), r
                    },
                    It = H.documentElement || {},
                    Nt = function() {
                        var t, e, i, n = m || /Android/i.test(W) && !_gsScope.chrome;
                        return H.createElementNS && !n && (t = Dt("svg", It), i = (e = Dt("rect", t, {
                            width: 100,
                            height: 50,
                            x: 100
                        })).getBoundingClientRect().width, e.style[Rt] = "50% 50%", e.style[Pt] = "scaleX(0.5)", n = i === e.getBoundingClientRect().width && !(p && Lt), It.removeChild(t)), n
                    }(),
                    zt = function(t, e, i, n, r, o) {
                        var a, l, c, h, u, d, p, f, m, g, v, y, _, x, w = t._gsTransform,
                            b = Ut(t, !0);
                        w && (_ = w.xOrigin, x = w.yOrigin), (!n || (a = n.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
                            x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                            y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                            width: 0,
                            height: 0
                        }), a = [(-1 !== (e = at(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = h = parseFloat(a[0]), i.yOrigin = u = parseFloat(a[1]), n && b !== Ht && (d = b[0], p = b[1], f = b[2], m = b[3], g = b[4], v = b[5], (y = d * m - p * f) && (l = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, c = h * (-p / y) + u * (d / y) - (d * v - p * g) / y, h = i.xOrigin = a[0] = l, u = i.yOrigin = a[1] = c)), w && (o && (i.xOffset = w.xOffset, i.yOffset = w.yOffset, w = i), r || !1 !== r && !1 !== s.defaultSmoothOrigin ? (l = h - _, c = u - x, w.xOffset += l * b[0] + c * b[2] - l, w.yOffset += l * b[1] + c * b[3] - c) : w.xOffset = w.yOffset = 0), o || t.setAttribute("data-svg-origin", a.join(" "))
                    },
                    Ft = function(t) {
                        var e, i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            n = this.parentNode,
                            r = this.nextSibling,
                            o = this.style.cssText;
                        if (It.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                            e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ft
                        } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                        return r ? n.insertBefore(this, r) : n.appendChild(this), It.removeChild(i), this.style.cssText = o, e
                    },
                    Bt = function(t) {
                        return !(!kt || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
                            try {
                                return t.getBBox()
                            } catch (e) {
                                return Ft.call(t, !0)
                            }
                        }(t))
                    },
                    Ht = [1, 0, 0, 1, 0, 0],
                    Ut = function(t, e) {
                        var i, n, r, o, s, a, l = t._gsTransform || new Ot,
                            c = t.style;
                        if (Pt ? n = K(t, Ct, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(O)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Pt || !(a = !Q(t) || "none" === Q(t).display) && t.parentNode || (a && (o = c.display, c.display = "block"), t.parentNode || (s = 1, It.appendChild(t)), i = !(n = K(t, Ct, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? c.display = o : a && qt(c, "display"), s && It.removeChild(t)), (l.svg || t.getCTM && Bt(t)) && (i && -1 !== (c[Pt] + "").indexOf("matrix") && (n = c[Pt], i = 0), r = t.getAttribute("transform"), i && r && (n = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return Ht;
                        for (r = (n || "").match(y) || [], bt = r.length; --bt > -1;) o = Number(r[bt]), r[bt] = (s = o - (o |= 0)) ? (1e5 * s + (0 > s ? -.5 : .5) | 0) / 1e5 + o : o;
                        return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                    },
                    Gt = V.getTransform = function(t, i, n, r) {
                        if (t._gsTransform && n && !r) return t._gsTransform;
                        var o, a, l, c, h, u, d = n && t._gsTransform || new Ot,
                            p = d.scaleX < 0,
                            f = 2e-5,
                            m = 1e5,
                            g = Lt && (parseFloat(K(t, Rt, i, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0,
                            v = parseFloat(s.defaultTransformPerspective) || 0;
                        if (d.svg = !(!t.getCTM || !Bt(t)), d.svg && (zt(t, K(t, Rt, i, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), Et = s.useSVGTransformAttr || Nt), (o = Ut(t)) !== Ht) {
                            if (16 === o.length) {
                                var y, _, x, w, b, T = o[0],
                                    S = o[1],
                                    M = o[2],
                                    E = o[3],
                                    A = o[4],
                                    P = o[5],
                                    C = o[6],
                                    R = o[7],
                                    L = o[8],
                                    O = o[9],
                                    k = o[10],
                                    D = o[12],
                                    I = o[13],
                                    N = o[14],
                                    F = o[11],
                                    B = Math.atan2(C, k);
                                d.zOrigin && (D = L * (N = -d.zOrigin) - o[12], I = O * N - o[13], N = k * N + d.zOrigin - o[14]), d.rotationX = B * z, B && (y = A * (w = Math.cos(-B)) + L * (b = Math.sin(-B)), _ = P * w + O * b, x = C * w + k * b, L = A * -b + L * w, O = P * -b + O * w, k = C * -b + k * w, F = R * -b + F * w, A = y, P = _, C = x), B = Math.atan2(-M, k), d.rotationY = B * z, B && (_ = S * (w = Math.cos(-B)) - O * (b = Math.sin(-B)), x = M * w - k * b, O = S * b + O * w, k = M * b + k * w, F = E * b + F * w, T = y = T * w - L * b, S = _, M = x), B = Math.atan2(S, T), d.rotation = B * z, B && (y = T * (w = Math.cos(B)) + S * (b = Math.sin(B)), _ = A * w + P * b, x = L * w + O * b, S = S * w - T * b, P = P * w - A * b, O = O * w - L * b, T = y, A = _, L = x), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), B = Math.atan2(A, P), d.scaleX = (Math.sqrt(T * T + S * S + M * M) * m + .5 | 0) / m, d.scaleY = (Math.sqrt(P * P + C * C) * m + .5 | 0) / m, d.scaleZ = (Math.sqrt(L * L + O * O + k * k) * m + .5 | 0) / m, T /= d.scaleX, A /= d.scaleY, S /= d.scaleX, P /= d.scaleY, Math.abs(B) > f ? (d.skewX = B * z, A = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(B))) : d.skewX = 0, d.perspective = F ? 1 / (0 > F ? -F : F) : 0, d.x = D, d.y = I, d.z = N, d.svg && (d.x -= d.xOrigin - (d.xOrigin * T - d.yOrigin * A), d.y -= d.yOrigin - (d.yOrigin * S - d.xOrigin * P))
                            } else if (!Lt || r || !o.length || d.x !== o[4] || d.y !== o[5] || !d.rotationX && !d.rotationY) {
                                var H = o.length >= 6,
                                    U = H ? o[0] : 1,
                                    G = o[1] || 0,
                                    j = o[2] || 0,
                                    V = H ? o[3] : 1;
                                d.x = o[4] || 0, d.y = o[5] || 0, l = Math.sqrt(U * U + G * G), c = Math.sqrt(V * V + j * j), h = U || G ? Math.atan2(G, U) * z : d.rotation || 0, u = j || V ? Math.atan2(j, V) * z + h : d.skewX || 0, d.scaleX = l, d.scaleY = c, d.rotation = h, d.skewX = u, Lt && (d.rotationX = d.rotationY = d.z = 0, d.perspective = v, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * U + d.yOrigin * j), d.y -= d.yOrigin - (d.xOrigin * G + d.yOrigin * V))
                            }
                            for (a in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = g, d) d[a] < f && d[a] > -f && (d[a] = 0)
                        }
                        return n && (t._gsTransform = d, d.svg && (Et && t.style[Pt] ? e.delayedCall(.001, function() {
                            qt(t.style, Pt)
                        }) : !Et && t.getAttribute("transform") && e.delayedCall(.001, function() {
                            t.removeAttribute("transform")
                        }))), d
                    },
                    jt = function(t) {
                        var e, i, n = this.data,
                            r = -n.rotation * N,
                            o = r + n.skewX * N,
                            s = 1e5,
                            a = (Math.cos(r) * n.scaleX * s | 0) / s,
                            l = (Math.sin(r) * n.scaleX * s | 0) / s,
                            c = (Math.sin(o) * -n.scaleY * s | 0) / s,
                            h = (Math.cos(o) * n.scaleY * s | 0) / s,
                            u = this.t.style,
                            d = this.t.currentStyle;
                        if (d) {
                            i = l, l = -c, c = -i, e = d.filter, u.filter = "";
                            var p, f, g = this.t.offsetWidth,
                                v = this.t.offsetHeight,
                                y = "absolute" !== d.position,
                                _ = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + l + ", M21=" + c + ", M22=" + h,
                                x = n.x + g * n.xPercent / 100,
                                w = n.y + v * n.yPercent / 100;
                            if (null != n.ox && (x += (p = (n.oxp ? g * n.ox * .01 : n.ox) - g / 2) - (p * a + (f = (n.oyp ? v * n.oy * .01 : n.oy) - v / 2) * l), w += f - (p * c + f * h)), y ? _ += ", Dx=" + ((p = g / 2) - (p * a + (f = v / 2) * l) + x) + ", Dy=" + (f - (p * c + f * h) + w) + ")" : _ += ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = e.replace(k, _) : u.filter = _ + " " + e, (0 === t || 1 === t) && 1 === a && 0 === l && 0 === c && 1 === h && (y && -1 === _.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && u.removeAttribute("filter")), !y) {
                                var S, M, E, A = 8 > m ? 1 : -1;
                                for (p = n.ieOffsetX || 0, f = n.ieOffsetY || 0, n.ieOffsetX = Math.round((g - ((0 > a ? -a : a) * g + (0 > l ? -l : l) * v)) / 2 + x), n.ieOffsetY = Math.round((v - ((0 > h ? -h : h) * v + (0 > c ? -c : c) * g)) / 2 + w), bt = 0; 4 > bt; bt++) E = (i = -1 !== (S = d[M = ot[bt]]).indexOf("px") ? parseFloat(S) : tt(this.t, M, parseFloat(S), S.replace(b, "")) || 0) !== n[M] ? 2 > bt ? -n.ieOffsetX : -n.ieOffsetY : 2 > bt ? p - n.ieOffsetX : f - n.ieOffsetY, u[M] = (n[M] = Math.round(i - E * (0 === bt || 2 === bt ? 1 : A))) + "px"
                            }
                        }
                    },
                    Vt = V.set3DTransformRatio = V.setTransformRatio = function(t) {
                        var e, i, n, r, o, s, a, l, c, h, u, d, f, m, g, v, y, _, x, w, b, T, S, M = this.data,
                            E = this.t.style,
                            A = M.rotation,
                            P = M.rotationX,
                            C = M.rotationY,
                            R = M.scaleX,
                            L = M.scaleY,
                            O = M.scaleZ,
                            k = M.x,
                            D = M.y,
                            I = M.z,
                            z = M.svg,
                            F = M.perspective,
                            B = M.force3D,
                            H = M.skewY,
                            U = M.skewX;
                        if (H && (U += H, A += H), !((1 !== t && 0 !== t || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || I || F || C || P || 1 !== O) || Et && z || !Lt) A || U || z ? (A *= N, T = U * N, S = 1e5, i = Math.cos(A) * R, o = Math.sin(A) * R, n = Math.sin(A - T) * -L, s = Math.cos(A - T) * L, T && "simple" === M.skewType && (e = Math.tan(T - H * N), n *= e = Math.sqrt(1 + e * e), s *= e, H && (e = Math.tan(H * N), i *= e = Math.sqrt(1 + e * e), o *= e)), z && (k += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, D += M.yOrigin - (M.xOrigin * o + M.yOrigin * s) + M.yOffset, Et && (M.xPercent || M.yPercent) && (g = this.t.getBBox(), k += .01 * M.xPercent * g.width, D += .01 * M.yPercent * g.height), (g = 1e-6) > k && k > -g && (k = 0), g > D && D > -g && (D = 0)), x = (i * S | 0) / S + "," + (o * S | 0) / S + "," + (n * S | 0) / S + "," + (s * S | 0) / S + "," + k + "," + D + ")", z && Et ? this.t.setAttribute("transform", "matrix(" + x) : E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + x) : E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + R + ",0,0," + L + "," + k + "," + D + ")";
                        else {
                            if (p && ((g = 1e-4) > R && R > -g && (R = O = 2e-5), g > L && L > -g && (L = O = 2e-5), !F || M.z || M.rotationX || M.rotationY || (F = 0)), A || U) A *= N, v = i = Math.cos(A), y = o = Math.sin(A), U && (A -= U * N, v = Math.cos(A), y = Math.sin(A), "simple" === M.skewType && (e = Math.tan((U - H) * N), v *= e = Math.sqrt(1 + e * e), y *= e, M.skewY && (e = Math.tan(H * N), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -y, s = v;
                            else {
                                if (!(C || P || 1 !== O || F || z)) return void(E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) translate3d(" : "translate3d(") + k + "px," + D + "px," + I + "px)" + (1 !== R || 1 !== L ? " scale(" + R + "," + L + ")" : ""));
                                i = s = 1, n = o = 0
                            }
                            h = 1, r = a = l = c = u = d = 0, f = F ? -1 / F : 0, m = M.zOrigin, g = 1e-6, w = ",", b = "0", (A = C * N) && (v = Math.cos(A), l = -(y = Math.sin(A)), u = f * -y, r = i * y, a = o * y, h = v, f *= v, i *= v, o *= v), (A = P * N) && (e = n * (v = Math.cos(A)) + r * (y = Math.sin(A)), _ = s * v + a * y, c = h * y, d = f * y, r = n * -y + r * v, a = s * -y + a * v, h *= v, f *= v, n = e, s = _), 1 !== O && (r *= O, a *= O, h *= O, f *= O), 1 !== L && (n *= L, s *= L, c *= L, d *= L), 1 !== R && (i *= R, o *= R, l *= R, u *= R), (m || z) && (m && (k += r * -m, D += a * -m, I += h * -m + m), z && (k += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, D += M.yOrigin - (M.xOrigin * o + M.yOrigin * s) + M.yOffset), g > k && k > -g && (k = b), g > D && D > -g && (D = b), g > I && I > -g && (I = 0)), x = M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix3d(" : "matrix3d(", x += (g > i && i > -g ? b : i) + w + (g > o && o > -g ? b : o) + w + (g > l && l > -g ? b : l), x += w + (g > u && u > -g ? b : u) + w + (g > n && n > -g ? b : n) + w + (g > s && s > -g ? b : s), P || C || 1 !== O ? (x += w + (g > c && c > -g ? b : c) + w + (g > d && d > -g ? b : d) + w + (g > r && r > -g ? b : r), x += w + (g > a && a > -g ? b : a) + w + (g > h && h > -g ? b : h) + w + (g > f && f > -g ? b : f) + w) : x += ",0,0,0,0,1,0,", x += k + w + D + w + I + w + (F ? 1 + -I / F : 1) + ")", E[Pt] = x
                        }
                    };
                (c = Ot.prototype).x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, St("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                    parser: function(t, e, i, n, o, a, l) {
                        if (n._lastParsedTransform === l) return o;
                        n._lastParsedTransform = l;
                        var c, h = l.scale && "function" == typeof l.scale ? l.scale : 0;
                        "function" == typeof l[i] && (c = l[i], l[i] = e), h && (l.scale = h(v, t));
                        var u, d, p, f, m, y, _, x, w, b = t._gsTransform,
                            T = t.style,
                            S = At.length,
                            M = l,
                            E = {},
                            A = "transformOrigin",
                            P = Gt(t, r, !0, M.parseTransform),
                            C = M.transform && ("function" == typeof M.transform ? M.transform(v, g) : M.transform);
                        if (P.skewType = M.skewType || P.skewType || s.defaultSkewType, n._transform = P, "rotationZ" in M && (M.rotation = M.rotationZ), C && "string" == typeof C && Pt)(d = G.style)[Pt] = C, d.display = "block", d.position = "absolute", -1 !== C.indexOf("%") && (d.width = K(t, "width"), d.height = K(t, "height")), H.body.appendChild(G), u = Gt(G, null, !1), "simple" === P.skewType && (u.scaleY *= Math.cos(u.skewX * N)), P.svg && (y = P.xOrigin, _ = P.yOrigin, u.x -= P.xOffset, u.y -= P.yOffset, (M.transformOrigin || M.svgOrigin) && (C = {}, zt(t, at(M.transformOrigin), C, M.svgOrigin, M.smoothOrigin, !0), y = C.xOrigin, _ = C.yOrigin, u.x -= C.xOffset - P.xOffset, u.y -= C.yOffset - P.yOffset), (y || _) && (x = Ut(G, !0), u.x -= y - (y * x[0] + _ * x[2]), u.y -= _ - (y * x[1] + _ * x[3]))), H.body.removeChild(G), u.perspective || (u.perspective = P.perspective), null != M.xPercent && (u.xPercent = ct(M.xPercent, P.xPercent)), null != M.yPercent && (u.yPercent = ct(M.yPercent, P.yPercent));
                        else if ("object" == typeof M) {
                            if (u = {
                                    scaleX: ct(null != M.scaleX ? M.scaleX : M.scale, P.scaleX),
                                    scaleY: ct(null != M.scaleY ? M.scaleY : M.scale, P.scaleY),
                                    scaleZ: ct(M.scaleZ, P.scaleZ),
                                    x: ct(M.x, P.x),
                                    y: ct(M.y, P.y),
                                    z: ct(M.z, P.z),
                                    xPercent: ct(M.xPercent, P.xPercent),
                                    yPercent: ct(M.yPercent, P.yPercent),
                                    perspective: ct(M.transformPerspective, P.perspective)
                                }, null != (m = M.directionalRotation))
                                if ("object" == typeof m)
                                    for (d in m) M[d] = m[d];
                                else M.rotation = m;
                            "string" == typeof M.x && -1 !== M.x.indexOf("%") && (u.x = 0, u.xPercent = ct(M.x, P.xPercent)), "string" == typeof M.y && -1 !== M.y.indexOf("%") && (u.y = 0, u.yPercent = ct(M.y, P.yPercent)), u.rotation = ht("rotation" in M ? M.rotation : "shortRotation" in M ? M.shortRotation + "_short" : P.rotation, P.rotation, "rotation", E), Lt && (u.rotationX = ht("rotationX" in M ? M.rotationX : "shortRotationX" in M ? M.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", E), u.rotationY = ht("rotationY" in M ? M.rotationY : "shortRotationY" in M ? M.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", E)), u.skewX = ht(M.skewX, P.skewX), u.skewY = ht(M.skewY, P.skewY)
                        }
                        for (Lt && null != M.force3D && (P.force3D = M.force3D, f = !0), (p = P.force3D || P.z || P.rotationX || P.rotationY || u.z || u.rotationX || u.rotationY || u.perspective) || null == M.scale || (u.scaleZ = 1); --S > -1;)((C = u[w = At[S]] - P[w]) > 1e-6 || -1e-6 > C || null != M[w] || null != F[w]) && (f = !0, o = new _t(P, w, P[w], C, o), w in E && (o.e = E[w]), o.xs0 = 0, o.plugin = a, n._overwriteProps.push(o.n));
                        return C = M.transformOrigin, P.svg && (C || M.svgOrigin) && (y = P.xOffset, _ = P.yOffset, zt(t, at(C), u, M.svgOrigin, M.smoothOrigin), o = xt(P, "xOrigin", (b ? P : u).xOrigin, u.xOrigin, o, A), o = xt(P, "yOrigin", (b ? P : u).yOrigin, u.yOrigin, o, A), (y !== P.xOffset || _ !== P.yOffset) && (o = xt(P, "xOffset", b ? y : P.xOffset, P.xOffset, o, A), o = xt(P, "yOffset", b ? _ : P.yOffset, P.yOffset, o, A)), C = "0px 0px"), (C || Lt && p && P.zOrigin) && (Pt ? (f = !0, w = Rt, C = (C || K(t, w, r, !1, "50% 50%")) + "", (o = new _t(T, w, 0, 0, o, -1, A)).b = T[w], o.plugin = a, Lt ? (d = P.zOrigin, C = C.split(" "), P.zOrigin = (C.length > 2 && (0 === d || "0px" !== C[2]) ? parseFloat(C[2]) : d) || 0, o.xs0 = o.e = C[0] + " " + (C[1] || "50%") + " 0px", (o = new _t(P, "zOrigin", 0, 0, o, -1, o.n)).b = d, o.xs0 = o.e = P.zOrigin) : o.xs0 = o.e = C) : at(C + "", P)), f && (n._transformType = P.svg && Et || !p && 3 !== this._transformType ? 2 : 3), c && (l[i] = c), h && (l.scale = h), o
                    },
                    prefix: !0
                }), St("boxShadow", {
                    defaultValue: "0px 0px 0px 0px #999",
                    prefix: !0,
                    color: !0,
                    multi: !0,
                    keyword: "inset"
                }), St("borderRadius", {
                    defaultValue: "0px",
                    parser: function(t, e, i, o, s, a) {
                        e = this.format(e);
                        var l, c, h, u, d, p, f, m, g, v, y, _, x, w, b, T, S = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                            M = t.style;
                        for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(" "), c = 0; c < S.length; c++) this.p.indexOf("border") && (S[c] = J(S[c])), -1 !== (d = u = K(t, S[c], r, !1, "0px")).indexOf(" ") && (u = d.split(" "), d = u[0], u = u[1]), p = h = l[c], f = parseFloat(d), _ = d.substr((f + "").length), (x = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (0 > m ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (w = tt(t, "borderLeft", f, _), b = tt(t, "borderTop", f, _), "%" === y ? (d = w / g * 100 + "%", u = b / v * 100 + "%") : "em" === y ? (d = w / (T = tt(t, "borderLeft", 1, "em")) + "em", u = b / T + "em") : (d = w + "px", u = b + "px"), x && (p = parseFloat(d) + m + y, h = parseFloat(u) + m + y)), s = wt(M, S[c], d + " " + u, p + " " + h, !1, "0px", s);
                        return s
                    },
                    prefix: !0,
                    formatter: gt("0px 0px 0px 0px", !1, !0)
                }), St("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                    defaultValue: "0px",
                    parser: function(t, e, i, n, o, s) {
                        return wt(t.style, i, this.format(K(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", o)
                    },
                    prefix: !0,
                    formatter: gt("0px 0px", !1, !0)
                }), St("backgroundPosition", {
                    defaultValue: "0 0",
                    parser: function(t, e, i, n, o, s) {
                        var a, l, c, h, u, d, p = "background-position",
                            f = r || Q(t, null),
                            g = this.format((f ? m ? f.getPropertyValue(p + "-x") + " " + f.getPropertyValue(p + "-y") : f.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                            v = this.format(e);
                        if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && ((d = K(t, "backgroundImage").replace(C, "")) && "none" !== d)) {
                            for (a = g.split(" "), l = v.split(" "), j.setAttribute("src", d), c = 2; --c > -1;)(h = -1 !== (g = a[c]).indexOf("%")) !== (-1 !== l[c].indexOf("%")) && (u = 0 === c ? t.offsetWidth - j.width : t.offsetHeight - j.height, a[c] = h ? parseFloat(g) / 100 * u + "px" : parseFloat(g) / u * 100 + "%");
                            g = a.join(" ")
                        }
                        return this.parseComplex(t.style, g, v, o, s)
                    },
                    formatter: at
                }), St("backgroundSize", {
                    defaultValue: "0 0",
                    formatter: function(t) {
                        return "co" === (t += "").substr(0, 2) ? t : at(-1 === t.indexOf(" ") ? t + " " + t : t)
                    }
                }), St("perspective", {
                    defaultValue: "0px",
                    prefix: !0
                }), St("perspectiveOrigin", {
                    defaultValue: "50% 50%",
                    prefix: !0
                }), St("transformStyle", {
                    prefix: !0
                }), St("backfaceVisibility", {
                    prefix: !0
                }), St("userSelect", {
                    prefix: !0
                }), St("margin", {
                    parser: vt("marginTop,marginRight,marginBottom,marginLeft")
                }), St("padding", {
                    parser: vt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                }), St("clip", {
                    defaultValue: "rect(0px,0px,0px,0px)",
                    parser: function(t, e, i, n, o, s) {
                        var a, l, c;
                        return 9 > m ? (l = t.currentStyle, c = 8 > m ? " " : ",", a = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", e = this.format(e).split(",").join(c)) : (a = this.format(K(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, a, e, o, s)
                    }
                }), St("textShadow", {
                    defaultValue: "0px 0px 0px #999",
                    color: !0,
                    multi: !0
                }), St("autoRound,strictUnits", {
                    parser: function(t, e, i, n, r) {
                        return r
                    }
                }), St("border", {
                    defaultValue: "0px solid #000",
                    parser: function(t, e, i, n, o, s) {
                        var a = K(t, "borderTopWidth", r, !1, "0px"),
                            l = this.format(e).split(" "),
                            c = l[0].replace(b, "");
                        return "px" !== c && (a = parseFloat(a) / tt(t, "borderTopWidth", 1, c) + c), this.parseComplex(t.style, this.format(a + " " + K(t, "borderTopStyle", r, !1, "solid") + " " + K(t, "borderTopColor", r, !1, "#000")), l.join(" "), o, s)
                    },
                    color: !0,
                    formatter: function(t) {
                        var e = t.split(" ");
                        return e[0] + " " + (e[1] || "solid") + " " + (t.match(mt) || ["#000"])[0]
                    }
                }), St("borderWidth", {
                    parser: vt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                }), St("float,cssFloat,styleFloat", {
                    parser: function(t, e, i, n, r, o) {
                        var s = t.style,
                            a = "cssFloat" in s ? "cssFloat" : "styleFloat";
                        return new _t(s, a, 0, 0, r, -1, i, !1, 0, s[a], e)
                    }
                });
                var Wt = function(t) {
                    var e, i = this.t,
                        n = i.filter || K(this.data, "filter") || "",
                        r = this.s + this.c * t | 0;
                    100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !K(this.data, "filter")) : (i.filter = n.replace(M, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(T, "opacity=" + r))
                };
                St("opacity,alpha,autoAlpha", {
                    defaultValue: "1",
                    parser: function(t, e, i, n, o, s) {
                        var a = parseFloat(K(t, "opacity", r, !1, "1")),
                            l = t.style,
                            c = "autoAlpha" === i;
                        return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), c && 1 === a && "hidden" === K(t, "visibility", r) && 0 !== e && (a = 0), q ? o = new _t(l, "opacity", a, e - a, o) : ((o = new _t(l, "opacity", 100 * a, 100 * (e - a), o)).xn1 = c ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = s, o.setRatio = Wt), c && ((o = new _t(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(o.n), n._overwriteProps.push(i)), o
                    }
                });
                var qt = function(t, e) {
                        e && (t.removeProperty ? (("ms" === e.substr(0, 2) || "webkit" === e.substr(0, 6)) && (e = "-" + e), t.removeProperty(e.replace(A, "-$1").toLowerCase())) : t.removeAttribute(e))
                    },
                    Xt = function(t) {
                        if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                            this.t.setAttribute("class", 0 === t ? this.b : this.e);
                            for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : qt(i, e.p), e = e._next;
                            1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                        } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                    };
                St("className", {
                    parser: function(t, e, n, o, s, a, l) {
                        var c, h, u, d, p, f = t.getAttribute("class") || "",
                            m = t.style.cssText;
                        if ((s = o._classNamePT = new _t(t, n, 0, 0, s, 2)).setRatio = Xt, s.pr = -11, i = !0, s.b = f, h = it(t, r), u = t._gsClassPT) {
                            for (d = {}, p = u.data; p;) d[p.p] = 1, p = p._next;
                            u.setRatio(1)
                        }
                        return t._gsClassPT = s, s.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", s.e), c = nt(t, h, it(t), l, d), t.setAttribute("class", f), s.data = c.firstMPT, t.style.cssText = m, s.xfirst = o.parse(t, c.difs, s, a)
                    }
                });
                var $t = function(t) {
                    if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                        var e, i, n, r, o, s = this.t.style,
                            a = l.transform.parse;
                        if ("all" === this.e) s.cssText = "", r = !0;
                        else
                            for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], l[i] && (l[i].parse === a ? r = !0 : i = "transformOrigin" === i ? Rt : l[i].p), qt(s, i);
                        r && (qt(s, Pt), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                    }
                };
                for (St("clearProps", {
                        parser: function(t, e, n, r, o) {
                            return (o = new _t(t, n, 0, 0, o, 2)).setRatio = $t, o.e = e, o.pr = -10, o.data = r._tween, i = !0, o
                        }
                    }), c = "bezier,throwProps,physicsProps,physics2D".split(","), bt = c.length; bt--;) Mt(c[bt]);
                (c = s.prototype)._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function(t, e, a, c) {
                    if (!t.nodeType) return !1;
                    this._target = g = t, this._tween = a, this._vars = e, v = c, h = e.autoRound, i = !1, n = e.suffixMap || s.suffixMap, r = Q(t, ""), o = this._overwriteProps;
                    var p, m, y, _, x, w, b, T, M, E = t.style;
                    if (u && "" === E.zIndex && (("auto" === (p = K(t, "zIndex", r)) || "" === p) && this._addLazySet(E, "zIndex", 0)), "string" == typeof e && (_ = E.cssText, p = it(t, r), E.cssText = _ + ";" + e, p = nt(t, p, it(t)).difs, !q && S.test(e) && (p.opacity = parseFloat(RegExp.$1)), e = p, E.cssText = _), e.className ? this._firstPT = m = l.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = m = this.parse(t, e, null), this._transformType) {
                        for (M = 3 === this._transformType, Pt ? d && (u = !0, "" === E.zIndex && (("auto" === (b = K(t, "zIndex", r)) || "" === b) && this._addLazySet(E, "zIndex", 0)), f && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (M ? "visible" : "hidden"))) : E.zoom = 1, y = m; y && y._next;) y = y._next;
                        T = new _t(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, y), T.setRatio = Pt ? Vt : jt, T.data = this._transform || Gt(t, r, !0), T.tween = a, T.pr = -1, o.pop()
                    }
                    if (i) {
                        for (; m;) {
                            for (w = m._next, y = _; y && y.pr > m.pr;) y = y._next;
                            (m._prev = y ? y._prev : x) ? m._prev._next = m: _ = m, (m._next = y) ? y._prev = m : x = m, m = w
                        }
                        this._firstPT = _
                    }
                    return !0
                }, c.parse = function(t, e, i, o) {
                    var s, a, c, u, d, p, f, m, y, _, x = t.style;
                    for (s in e) {
                        if ("function" == typeof(p = e[s]) && (p = p(v, g)), a = l[s]) i = a.parse(t, p, s, this, i, o, e);
                        else {
                            if ("--" === s.substr(0, 2)) {
                                this._tween._propLookup[s] = this._addTween.call(this._tween, t.style, "setProperty", Q(t).getPropertyValue(s) + "", p + "", s, !1, s);
                                continue
                            }
                            d = K(t, s, r) + "", y = "string" == typeof p, "color" === s || "fill" === s || "stroke" === s || -1 !== s.indexOf("Color") || y && E.test(p) ? (y || (p = ((p = pt(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), i = wt(x, s, d, p, !0, "transparent", i, 0, o)) : y && I.test(p) ? i = wt(x, s, d, p, !0, null, i, 0, o) : (f = (c = parseFloat(d)) || 0 === c ? d.substr((c + "").length) : "", ("" === d || "auto" === d) && ("width" === s || "height" === s ? (c = st(t, s, r), f = "px") : "left" === s || "top" === s ? (c = et(t, s, r), f = "px") : (c = "opacity" !== s ? 0 : 1, f = "")), (_ = y && "=" === p.charAt(1)) ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), m = p.replace(b, "")) : (u = parseFloat(p), m = y ? p.replace(b, "") : ""), "" === m && (m = s in n ? n[s] : f), p = u || 0 === u ? (_ ? u + c : u) + m : e[s], f !== m && ("" !== m || "lineHeight" === s) && (u || 0 === u) && c && (c = tt(t, s, c, f), "%" === m ? (c /= tt(t, s, 100, "%") / 100, !0 !== e.strictUnits && (d = c + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? c /= tt(t, s, 1, m) : "px" !== m && (u = tt(t, s, u, m), m = "px"), _ && (u || 0 === u) && (p = u + c + m)), _ && (u += c), !c && 0 !== c || !u && 0 !== u ? void 0 !== x[s] && (p || p + "" != "NaN" && null != p) ? (i = new _t(x, s, u || c || 0, 0, i, -1, s, !1, 0, d, p)).xs0 = "none" !== p || "display" !== s && -1 === s.indexOf("Style") ? p : d : $("invalid " + s + " tween value: " + e[s]) : (i = new _t(x, s, c, u - c, i, 0, s, !1 !== h && ("px" === m || "zIndex" === s), 0, d, p)).xs0 = m)
                        }
                        o && i && !i.plugin && (i.plugin = o)
                    }
                    return i
                }, c.setRatio = function(t) {
                    var e, i, n, r = this._firstPT;
                    if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                        if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                            for (; r;) {
                                if (e = r.c * t + r.s, r.r ? e = r.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), r.type)
                                    if (1 === r.type)
                                        if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                        else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                else {
                                    for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                    r.t[r.p] = i
                                } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                else r.t[r.p] = e + r.xs0;
                                r = r._next
                            } else
                                for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                        else
                            for (; r;) {
                                if (2 !== r.type)
                                    if (r.r && -1 !== r.type)
                                        if (e = r.r(r.s + r.c), r.type) {
                                            if (1 === r.type) {
                                                for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                r.t[r.p] = i
                                            }
                                        } else r.t[r.p] = e + r.xs0;
                                else r.t[r.p] = r.e;
                                else r.setRatio(t);
                                r = r._next
                            }
                }, c._enableTransforms = function(t) {
                    this._transform = this._transform || Gt(this._target, r, !0), this._transformType = this._transform.svg && Et || !t && 3 !== this._transformType ? 2 : 3
                };
                var Yt = function(t) {
                    this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                };
                c._addLazySet = function(t, e, i) {
                    var n = this._firstPT = new _t(t, e, 0, 0, this._firstPT, 2);
                    n.e = i, n.setRatio = Yt, n.data = this
                }, c._linkCSSP = function(t, e, i, n) {
                    return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                }, c._mod = function(t) {
                    for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
                }, c._kill = function(e) {
                    var i, n, r, o = e;
                    if (e.autoAlpha || e.alpha) {
                        for (n in o = {}, e) o[n] = e[n];
                        o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                    }
                    for (e.className && (i = this._classNamePT) && ((r = i.xfirst) && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
                    return t.prototype._kill.call(this, o)
                };
                var Zt = function(t, e, i) {
                    var n, r, o, s;
                    if (t.slice)
                        for (r = t.length; --r > -1;) Zt(t[r], e, i);
                    else
                        for (r = (n = t.childNodes).length; --r > -1;) s = (o = n[r]).type, o.style && (e.push(it(o)), i && i.push(o)), 1 !== s && 9 !== s && 11 !== s || !o.childNodes.length || Zt(o, e, i)
                };
                return s.cascadeTo = function(t, i, n) {
                    var r, o, s, a, l = e.to(t, i, n),
                        c = [l],
                        h = [],
                        u = [],
                        d = [],
                        p = e._internals.reservedProps;
                    for (t = l._targets || l.target, Zt(t, h, d), l.render(i, !0, !0), Zt(t, u), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;)
                        if ((o = nt(d[r], h[r], u[r])).firstMPT) {
                            for (s in o = o.difs, n) p[s] && (o[s] = n[s]);
                            for (s in a = {}, o) a[s] = h[r][s];
                            c.push(e.fromTo(d[r], i, a, o))
                        } return c
                }, t.activate([s]), s
            }, !0),
            function() {
                var t = _gsScope._gsDefine.plugin({
                        propName: "roundProps",
                        version: "1.7.0",
                        priority: -1,
                        API: 2,
                        init: function(t, e, i) {
                            return this._tween = i, !0
                        }
                    }),
                    e = function(t) {
                        var e = 1 > t ? Math.pow(10, (t + "").length - 2) : 1;
                        return function(i) {
                            return (Math.round(i / t) * t * e | 0) / e
                        }
                    },
                    i = function(t, e) {
                        for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
                    },
                    n = t.prototype;
                n._onInitAllProps = function() {
                    var t, n, r, o, s = this._tween,
                        a = s.vars.roundProps,
                        l = {},
                        c = s._propLookup.roundProps;
                    if ("object" != typeof a || a.push)
                        for ("string" == typeof a && (a = a.split(",")), r = a.length; --r > -1;) l[a[r]] = Math.round;
                    else
                        for (o in a) l[o] = e(a[o]);
                    for (o in l)
                        for (t = s._firstPT; t;) n = t._next, t.pg ? t.t._mod(l) : t.n === o && (2 === t.f && t.t ? i(t.t._firstPT, l[o]) : (this._add(t.t, o, t.s, t.c, l[o]), n && (n._prev = t._prev), t._prev ? t._prev._next = n : s._firstPT === t && (s._firstPT = n), t._next = t._prev = null, s._propLookup[o] = c)), t = n;
                    return !1
                }, n._add = function(t, e, i, n, r) {
                    this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
                }
            }(), _gsScope._gsDefine.plugin({
                propName: "attr",
                API: 2,
                version: "0.6.1",
                init: function(t, e, i, n) {
                    var r, o;
                    if ("function" != typeof t.setAttribute) return !1;
                    for (r in e) "function" == typeof(o = e[r]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                    return !0
                }
            }), _gsScope._gsDefine.plugin({
                propName: "directionalRotation",
                version: "0.3.1",
                API: 2,
                init: function(t, e, i, n) {
                    "object" != typeof e && (e = {
                        rotation: e
                    }), this.finals = {};
                    var r, o, s, a, l, c, h = !0 === e.useRadians ? 2 * Math.PI : 360;
                    for (r in e) "useRadians" !== r && ("function" == typeof(a = e[r]) && (a = a(n, t)), o = (c = (a + "").split("_"))[0], s = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), l = (a = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? s + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - s, c.length && (-1 !== (o = c.join("_")).indexOf("short") && ((l %= h) !== l % (h / 2) && (l = 0 > l ? l + h : l - h)), -1 !== o.indexOf("_cw") && 0 > l ? l = (l + 9999999999 * h) % h - (l / h | 0) * h : -1 !== o.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * h) % h - (l / h | 0) * h)), (l > 1e-6 || -1e-6 > l) && (this._addTween(t, r, s, s + l, r), this._overwriteProps.push(r)));
                    return !0
                },
                set: function(t) {
                    var e;
                    if (1 !== t) this._super.setRatio.call(this, t);
                    else
                        for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                }
            })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                var e, i, n, r, o = _gsScope.GreenSockGlobals || _gsScope,
                    s = o.com.greensock,
                    a = 2 * Math.PI,
                    l = Math.PI / 2,
                    c = s._class,
                    h = function(e, i) {
                        var n = c("easing." + e, function() {}, !0),
                            r = n.prototype = new t;
                        return r.constructor = n, r.getRatio = i, n
                    },
                    u = t.register || function() {},
                    d = function(t, e, i, n, r) {
                        var o = c("easing." + t, {
                            easeOut: new e,
                            easeIn: new i,
                            easeInOut: new n
                        }, !0);
                        return u(o, t), o
                    },
                    p = function(t, e, i) {
                        this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                    },
                    f = function(e, i) {
                        var n = c("easing." + e, function(t) {
                                this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                            }, !0),
                            r = n.prototype = new t;
                        return r.constructor = n, r.getRatio = i, r.config = function(t) {
                            return new n(t)
                        }, n
                    },
                    m = d("Back", f("BackOut", function(t) {
                        return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                    }), f("BackIn", function(t) {
                        return t * t * ((this._p1 + 1) * t - this._p1)
                    }), f("BackInOut", function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                    })),
                    g = c("easing.SlowMo", function(t, e, i) {
                        e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                    }, !0),
                    v = g.prototype = new t;
                return v.constructor = g, v.getRatio = function(t) {
                    var e = t + (.5 - t) * this._p;
                    return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                }, g.ease = new g(.7, .7), v.config = g.config = function(t, e, i) {
                    return new g(t, e, i)
                }, (v = (e = c("easing.SteppedEase", function(t, e) {
                    t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                }, !0)).prototype = new t).constructor = e, v.getRatio = function(t) {
                    return 0 > t ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                }, v.config = e.config = function(t, i) {
                    return new e(t, i)
                }, (v = (i = c("easing.ExpoScaleEase", function(t, e, i) {
                    this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
                }, !0)).prototype = new t).constructor = i, v.getRatio = function(t) {
                    return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
                }, v.config = i.config = function(t, e, n) {
                    return new i(t, e, n)
                }, (v = (n = c("easing.RoughEase", function(e) {
                    for (var i, n, r, o, s, a, l = (e = e || {}).taper || "none", c = [], h = 0, u = 0 | (e.points || 20), d = u, f = !1 !== e.randomize, m = !0 === e.clamp, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;) i = f ? Math.random() : 1 / u * d, n = g ? g.getRatio(i) : i, "none" === l ? r = v : "out" === l ? r = (o = 1 - i) * o * v : "in" === l ? r = i * i * v : .5 > i ? r = (o = 2 * i) * o * .5 * v : r = (o = 2 * (1 - i)) * o * .5 * v, f ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : 0 > n && (n = 0)), c[h++] = {
                        x: i,
                        y: n
                    };
                    for (c.sort(function(t, e) {
                            return t.x - e.x
                        }), a = new p(1, 1, null), d = u; --d > -1;) s = c[d], a = new p(s.x, s.y, a);
                    this._prev = new p(0, 0, 0 !== a.t ? a : a.next)
                }, !0)).prototype = new t).constructor = n, v.getRatio = function(t) {
                    var e = this._prev;
                    if (t > e.t) {
                        for (; e.next && t >= e.t;) e = e.next;
                        e = e.prev
                    } else
                        for (; e.prev && t <= e.t;) e = e.prev;
                    return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                }, v.config = function(t) {
                    return new n(t)
                }, n.ease = new n, d("Bounce", h("BounceOut", function(t) {
                    return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                }), h("BounceIn", function(t) {
                    return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                }), h("BounceInOut", function(t) {
                    var e = .5 > t;
                    return t = 1 / 2.75 > (t = e ? 1 - 2 * t : 2 * t - 1) ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                })), d("Circ", h("CircOut", function(t) {
                    return Math.sqrt(1 - (t -= 1) * t)
                }), h("CircIn", function(t) {
                    return -(Math.sqrt(1 - t * t) - 1)
                }), h("CircInOut", function(t) {
                    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                })), d("Elastic", (r = function(e, i, n) {
                    var r = c("easing." + e, function(t, e) {
                            this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (1 > t ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2
                        }, !0),
                        o = r.prototype = new t;
                    return o.constructor = r, o.getRatio = i, o.config = function(t, e) {
                        return new r(t, e)
                    }, r
                })("ElasticOut", function(t) {
                    return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                }, .3), r("ElasticIn", function(t) {
                    return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
                }, .3), r("ElasticInOut", function(t) {
                    return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                }, .45)), d("Expo", h("ExpoOut", function(t) {
                    return 1 - Math.pow(2, -10 * t)
                }), h("ExpoIn", function(t) {
                    return Math.pow(2, 10 * (t - 1)) - .001
                }), h("ExpoInOut", function(t) {
                    return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                })), d("Sine", h("SineOut", function(t) {
                    return Math.sin(t * l)
                }), h("SineIn", function(t) {
                    return 1 - Math.cos(t * l)
                }), h("SineInOut", function(t) {
                    return -.5 * (Math.cos(Math.PI * t) - 1)
                })), c("easing.EaseLookup", {
                    find: function(e) {
                        return t.map[e]
                    }
                }, !0), u(o.SlowMo, "SlowMo", "ease,"), u(n, "RoughEase", "ease,"), u(e, "SteppedEase", "ease,"), m
            }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(t, e) {
        "use strict";
        var i = {},
            n = t.document,
            r = t.GreenSockGlobals = t.GreenSockGlobals || t,
            o = r[e];
        if (o) return "undefined" != typeof module && module.exports && (module.exports = o), o;
        var s, a, l, c, h, u = function(t) {
                var e, i = t.split("."),
                    n = r;
                for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                return n
            },
            d = u("com.greensock"),
            p = 1e-10,
            f = function(t) {
                var e, i = [],
                    n = t.length;
                for (e = 0; e !== n; i.push(t[e++]));
                return i
            },
            m = function() {},
            g = function() {
                var t = Object.prototype.toString,
                    e = t.call([]);
                return function(i) {
                    return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                }
            }(),
            v = {},
            y = function(n, o, s, a) {
                this.sc = v[n] ? v[n].sc : [], v[n] = this, this.gsClass = null, this.func = s;
                var l = [];
                this.check = function(c) {
                    for (var h, d, p, f, m = o.length, g = m; --m > -1;)(h = v[o[m]] || new y(o[m], [])).gsClass ? (l[m] = h.gsClass, g--) : c && h.sc.push(this);
                    if (0 === g && s) {
                        if (p = (d = ("com.greensock." + n).split(".")).pop(), f = u(d.join("."))[p] = this.gsClass = s.apply(s, l), a)
                            if (r[p] = i[p] = f, "undefined" != typeof module && module.exports)
                                if (n === e)
                                    for (m in module.exports = i[e] = f, i) f[m] = i[m];
                                else i[e] && (i[e][p] = f);
                        else "function" == typeof define && define.amd && define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + n.split(".").pop(), [], function() {
                            return f
                        });
                        for (m = 0; m < this.sc.length; m++) this.sc[m].check()
                    }
                }, this.check(!0)
            },
            _ = t._gsDefine = function(t, e, i, n) {
                return new y(t, e, i, n)
            },
            x = d._class = function(t, e, i) {
                return e = e || function() {}, _(t, [], function() {
                    return e
                }, i), e
            };
        _.globals = r;
        var w = [0, 0, 1, 1],
            b = x("easing.Ease", function(t, e, i, n) {
                this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? w.concat(e) : w
            }, !0),
            T = b.map = {},
            S = b.register = function(t, e, i, n) {
                for (var r, o, s, a, l = e.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                    for (o = l[c], r = n ? x("easing." + o, null, !0) : d.easing[o] || {}, s = h.length; --s > -1;) a = h[s], T[o + "." + a] = T[a + o] = r[a] = t.getRatio ? t : t[a] || new t
            };
        for ((l = b.prototype)._calcEnd = !1, l.getRatio = function(t) {
                if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                var e = this._type,
                    i = this._power,
                    n = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
                return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : .5 > t ? n / 2 : 1 - n / 2
            }, a = (s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --a > -1;) l = s[a] + ",Power" + a, S(new b(null, null, 1, a), l, "easeOut", !0), S(new b(null, null, 2, a), l, "easeIn" + (0 === a ? ",easeNone" : "")), S(new b(null, null, 3, a), l, "easeInOut");
        T.linear = d.easing.Linear.easeIn, T.swing = d.easing.Quad.easeInOut;
        var M = x("events.EventDispatcher", function(t) {
            this._listeners = {}, this._eventTarget = t || this
        });
        (l = M.prototype).addEventListener = function(t, e, i, n, r) {
            r = r || 0;
            var o, s, a = this._listeners[t],
                l = 0;
            for (this !== c || h || c.wake(), null == a && (this._listeners[t] = a = []), s = a.length; --s > -1;)(o = a[s]).c === e && o.s === i ? a.splice(s, 1) : 0 === l && o.pr < r && (l = s + 1);
            a.splice(l, 0, {
                c: e,
                s: i,
                up: n,
                pr: r
            })
        }, l.removeEventListener = function(t, e) {
            var i, n = this._listeners[t];
            if (n)
                for (i = n.length; --i > -1;)
                    if (n[i].c === e) return void n.splice(i, 1)
        }, l.dispatchEvent = function(t) {
            var e, i, n, r = this._listeners[t];
            if (r)
                for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                    type: t,
                    target: i
                }) : n.c.call(n.s || i))
        };
        var E = t.requestAnimationFrame,
            A = t.cancelAnimationFrame,
            P = Date.now || function() {
                return (new Date).getTime()
            },
            C = P();
        for (a = (s = ["ms", "moz", "webkit", "o"]).length; --a > -1 && !E;) E = t[s[a] + "RequestAnimationFrame"], A = t[s[a] + "CancelAnimationFrame"] || t[s[a] + "CancelRequestAnimationFrame"];
        x("Ticker", function(t, e) {
            var i, r, o, s, a, l = this,
                u = P(),
                d = !(!1 === e || !E) && "auto",
                f = 500,
                g = 33,
                v = function(t) {
                    var e, n, c = P() - C;
                    c > f && (u += c - g), C += c, l.time = (C - u) / 1e3, e = l.time - a, (!i || e > 0 || !0 === t) && (l.frame++, a += e + (e >= s ? .004 : s - e), n = !0), !0 !== t && (o = r(v)), n && l.dispatchEvent("tick")
                };
            M.call(l), l.time = l.frame = 0, l.tick = function() {
                v(!0)
            }, l.lagSmoothing = function(t, e) {
                return arguments.length ? (f = t || 1 / p, void(g = Math.min(e, f, 0))) : 1 / p > f
            }, l.sleep = function() {
                null != o && (d && A ? A(o) : clearTimeout(o), r = m, o = null, l === c && (h = !1))
            }, l.wake = function(t) {
                null !== o ? l.sleep() : t ? u += -C + (C = P()) : l.frame > 10 && (C = P() - f + 5), r = 0 === i ? m : d && E ? E : function(t) {
                    return setTimeout(t, 1e3 * (a - l.time) + 1 | 0)
                }, l === c && (h = !0), v(2)
            }, l.fps = function(t) {
                return arguments.length ? (s = 1 / ((i = t) || 60), a = this.time + s, void l.wake()) : i
            }, l.useRAF = function(t) {
                return arguments.length ? (l.sleep(), d = t, void l.fps(i)) : d
            }, l.fps(t), setTimeout(function() {
                "auto" === d && l.frame < 5 && "hidden" !== (n || {}).visibilityState && l.useRAF(!1)
            }, 1500)
        }), (l = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker;
        var R = x("core.Animation", function(t, e) {
            if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, Y) {
                h || c.wake();
                var i = this.vars.useFrames ? $ : Y;
                i.add(this, i._time), this.vars.paused && this.paused(!0)
            }
        });
        c = R.ticker = new d.Ticker, (l = R.prototype)._dirty = l._gc = l._initted = l._paused = !1, l._totalTime = l._time = 0, l._rawPrevTime = -1, l._next = l._last = l._onUpdate = l._timeline = l.timeline = null, l._paused = !1;
        var L = function() {
            h && P() - C > 2e3 && ("hidden" !== (n || {}).visibilityState || !c.lagSmoothing()) && c.wake();
            var t = setTimeout(L, 2e3);
            t.unref && t.unref()
        };
        L(), l.play = function(t, e) {
            return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
        }, l.pause = function(t, e) {
            return null != t && this.seek(t, e), this.paused(!0)
        }, l.resume = function(t, e) {
            return null != t && this.seek(t, e), this.paused(!1)
        }, l.seek = function(t, e) {
            return this.totalTime(Number(t), !1 !== e)
        }, l.restart = function(t, e) {
            return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
        }, l.reverse = function(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
        }, l.render = function(t, e, i) {}, l.invalidate = function() {
            return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
        }, l.isActive = function() {
            var t, e = this._timeline,
                i = this._startTime;
            return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
        }, l._enabled = function(t, e) {
            return h || c.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
        }, l._kill = function(t, e) {
            return this._enabled(!1, !1)
        }, l.kill = function(t, e) {
            return this._kill(t, e), this
        }, l._uncache = function(t) {
            for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
            return this
        }, l._swapSelfInParams = function(t) {
            for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
            return i
        }, l._callback = function(t) {
            var e = this.vars,
                i = e[t],
                n = e[t + "Params"],
                r = e[t + "Scope"] || e.callbackScope || this;
            switch (n ? n.length : 0) {
                case 0:
                    i.call(r);
                    break;
                case 1:
                    i.call(r, n[0]);
                    break;
                case 2:
                    i.call(r, n[0], n[1]);
                    break;
                default:
                    i.apply(r, n)
            }
        }, l.eventCallback = function(t, e, i, n) {
            if ("on" === (t || "").substr(0, 2)) {
                var r = this.vars;
                if (1 === arguments.length) return r[t];
                null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = g(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
            }
            return this
        }, l.delay = function(t) {
            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
        }, l.duration = function(t) {
            return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
        }, l.totalDuration = function(t) {
            return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
        }, l.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
        }, l.totalTime = function(t, e, i) {
            if (h || c.wake(), !arguments.length) return this._totalTime;
            if (this._timeline) {
                if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                    this._dirty && this.totalDuration();
                    var n = this._totalDuration,
                        r = this._timeline;
                    if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                        for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                }
                this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (I.length && J(), this.render(t, e, !1), I.length && J())
            }
            return this
        }, l.progress = l.totalProgress = function(t, e) {
            var i = this.duration();
            return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
        }, l.startTime = function(t) {
            return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
        }, l.endTime = function(t) {
            return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
        }, l.timeScale = function(t) {
            if (!arguments.length) return this._timeScale;
            var e, i;
            for (t = t || p, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
            return this
        }, l.reversed = function(t) {
            return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
        }, l.paused = function(t) {
            if (!arguments.length) return this._paused;
            var e, i, n = this._timeline;
            return t != this._paused && n && (h || t || c.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
        };
        var O = x("core.SimpleTimeline", function(t) {
            R.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
        });
        (l = O.prototype = new R).constructor = O, l.kill()._gc = !1, l._first = l._last = l._recent = null, l._sortChildren = !1, l.add = l.insert = function(t, e, i, n) {
            var r, o;
            if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                for (o = t._startTime; r && r._startTime > o;) r = r._prev;
            return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
        }, l._remove = function(t, e) {
            return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
        }, l.render = function(t, e, i) {
            var n, r = this._first;
            for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
        }, l.rawTime = function() {
            return h || c.wake(), this._totalTime
        };
        var k = x("TweenLite", function(e, i, n) {
                if (R.call(this, i, n), this.render = k.prototype.render, null == e) throw "Cannot tween a null target.";
                this.target = e = "string" != typeof e ? e : k.selector(e) || e;
                var r, o, s, a = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                    l = this.vars.overwrite;
                if (this._overwrite = l = null == l ? X[k.defaultOverwrite] : "number" == typeof l ? l >> 0 : X[l], (a || e instanceof Array || e.push && g(e)) && "number" != typeof e[0])
                    for (this._targets = s = f(e), this._propLookup = [], this._siblings = [], r = 0; r < s.length; r++)(o = s[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (s.splice(r--, 1), this._targets = s = s.concat(f(o))) : (this._siblings[r] = Q(o, this, !1), 1 === l && this._siblings[r].length > 1 && tt(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = s[r--] = k.selector(o)) && s.splice(r + 1, 1) : s.splice(r--, 1);
                else this._propLookup = {}, this._siblings = Q(e, this, !1), 1 === l && this._siblings.length > 1 && tt(e, this, null, 1, this._siblings);
                (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -p, this.render(Math.min(0, -this._delay)))
            }, !0),
            D = function(e) {
                return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
            };
        (l = k.prototype = new R).constructor = k, l.kill()._gc = !1, l.ratio = 0, l._firstPT = l._targets = l._overwrittenProps = l._startAt = null, l._notifyPluginsOfEnabled = l._lazy = !1, k.version = "2.0.2", k.defaultEase = l._ease = new b(null, null, 1, 1), k.defaultOverwrite = "auto", k.ticker = c, k.autoSleep = 120, k.lagSmoothing = function(t, e) {
            c.lagSmoothing(t, e)
        }, k.selector = t.$ || t.jQuery || function(e) {
            var i = t.$ || t.jQuery;
            return i ? (k.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
        };
        var I = [],
            N = {},
            z = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            F = /[\+-]=-?[\.\d]/,
            B = function(t) {
                for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : 1e-6 > e && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
            },
            H = function(t, e, i, n) {
                var r, o, s, a, l, c, h, u = [],
                    d = 0,
                    p = "",
                    f = 0;
                for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(z) || [], o = e.match(z) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = o.length, a = 0; l > a; a++) h = o[a], p += (c = e.substr(d, e.indexOf(h, d) - d)) || !a ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[a] || r.length <= a ? p += h : (p && (u.push(p), p = ""), s = parseFloat(r[a]), u.push(s), u._firstPT = {
                    _next: u._firstPT,
                    t: u,
                    p: u.length - 1,
                    s: s,
                    c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - s) || 0,
                    f: 0,
                    m: f && 4 > f ? Math.round : 0
                }), d += h.length;
                return (p += e.substr(d)) && u.push(p), u.setRatio = B, F.test(e) && (u.end = null), u
            },
            U = function(t, e, i, n, r, o, s, a, l) {
                "function" == typeof n && (n = n(l || 0, t));
                var c = typeof t[e],
                    h = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                    u = "get" !== i ? i : h ? s ? t[h](s) : t[h]() : t[e],
                    d = "string" == typeof n && "=" === n.charAt(1),
                    p = {
                        t: t,
                        p: e,
                        s: u,
                        f: "function" === c,
                        pg: 0,
                        n: r || e,
                        m: o ? "function" == typeof o ? o : Math.round : 0,
                        pr: 0,
                        c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                    };
                return ("number" != typeof u || "number" != typeof n && !d) && (s || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = s, p = {
                    t: H(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, a || k.defaultStringFilter, p),
                    p: "setRatio",
                    s: 0,
                    c: 1,
                    f: 2,
                    pg: 0,
                    n: r || e,
                    pr: 0,
                    m: 0
                }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c ? ((p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p) : void 0
            },
            G = k._internals = {
                isArray: g,
                isSelector: D,
                lazyTweens: I,
                blobDif: H
            },
            j = k._plugins = {},
            V = G.tweenLookup = {},
            W = 0,
            q = G.reservedProps = {
                ease: 1,
                delay: 1,
                overwrite: 1,
                onComplete: 1,
                onCompleteParams: 1,
                onCompleteScope: 1,
                useFrames: 1,
                runBackwards: 1,
                startAt: 1,
                onUpdate: 1,
                onUpdateParams: 1,
                onUpdateScope: 1,
                onStart: 1,
                onStartParams: 1,
                onStartScope: 1,
                onReverseComplete: 1,
                onReverseCompleteParams: 1,
                onReverseCompleteScope: 1,
                onRepeat: 1,
                onRepeatParams: 1,
                onRepeatScope: 1,
                easeParams: 1,
                yoyo: 1,
                immediateRender: 1,
                repeat: 1,
                repeatDelay: 1,
                data: 1,
                paused: 1,
                reversed: 1,
                autoCSS: 1,
                lazy: 1,
                onOverwrite: 1,
                callbackScope: 1,
                stringFilter: 1,
                id: 1,
                yoyoEase: 1
            },
            X = {
                none: 0,
                all: 1,
                auto: 2,
                concurrent: 3,
                allOnStart: 4,
                preexisting: 5,
                true: 1,
                false: 0
            },
            $ = R._rootFramesTimeline = new O,
            Y = R._rootTimeline = new O,
            Z = 30,
            J = G.lazyRender = function() {
                var t, e = I.length;
                for (N = {}; --e > -1;)(t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                I.length = 0
            };
        Y._startTime = c.time, $._startTime = c.frame, Y._active = $._active = !0, setTimeout(J, 1), R._updateRoot = k.render = function() {
            var t, e, i;
            if (I.length && J(), Y.render((c.time - Y._startTime) * Y._timeScale, !1, !1), $.render((c.frame - $._startTime) * $._timeScale, !1, !1), I.length && J(), c.frame >= Z) {
                for (i in Z = c.frame + (parseInt(k.autoSleep, 10) || 120), V) {
                    for (t = (e = V[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                    0 === e.length && delete V[i]
                }
                if ((!(i = Y._first) || i._paused) && k.autoSleep && !$._first && 1 === c._listeners.tick.length) {
                    for (; i && i._paused;) i = i._next;
                    i || c.sleep()
                }
            }
        }, c.addEventListener("tick", R._updateRoot);
        var Q = function(t, e, i) {
                var n, r, o = t._gsTweenID;
                if (V[o || (t._gsTweenID = o = "t" + W++)] || (V[o] = {
                        target: t,
                        tweens: []
                    }), e && ((n = V[o].tweens)[r = n.length] = e, i))
                    for (; --r > -1;) n[r] === e && n.splice(r, 1);
                return V[o].tweens
            },
            K = function(t, e, i, n) {
                var r, o, s = t.vars.onOverwrite;
                return s && (r = s(t, e, i, n)), (s = k.onOverwrite) && (o = s(t, e, i, n)), !1 !== r && !1 !== o
            },
            tt = function(t, e, i, n, r) {
                var o, s, a, l;
                if (1 === n || n >= 4) {
                    for (l = r.length, o = 0; l > o; o++)
                        if ((a = r[o]) !== e) a._gc || a._kill(null, t, e) && (s = !0);
                        else if (5 === n) break;
                    return s
                }
                var c, h = e._startTime + p,
                    u = [],
                    d = 0,
                    f = 0 === e._duration;
                for (o = r.length; --o > -1;)(a = r[o]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (c = c || et(e, 0, f), 0 === et(a, c, f) && (u[d++] = a)) : a._startTime <= h && a._startTime + a.totalDuration() / a._timeScale > h && ((f || !a._initted) && h - a._startTime <= 2e-10 || (u[d++] = a)));
                for (o = d; --o > -1;)
                    if (l = (a = u[o])._firstPT, 2 === n && a._kill(i, t, e) && (s = !0), 2 !== n || !a._firstPT && a._initted && l) {
                        if (2 !== n && !K(a, e)) continue;
                        a._enabled(!1, !1) && (s = !0)
                    } return s
            },
            et = function(t, e, i) {
                for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                    if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                    n = n._timeline
                }
                return (o /= r) > e ? o - e : i && o === e || !t._initted && 2 * p > o - e ? p : (o += t.totalDuration() / t._timeScale / r) > e + p ? 0 : o - e - p
            };
        l._init = function() {
            var t, e, i, n, r, o, s = this.vars,
                a = this._overwrittenProps,
                l = this._duration,
                c = !!s.immediateRender,
                h = s.ease;
            if (s.startAt) {
                for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, s.startAt) r[n] = s.startAt[n];
                if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== s.lazy, r.startAt = r.delay = null, r.onUpdate = s.onUpdate, r.onUpdateParams = s.onUpdateParams, r.onUpdateScope = s.onUpdateScope || s.callbackScope || this, this._startAt = k.to(this.target || {}, 0, r), c)
                    if (this._time > 0) this._startAt = null;
                    else if (0 !== l) return
            } else if (s.runBackwards && 0 !== l)
                if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                else {
                    for (n in 0 !== this._time && (c = !1), i = {}, s) q[n] && "autoCSS" !== n || (i[n] = s[n]);
                    if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && !1 !== s.lazy, i.immediateRender = c, this._startAt = k.to(this.target, 0, i), c) {
                        if (0 === this._time) return
                    } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                } if (this._ease = h = h ? h instanceof b ? h : "function" == typeof h ? new b(h, s.easeParams) : T[h] || k.defaultEase : k.defaultEase, s.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                for (o = this._targets.length, t = 0; o > t; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0);
            else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0);
            if (e && k._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
                for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
            this._onUpdate = s.onUpdate, this._initted = !0
        }, l._initProps = function(e, i, n, r, o) {
            var s, a, l, c, h, u;
            if (null == e) return !1;
            for (s in N[e._gsTweenID] && J(), this.vars.css || e.style && e !== t && e.nodeType && j.css && !1 !== this.vars.autoCSS && function(t, e) {
                    var i, n = {};
                    for (i in t) q[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!j[i] || j[i] && j[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                    t.css = n
                }(this.vars, e), this.vars)
                if (u = this.vars[s], q[s]) u && (u instanceof Array || u.push && g(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[s] = u = this._swapSelfInParams(u, this));
                else if (j[s] && (c = new j[s])._onInitTween(e, this.vars[s], this, o)) {
                for (this._firstPT = h = {
                        _next: this._firstPT,
                        t: c,
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: 1,
                        n: s,
                        pg: 1,
                        pr: c._priority,
                        m: 0
                    }, a = c._overwriteProps.length; --a > -1;) i[c._overwriteProps[a]] = this._firstPT;
                (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
            } else i[s] = U.call(this, e, s, "get", u, s, 0, null, this.vars.stringFilter, o);
            return r && this._kill(r, e) ? this._initProps(e, i, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && tt(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (N[e._gsTweenID] = !0), l)
        }, l.render = function(t, e, i) {
            var n, r, o, s, a = this._time,
                l = this._duration,
                c = this._rawPrevTime;
            if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 > c || 0 >= t && t >= -1e-7 || c === p && "isPause" !== this.data) && c !== t && (i = !0, c > p && (r = "onReverseComplete")), this._rawPrevTime = s = !e || t || c === t ? t : p);
            else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), 0 > t && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (c !== p || "isPause" !== this.data) && (i = !0), this._rawPrevTime = s = !e || t || c === t ? t : p)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
            else if (this._totalTime = this._time = t, this._easeType) {
                var h = t / l,
                    u = this._easeType,
                    d = this._easePower;
                (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : .5 > t / l ? h / 2 : 1 - h / 2
            } else this.ratio = this._ease.getRatio(t / l);
            if (this._time !== a || i) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = c, I.push(this), void(this._lazy = [t, e]);
                    this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                }
                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === l) && (e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                this._onUpdate && (0 > t && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== a || n || i) && this._callback("onUpdate")), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === p && s !== p && (this._rawPrevTime = 0))
            }
        }, l._kill = function(t, e, i) {
            if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
            e = "string" != typeof e ? e || this._targets || this.target : k.selector(e) || e;
            var n, r, o, s, a, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                p = this._firstPT;
            if ((g(e) || D(e)) && "number" != typeof e[0])
                for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
            else {
                if (this._targets) {
                    for (n = this._targets.length; --n > -1;)
                        if (e === this._targets[n]) {
                            a = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                            break
                        }
                } else {
                    if (e !== this.target) return !1;
                    a = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                }
                if (a) {
                    if (c = t || a, h = t !== r && "all" !== r && t !== a && ("object" != typeof t || !t._tempKill), i && (k.onOverwrite || this.vars.onOverwrite)) {
                        for (o in c) a[o] && (u || (u = []), u.push(o));
                        if ((u || !t) && !K(this, i, e, u)) return !1
                    }
                    for (o in c)(s = a[o]) && (d && (s.f ? s.t[s.p](s.s) : s.t[s.p] = s.s, l = !0), s.pg && s.t._kill(c) && (l = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete a[o]), h && (r[o] = 1);
                    !this._firstPT && this._initted && p && this._enabled(!1, !1)
                }
            }
            return l
        }, l.invalidate = function() {
            return this._notifyPluginsOfEnabled && k._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], R.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -p, this.render(Math.min(0, -this._delay))), this
        }, l._enabled = function(t, e) {
            if (h || c.wake(), t && this._gc) {
                var i, n = this._targets;
                if (n)
                    for (i = n.length; --i > -1;) this._siblings[i] = Q(n[i], this, !0);
                else this._siblings = Q(this.target, this, !0)
            }
            return R.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && k._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
        }, k.to = function(t, e, i) {
            return new k(t, e, i)
        }, k.from = function(t, e, i) {
            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new k(t, e, i)
        }, k.fromTo = function(t, e, i, n) {
            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new k(t, e, n)
        }, k.delayedCall = function(t, e, i, n, r) {
            return new k(e, 0, {
                delay: t,
                onComplete: e,
                onCompleteParams: i,
                callbackScope: n,
                onReverseComplete: e,
                onReverseCompleteParams: i,
                immediateRender: !1,
                lazy: !1,
                useFrames: r,
                overwrite: 0
            })
        }, k.set = function(t, e) {
            return new k(t, 0, e)
        }, k.getTweensOf = function(t, e) {
            if (null == t) return [];
            var i, n, r, o;
            if (t = "string" != typeof t ? t : k.selector(t) || t, (g(t) || D(t)) && "number" != typeof t[0]) {
                for (i = t.length, n = []; --i > -1;) n = n.concat(k.getTweensOf(t[i], e));
                for (i = n.length; --i > -1;)
                    for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
            } else if (t._gsTweenID)
                for (i = (n = Q(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
            return n || []
        }, k.killTweensOf = k.killDelayedCallsTo = function(t, e, i) {
            "object" == typeof e && (i = e, e = !1);
            for (var n = k.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
        };
        var it = x("plugins.TweenPlugin", function(t, e) {
            this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = it.prototype
        }, !0);
        if (l = it.prototype, it.version = "1.19.0", it.API = 2, l._firstPT = null, l._addTween = U, l.setRatio = B, l._kill = function(t) {
                var e, i = this._overwriteProps,
                    n = this._firstPT;
                if (null != t[this._propName]) this._overwriteProps = [];
                else
                    for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                return !1
            }, l._mod = l._roundProps = function(t) {
                for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
            }, k._onPluginEvent = function(t, e) {
                var i, n, r, o, s, a = e._firstPT;
                if ("_onInitAllProps" === t) {
                    for (; a;) {
                        for (s = a._next, n = r; n && n.pr > a.pr;) n = n._next;
                        (a._prev = n ? n._prev : o) ? a._prev._next = a: r = a, (a._next = n) ? n._prev = a : o = a, a = s
                    }
                    a = e._firstPT = r
                }
                for (; a;) a.pg && "function" == typeof a.t[t] && a.t[t]() && (i = !0), a = a._next;
                return i
            }, it.activate = function(t) {
                for (var e = t.length; --e > -1;) t[e].API === it.API && (j[(new t[e])._propName] = t[e]);
                return !0
            }, _.plugin = function(t) {
                if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                var e, i = t.propName,
                    n = t.priority || 0,
                    r = t.overwriteProps,
                    o = {
                        init: "_onInitTween",
                        set: "setRatio",
                        kill: "_kill",
                        round: "_mod",
                        mod: "_mod",
                        initAll: "_onInitAllProps"
                    },
                    s = x("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                        it.call(this, i, n), this._overwriteProps = r || []
                    }, !0 === t.global),
                    a = s.prototype = new it(i);
                for (e in a.constructor = s, s.API = t.API, o) "function" == typeof t[e] && (a[o[e]] = t[e]);
                return s.version = t.version, it.activate([s]), s
            }, s = t._gsQueue) {
            for (a = 0; a < s.length; a++) s[a]();
            for (l in v) v[l].func || t.console.log("GSAP encountered missing dependency: " + l)
        }
        h = !1
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax"),
    function(t, e) {
        "use strict";
        var i = {},
            n = t.document,
            r = t.GreenSockGlobals = t.GreenSockGlobals || t,
            o = r[e];
        if (o) return "undefined" != typeof module && module.exports && (module.exports = o), o;
        var s, a, l, c, h, u = function(t) {
                var e, i = t.split("."),
                    n = r;
                for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                return n
            },
            d = u("com.greensock"),
            p = 1e-10,
            f = function(t) {
                var e, i = [],
                    n = t.length;
                for (e = 0; e !== n; i.push(t[e++]));
                return i
            },
            m = function() {},
            g = function() {
                var t = Object.prototype.toString,
                    e = t.call([]);
                return function(i) {
                    return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                }
            }(),
            v = {},
            y = function(n, o, s, a) {
                this.sc = v[n] ? v[n].sc : [], v[n] = this, this.gsClass = null, this.func = s;
                var l = [];
                this.check = function(c) {
                    for (var h, d, p, f, m = o.length, g = m; --m > -1;)(h = v[o[m]] || new y(o[m], [])).gsClass ? (l[m] = h.gsClass, g--) : c && h.sc.push(this);
                    if (0 === g && s) {
                        if (p = (d = ("com.greensock." + n).split(".")).pop(), f = u(d.join("."))[p] = this.gsClass = s.apply(s, l), a)
                            if (r[p] = i[p] = f, "undefined" != typeof module && module.exports)
                                if (n === e)
                                    for (m in module.exports = i[e] = f, i) f[m] = i[m];
                                else i[e] && (i[e][p] = f);
                        else "function" == typeof define && define.amd && define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + n.split(".").pop(), [], function() {
                            return f
                        });
                        for (m = 0; m < this.sc.length; m++) this.sc[m].check()
                    }
                }, this.check(!0)
            },
            _ = t._gsDefine = function(t, e, i, n) {
                return new y(t, e, i, n)
            },
            x = d._class = function(t, e, i) {
                return e = e || function() {}, _(t, [], function() {
                    return e
                }, i), e
            };
        _.globals = r;
        var w = [0, 0, 1, 1],
            b = x("easing.Ease", function(t, e, i, n) {
                this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? w.concat(e) : w
            }, !0),
            T = b.map = {},
            S = b.register = function(t, e, i, n) {
                for (var r, o, s, a, l = e.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                    for (o = l[c], r = n ? x("easing." + o, null, !0) : d.easing[o] || {}, s = h.length; --s > -1;) a = h[s], T[o + "." + a] = T[a + o] = r[a] = t.getRatio ? t : t[a] || new t
            };
        for ((l = b.prototype)._calcEnd = !1, l.getRatio = function(t) {
                if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                var e = this._type,
                    i = this._power,
                    n = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
                return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : .5 > t ? n / 2 : 1 - n / 2
            }, a = (s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --a > -1;) l = s[a] + ",Power" + a, S(new b(null, null, 1, a), l, "easeOut", !0), S(new b(null, null, 2, a), l, "easeIn" + (0 === a ? ",easeNone" : "")), S(new b(null, null, 3, a), l, "easeInOut");
        T.linear = d.easing.Linear.easeIn, T.swing = d.easing.Quad.easeInOut;
        var M = x("events.EventDispatcher", function(t) {
            this._listeners = {}, this._eventTarget = t || this
        });
        (l = M.prototype).addEventListener = function(t, e, i, n, r) {
            r = r || 0;
            var o, s, a = this._listeners[t],
                l = 0;
            for (this !== c || h || c.wake(), null == a && (this._listeners[t] = a = []), s = a.length; --s > -1;)(o = a[s]).c === e && o.s === i ? a.splice(s, 1) : 0 === l && o.pr < r && (l = s + 1);
            a.splice(l, 0, {
                c: e,
                s: i,
                up: n,
                pr: r
            })
        }, l.removeEventListener = function(t, e) {
            var i, n = this._listeners[t];
            if (n)
                for (i = n.length; --i > -1;)
                    if (n[i].c === e) return void n.splice(i, 1)
        }, l.dispatchEvent = function(t) {
            var e, i, n, r = this._listeners[t];
            if (r)
                for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                    type: t,
                    target: i
                }) : n.c.call(n.s || i))
        };
        var E = t.requestAnimationFrame,
            A = t.cancelAnimationFrame,
            P = Date.now || function() {
                return (new Date).getTime()
            },
            C = P();
        for (a = (s = ["ms", "moz", "webkit", "o"]).length; --a > -1 && !E;) E = t[s[a] + "RequestAnimationFrame"], A = t[s[a] + "CancelAnimationFrame"] || t[s[a] + "CancelRequestAnimationFrame"];
        x("Ticker", function(t, e) {
            var i, r, o, s, a, l = this,
                u = P(),
                d = !(!1 === e || !E) && "auto",
                f = 500,
                g = 33,
                v = function(t) {
                    var e, n, c = P() - C;
                    c > f && (u += c - g), C += c, l.time = (C - u) / 1e3, e = l.time - a, (!i || e > 0 || !0 === t) && (l.frame++, a += e + (e >= s ? .004 : s - e), n = !0), !0 !== t && (o = r(v)), n && l.dispatchEvent("tick")
                };
            M.call(l), l.time = l.frame = 0, l.tick = function() {
                v(!0)
            }, l.lagSmoothing = function(t, e) {
                return arguments.length ? (f = t || 1 / p, void(g = Math.min(e, f, 0))) : 1 / p > f
            }, l.sleep = function() {
                null != o && (d && A ? A(o) : clearTimeout(o), r = m, o = null, l === c && (h = !1))
            }, l.wake = function(t) {
                null !== o ? l.sleep() : t ? u += -C + (C = P()) : l.frame > 10 && (C = P() - f + 5), r = 0 === i ? m : d && E ? E : function(t) {
                    return setTimeout(t, 1e3 * (a - l.time) + 1 | 0)
                }, l === c && (h = !0), v(2)
            }, l.fps = function(t) {
                return arguments.length ? (s = 1 / ((i = t) || 60), a = this.time + s, void l.wake()) : i
            }, l.useRAF = function(t) {
                return arguments.length ? (l.sleep(), d = t, void l.fps(i)) : d
            }, l.fps(t), setTimeout(function() {
                "auto" === d && l.frame < 5 && "hidden" !== (n || {}).visibilityState && l.useRAF(!1)
            }, 1500)
        }), (l = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker;
        var R = x("core.Animation", function(t, e) {
            if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, Y) {
                h || c.wake();
                var i = this.vars.useFrames ? $ : Y;
                i.add(this, i._time), this.vars.paused && this.paused(!0)
            }
        });
        c = R.ticker = new d.Ticker, (l = R.prototype)._dirty = l._gc = l._initted = l._paused = !1, l._totalTime = l._time = 0, l._rawPrevTime = -1, l._next = l._last = l._onUpdate = l._timeline = l.timeline = null, l._paused = !1;
        var L = function() {
            h && P() - C > 2e3 && ("hidden" !== (n || {}).visibilityState || !c.lagSmoothing()) && c.wake();
            var t = setTimeout(L, 2e3);
            t.unref && t.unref()
        };
        L(), l.play = function(t, e) {
            return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
        }, l.pause = function(t, e) {
            return null != t && this.seek(t, e), this.paused(!0)
        }, l.resume = function(t, e) {
            return null != t && this.seek(t, e), this.paused(!1)
        }, l.seek = function(t, e) {
            return this.totalTime(Number(t), !1 !== e)
        }, l.restart = function(t, e) {
            return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
        }, l.reverse = function(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
        }, l.render = function(t, e, i) {}, l.invalidate = function() {
            return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
        }, l.isActive = function() {
            var t, e = this._timeline,
                i = this._startTime;
            return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
        }, l._enabled = function(t, e) {
            return h || c.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
        }, l._kill = function(t, e) {
            return this._enabled(!1, !1)
        }, l.kill = function(t, e) {
            return this._kill(t, e), this
        }, l._uncache = function(t) {
            for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
            return this
        }, l._swapSelfInParams = function(t) {
            for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
            return i
        }, l._callback = function(t) {
            var e = this.vars,
                i = e[t],
                n = e[t + "Params"],
                r = e[t + "Scope"] || e.callbackScope || this;
            switch (n ? n.length : 0) {
                case 0:
                    i.call(r);
                    break;
                case 1:
                    i.call(r, n[0]);
                    break;
                case 2:
                    i.call(r, n[0], n[1]);
                    break;
                default:
                    i.apply(r, n)
            }
        }, l.eventCallback = function(t, e, i, n) {
            if ("on" === (t || "").substr(0, 2)) {
                var r = this.vars;
                if (1 === arguments.length) return r[t];
                null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = g(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
            }
            return this
        }, l.delay = function(t) {
            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
        }, l.duration = function(t) {
            return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
        }, l.totalDuration = function(t) {
            return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
        }, l.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
        }, l.totalTime = function(t, e, i) {
            if (h || c.wake(), !arguments.length) return this._totalTime;
            if (this._timeline) {
                if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                    this._dirty && this.totalDuration();
                    var n = this._totalDuration,
                        r = this._timeline;
                    if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                        for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                }
                this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (I.length && J(), this.render(t, e, !1), I.length && J())
            }
            return this
        }, l.progress = l.totalProgress = function(t, e) {
            var i = this.duration();
            return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
        }, l.startTime = function(t) {
            return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
        }, l.endTime = function(t) {
            return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
        }, l.timeScale = function(t) {
            if (!arguments.length) return this._timeScale;
            var e, i;
            for (t = t || p, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
            return this
        }, l.reversed = function(t) {
            return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
        }, l.paused = function(t) {
            if (!arguments.length) return this._paused;
            var e, i, n = this._timeline;
            return t != this._paused && n && (h || t || c.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
        };
        var O = x("core.SimpleTimeline", function(t) {
            R.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
        });
        (l = O.prototype = new R).constructor = O, l.kill()._gc = !1, l._first = l._last = l._recent = null, l._sortChildren = !1, l.add = l.insert = function(t, e, i, n) {
            var r, o;
            if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                for (o = t._startTime; r && r._startTime > o;) r = r._prev;
            return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
        }, l._remove = function(t, e) {
            return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
        }, l.render = function(t, e, i) {
            var n, r = this._first;
            for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
        }, l.rawTime = function() {
            return h || c.wake(), this._totalTime
        };
        var k = x("TweenLite", function(e, i, n) {
                if (R.call(this, i, n), this.render = k.prototype.render, null == e) throw "Cannot tween a null target.";
                this.target = e = "string" != typeof e ? e : k.selector(e) || e;
                var r, o, s, a = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                    l = this.vars.overwrite;
                if (this._overwrite = l = null == l ? X[k.defaultOverwrite] : "number" == typeof l ? l >> 0 : X[l], (a || e instanceof Array || e.push && g(e)) && "number" != typeof e[0])
                    for (this._targets = s = f(e), this._propLookup = [], this._siblings = [], r = 0; r < s.length; r++)(o = s[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (s.splice(r--, 1), this._targets = s = s.concat(f(o))) : (this._siblings[r] = Q(o, this, !1), 1 === l && this._siblings[r].length > 1 && tt(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = s[r--] = k.selector(o)) && s.splice(r + 1, 1) : s.splice(r--, 1);
                else this._propLookup = {}, this._siblings = Q(e, this, !1), 1 === l && this._siblings.length > 1 && tt(e, this, null, 1, this._siblings);
                (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -p, this.render(Math.min(0, -this._delay)))
            }, !0),
            D = function(e) {
                return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
            };
        (l = k.prototype = new R).constructor = k, l.kill()._gc = !1, l.ratio = 0, l._firstPT = l._targets = l._overwrittenProps = l._startAt = null, l._notifyPluginsOfEnabled = l._lazy = !1, k.version = "2.0.2", k.defaultEase = l._ease = new b(null, null, 1, 1), k.defaultOverwrite = "auto", k.ticker = c, k.autoSleep = 120, k.lagSmoothing = function(t, e) {
            c.lagSmoothing(t, e)
        }, k.selector = t.$ || t.jQuery || function(e) {
            var i = t.$ || t.jQuery;
            return i ? (k.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
        };
        var I = [],
            N = {},
            z = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            F = /[\+-]=-?[\.\d]/,
            B = function(t) {
                for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : 1e-6 > e && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
            },
            H = function(t, e, i, n) {
                var r, o, s, a, l, c, h, u = [],
                    d = 0,
                    p = "",
                    f = 0;
                for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(z) || [], o = e.match(z) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = o.length, a = 0; l > a; a++) h = o[a], p += (c = e.substr(d, e.indexOf(h, d) - d)) || !a ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[a] || r.length <= a ? p += h : (p && (u.push(p), p = ""), s = parseFloat(r[a]), u.push(s), u._firstPT = {
                    _next: u._firstPT,
                    t: u,
                    p: u.length - 1,
                    s: s,
                    c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - s) || 0,
                    f: 0,
                    m: f && 4 > f ? Math.round : 0
                }), d += h.length;
                return (p += e.substr(d)) && u.push(p), u.setRatio = B, F.test(e) && (u.end = null), u
            },
            U = function(t, e, i, n, r, o, s, a, l) {
                "function" == typeof n && (n = n(l || 0, t));
                var c = typeof t[e],
                    h = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                    u = "get" !== i ? i : h ? s ? t[h](s) : t[h]() : t[e],
                    d = "string" == typeof n && "=" === n.charAt(1),
                    p = {
                        t: t,
                        p: e,
                        s: u,
                        f: "function" === c,
                        pg: 0,
                        n: r || e,
                        m: o ? "function" == typeof o ? o : Math.round : 0,
                        pr: 0,
                        c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                    };
                return ("number" != typeof u || "number" != typeof n && !d) && (s || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = s, p = {
                    t: H(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, a || k.defaultStringFilter, p),
                    p: "setRatio",
                    s: 0,
                    c: 1,
                    f: 2,
                    pg: 0,
                    n: r || e,
                    pr: 0,
                    m: 0
                }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c ? ((p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p) : void 0
            },
            G = k._internals = {
                isArray: g,
                isSelector: D,
                lazyTweens: I,
                blobDif: H
            },
            j = k._plugins = {},
            V = G.tweenLookup = {},
            W = 0,
            q = G.reservedProps = {
                ease: 1,
                delay: 1,
                overwrite: 1,
                onComplete: 1,
                onCompleteParams: 1,
                onCompleteScope: 1,
                useFrames: 1,
                runBackwards: 1,
                startAt: 1,
                onUpdate: 1,
                onUpdateParams: 1,
                onUpdateScope: 1,
                onStart: 1,
                onStartParams: 1,
                onStartScope: 1,
                onReverseComplete: 1,
                onReverseCompleteParams: 1,
                onReverseCompleteScope: 1,
                onRepeat: 1,
                onRepeatParams: 1,
                onRepeatScope: 1,
                easeParams: 1,
                yoyo: 1,
                immediateRender: 1,
                repeat: 1,
                repeatDelay: 1,
                data: 1,
                paused: 1,
                reversed: 1,
                autoCSS: 1,
                lazy: 1,
                onOverwrite: 1,
                callbackScope: 1,
                stringFilter: 1,
                id: 1,
                yoyoEase: 1
            },
            X = {
                none: 0,
                all: 1,
                auto: 2,
                concurrent: 3,
                allOnStart: 4,
                preexisting: 5,
                true: 1,
                false: 0
            },
            $ = R._rootFramesTimeline = new O,
            Y = R._rootTimeline = new O,
            Z = 30,
            J = G.lazyRender = function() {
                var t, e = I.length;
                for (N = {}; --e > -1;)(t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                I.length = 0
            };
        Y._startTime = c.time, $._startTime = c.frame, Y._active = $._active = !0, setTimeout(J, 1), R._updateRoot = k.render = function() {
            var t, e, i;
            if (I.length && J(), Y.render((c.time - Y._startTime) * Y._timeScale, !1, !1), $.render((c.frame - $._startTime) * $._timeScale, !1, !1), I.length && J(), c.frame >= Z) {
                for (i in Z = c.frame + (parseInt(k.autoSleep, 10) || 120), V) {
                    for (t = (e = V[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                    0 === e.length && delete V[i]
                }
                if ((!(i = Y._first) || i._paused) && k.autoSleep && !$._first && 1 === c._listeners.tick.length) {
                    for (; i && i._paused;) i = i._next;
                    i || c.sleep()
                }
            }
        }, c.addEventListener("tick", R._updateRoot);
        var Q = function(t, e, i) {
                var n, r, o = t._gsTweenID;
                if (V[o || (t._gsTweenID = o = "t" + W++)] || (V[o] = {
                        target: t,
                        tweens: []
                    }), e && ((n = V[o].tweens)[r = n.length] = e, i))
                    for (; --r > -1;) n[r] === e && n.splice(r, 1);
                return V[o].tweens
            },
            K = function(t, e, i, n) {
                var r, o, s = t.vars.onOverwrite;
                return s && (r = s(t, e, i, n)), (s = k.onOverwrite) && (o = s(t, e, i, n)), !1 !== r && !1 !== o
            },
            tt = function(t, e, i, n, r) {
                var o, s, a, l;
                if (1 === n || n >= 4) {
                    for (l = r.length, o = 0; l > o; o++)
                        if ((a = r[o]) !== e) a._gc || a._kill(null, t, e) && (s = !0);
                        else if (5 === n) break;
                    return s
                }
                var c, h = e._startTime + p,
                    u = [],
                    d = 0,
                    f = 0 === e._duration;
                for (o = r.length; --o > -1;)(a = r[o]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (c = c || et(e, 0, f), 0 === et(a, c, f) && (u[d++] = a)) : a._startTime <= h && a._startTime + a.totalDuration() / a._timeScale > h && ((f || !a._initted) && h - a._startTime <= 2e-10 || (u[d++] = a)));
                for (o = d; --o > -1;)
                    if (l = (a = u[o])._firstPT, 2 === n && a._kill(i, t, e) && (s = !0), 2 !== n || !a._firstPT && a._initted && l) {
                        if (2 !== n && !K(a, e)) continue;
                        a._enabled(!1, !1) && (s = !0)
                    } return s
            },
            et = function(t, e, i) {
                for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                    if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                    n = n._timeline
                }
                return (o /= r) > e ? o - e : i && o === e || !t._initted && 2 * p > o - e ? p : (o += t.totalDuration() / t._timeScale / r) > e + p ? 0 : o - e - p
            };
        l._init = function() {
            var t, e, i, n, r, o, s = this.vars,
                a = this._overwrittenProps,
                l = this._duration,
                c = !!s.immediateRender,
                h = s.ease;
            if (s.startAt) {
                for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, s.startAt) r[n] = s.startAt[n];
                if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== s.lazy, r.startAt = r.delay = null, r.onUpdate = s.onUpdate, r.onUpdateParams = s.onUpdateParams, r.onUpdateScope = s.onUpdateScope || s.callbackScope || this, this._startAt = k.to(this.target || {}, 0, r), c)
                    if (this._time > 0) this._startAt = null;
                    else if (0 !== l) return
            } else if (s.runBackwards && 0 !== l)
                if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                else {
                    for (n in 0 !== this._time && (c = !1), i = {}, s) q[n] && "autoCSS" !== n || (i[n] = s[n]);
                    if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && !1 !== s.lazy, i.immediateRender = c, this._startAt = k.to(this.target, 0, i), c) {
                        if (0 === this._time) return
                    } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                } if (this._ease = h = h ? h instanceof b ? h : "function" == typeof h ? new b(h, s.easeParams) : T[h] || k.defaultEase : k.defaultEase, s.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                for (o = this._targets.length, t = 0; o > t; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0);
            else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0);
            if (e && k._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards)
                for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
            this._onUpdate = s.onUpdate, this._initted = !0
        }, l._initProps = function(e, i, n, r, o) {
            var s, a, l, c, h, u;
            if (null == e) return !1;
            for (s in N[e._gsTweenID] && J(), this.vars.css || e.style && e !== t && e.nodeType && j.css && !1 !== this.vars.autoCSS && function(t, e) {
                    var i, n = {};
                    for (i in t) q[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!j[i] || j[i] && j[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                    t.css = n
                }(this.vars, e), this.vars)
                if (u = this.vars[s], q[s]) u && (u instanceof Array || u.push && g(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[s] = u = this._swapSelfInParams(u, this));
                else if (j[s] && (c = new j[s])._onInitTween(e, this.vars[s], this, o)) {
                for (this._firstPT = h = {
                        _next: this._firstPT,
                        t: c,
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: 1,
                        n: s,
                        pg: 1,
                        pr: c._priority,
                        m: 0
                    }, a = c._overwriteProps.length; --a > -1;) i[c._overwriteProps[a]] = this._firstPT;
                (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
            } else i[s] = U.call(this, e, s, "get", u, s, 0, null, this.vars.stringFilter, o);
            return r && this._kill(r, e) ? this._initProps(e, i, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && tt(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (N[e._gsTweenID] = !0), l)
        }, l.render = function(t, e, i) {
            var n, r, o, s, a = this._time,
                l = this._duration,
                c = this._rawPrevTime;
            if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 > c || 0 >= t && t >= -1e-7 || c === p && "isPause" !== this.data) && c !== t && (i = !0, c > p && (r = "onReverseComplete")), this._rawPrevTime = s = !e || t || c === t ? t : p);
            else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), 0 > t && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (c !== p || "isPause" !== this.data) && (i = !0), this._rawPrevTime = s = !e || t || c === t ? t : p)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
            else if (this._totalTime = this._time = t, this._easeType) {
                var h = t / l,
                    u = this._easeType,
                    d = this._easePower;
                (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : .5 > t / l ? h / 2 : 1 - h / 2
            } else this.ratio = this._ease.getRatio(t / l);
            if (this._time !== a || i) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = c, I.push(this), void(this._lazy = [t, e]);
                    this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                }
                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === l) && (e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                this._onUpdate && (0 > t && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== a || n || i) && this._callback("onUpdate")), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === p && s !== p && (this._rawPrevTime = 0))
            }
        }, l._kill = function(t, e, i) {
            if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
            e = "string" != typeof e ? e || this._targets || this.target : k.selector(e) || e;
            var n, r, o, s, a, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                p = this._firstPT;
            if ((g(e) || D(e)) && "number" != typeof e[0])
                for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
            else {
                if (this._targets) {
                    for (n = this._targets.length; --n > -1;)
                        if (e === this._targets[n]) {
                            a = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                            break
                        }
                } else {
                    if (e !== this.target) return !1;
                    a = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                }
                if (a) {
                    if (c = t || a, h = t !== r && "all" !== r && t !== a && ("object" != typeof t || !t._tempKill), i && (k.onOverwrite || this.vars.onOverwrite)) {
                        for (o in c) a[o] && (u || (u = []), u.push(o));
                        if ((u || !t) && !K(this, i, e, u)) return !1
                    }
                    for (o in c)(s = a[o]) && (d && (s.f ? s.t[s.p](s.s) : s.t[s.p] = s.s, l = !0), s.pg && s.t._kill(c) && (l = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete a[o]), h && (r[o] = 1);
                    !this._firstPT && this._initted && p && this._enabled(!1, !1)
                }
            }
            return l
        }, l.invalidate = function() {
            return this._notifyPluginsOfEnabled && k._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], R.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -p, this.render(Math.min(0, -this._delay))), this
        }, l._enabled = function(t, e) {
            if (h || c.wake(), t && this._gc) {
                var i, n = this._targets;
                if (n)
                    for (i = n.length; --i > -1;) this._siblings[i] = Q(n[i], this, !0);
                else this._siblings = Q(this.target, this, !0)
            }
            return R.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && k._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
        }, k.to = function(t, e, i) {
            return new k(t, e, i)
        }, k.from = function(t, e, i) {
            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new k(t, e, i)
        }, k.fromTo = function(t, e, i, n) {
            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new k(t, e, n)
        }, k.delayedCall = function(t, e, i, n, r) {
            return new k(e, 0, {
                delay: t,
                onComplete: e,
                onCompleteParams: i,
                callbackScope: n,
                onReverseComplete: e,
                onReverseCompleteParams: i,
                immediateRender: !1,
                lazy: !1,
                useFrames: r,
                overwrite: 0
            })
        }, k.set = function(t, e) {
            return new k(t, 0, e)
        }, k.getTweensOf = function(t, e) {
            if (null == t) return [];
            var i, n, r, o;
            if (t = "string" != typeof t ? t : k.selector(t) || t, (g(t) || D(t)) && "number" != typeof t[0]) {
                for (i = t.length, n = []; --i > -1;) n = n.concat(k.getTweensOf(t[i], e));
                for (i = n.length; --i > -1;)
                    for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
            } else if (t._gsTweenID)
                for (i = (n = Q(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
            return n || []
        }, k.killTweensOf = k.killDelayedCallsTo = function(t, e, i) {
            "object" == typeof e && (i = e, e = !1);
            for (var n = k.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
        };
        var it = x("plugins.TweenPlugin", function(t, e) {
            this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = it.prototype
        }, !0);
        if (l = it.prototype, it.version = "1.19.0", it.API = 2, l._firstPT = null, l._addTween = U, l.setRatio = B, l._kill = function(t) {
                var e, i = this._overwriteProps,
                    n = this._firstPT;
                if (null != t[this._propName]) this._overwriteProps = [];
                else
                    for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                return !1
            }, l._mod = l._roundProps = function(t) {
                for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
            }, k._onPluginEvent = function(t, e) {
                var i, n, r, o, s, a = e._firstPT;
                if ("_onInitAllProps" === t) {
                    for (; a;) {
                        for (s = a._next, n = r; n && n.pr > a.pr;) n = n._next;
                        (a._prev = n ? n._prev : o) ? a._prev._next = a: r = a, (a._next = n) ? n._prev = a : o = a, a = s
                    }
                    a = e._firstPT = r
                }
                for (; a;) a.pg && "function" == typeof a.t[t] && a.t[t]() && (i = !0), a = a._next;
                return i
            }, it.activate = function(t) {
                for (var e = t.length; --e > -1;) t[e].API === it.API && (j[(new t[e])._propName] = t[e]);
                return !0
            }, _.plugin = function(t) {
                if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                var e, i = t.propName,
                    n = t.priority || 0,
                    r = t.overwriteProps,
                    o = {
                        init: "_onInitTween",
                        set: "setRatio",
                        kill: "_kill",
                        round: "_mod",
                        mod: "_mod",
                        initAll: "_onInitAllProps"
                    },
                    s = x("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                        it.call(this, i, n), this._overwriteProps = r || []
                    }, !0 === t.global),
                    a = s.prototype = new it(i);
                for (e in a.constructor = s, s.API = t.API, o) "function" == typeof t[e] && (a[o[e]] = t[e]);
                return s.version = t.version, it.activate([s]), s
            }, s = t._gsQueue) {
            for (a = 0; a < s.length; a++) s[a]();
            for (l in v) v[l].func || t.console.log("GSAP encountered missing dependency: " + l)
        }
        h = !1
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenLite"),
    function(t, e) {
        "function" == typeof define && define.amd ? define(e) : "object" == typeof exports ? module.exports = e() : t.ScrollMagic = e()
    }(this, function() {
        "use strict";
        var t = function() {
            n.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.")
        };
        t.version = "2.0.7", window.addEventListener("mousewheel", function() {});
        t.Controller = function(i) {
            var r, o, s = "ScrollMagic.Controller",
                a = e.defaults,
                l = this,
                c = n.extend({}, a, i),
                h = [],
                u = !1,
                d = 0,
                p = "PAUSED",
                f = !0,
                m = 0,
                g = !0,
                v = function() {
                    c.refreshInterval > 0 && (o = window.setTimeout(S, c.refreshInterval))
                },
                y = function() {
                    return c.vertical ? n.get.scrollTop(c.container) : n.get.scrollLeft(c.container)
                },
                _ = function() {
                    return c.vertical ? n.get.height(c.container) : n.get.width(c.container)
                },
                x = this._setScrollPos = function(t) {
                    c.vertical ? f ? window.scrollTo(n.get.scrollLeft(), t) : c.container.scrollTop = t : f ? window.scrollTo(t, n.get.scrollTop()) : c.container.scrollLeft = t
                },
                w = function() {
                    if (g && u) {
                        var t = n.type.Array(u) ? u : h.slice(0);
                        u = !1;
                        var e = d,
                            i = (d = l.scrollPos()) - e;
                        0 !== i && (p = i > 0 ? "FORWARD" : "REVERSE"), "REVERSE" === p && t.reverse(), t.forEach(function(e, i) {
                            M(3, "updating Scene " + (i + 1) + "/" + t.length + " (" + h.length + " total)"), e.update(!0)
                        }), 0 === t.length && c.loglevel >= 3 && M(3, "updating 0 Scenes (nothing added to controller)")
                    }
                },
                b = function() {
                    r = n.rAF(w)
                },
                T = function(t) {
                    M(3, "event fired causing an update:", t.type), "resize" == t.type && (m = _(), p = "PAUSED"), !0 !== u && (u = !0, b())
                },
                S = function() {
                    if (!f && m != _()) {
                        var t;
                        try {
                            t = new Event("resize", {
                                bubbles: !1,
                                cancelable: !1
                            })
                        } catch (e) {
                            (t = document.createEvent("Event")).initEvent("resize", !1, !1)
                        }
                        c.container.dispatchEvent(t)
                    }
                    h.forEach(function(t, e) {
                        t.refresh()
                    }), v()
                },
                M = this._log = function(t, e) {
                    c.loglevel >= t && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments))
                };
            this._options = c;
            var E = function(t) {
                if (t.length <= 1) return t;
                var e = t.slice(0);
                return e.sort(function(t, e) {
                    return t.scrollOffset() > e.scrollOffset() ? 1 : -1
                }), e
            };
            return this.addScene = function(e) {
                    if (n.type.Array(e)) e.forEach(function(t, e) {
                        l.addScene(t)
                    });
                    else if (e instanceof t.Scene) {
                        if (e.controller() !== l) e.addTo(l);
                        else if (h.indexOf(e) < 0) {
                            for (var i in h.push(e), h = E(h), e.on("shift.controller_sort", function() {
                                    h = E(h)
                                }), c.globalSceneOptions) e[i] && e[i].call(e, c.globalSceneOptions[i]);
                            M(3, "adding Scene (now " + h.length + " total)")
                        }
                    } else M(1, "ERROR: invalid argument supplied for '.addScene()'");
                    return l
                }, this.removeScene = function(t) {
                    if (n.type.Array(t)) t.forEach(function(t, e) {
                        l.removeScene(t)
                    });
                    else {
                        var e = h.indexOf(t);
                        e > -1 && (t.off("shift.controller_sort"), h.splice(e, 1), M(3, "removing Scene (now " + h.length + " left)"), t.remove())
                    }
                    return l
                }, this.updateScene = function(e, i) {
                    return n.type.Array(e) ? e.forEach(function(t, e) {
                        l.updateScene(t, i)
                    }) : i ? e.update(!0) : !0 !== u && e instanceof t.Scene && (-1 == (u = u || []).indexOf(e) && u.push(e), u = E(u), b()), l
                }, this.update = function(t) {
                    return T({
                        type: "resize"
                    }), t && w(), l
                }, this.scrollTo = function(e, i) {
                    if (n.type.Number(e)) x.call(c.container, e, i);
                    else if (e instanceof t.Scene) e.controller() === l ? l.scrollTo(e.scrollOffset(), i) : M(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", e);
                    else if (n.type.Function(e)) x = e;
                    else {
                        var r = n.get.elements(e)[0];
                        if (r) {
                            for (; r.parentNode.hasAttribute("data-scrollmagic-pin-spacer");) r = r.parentNode;
                            var o = c.vertical ? "top" : "left",
                                s = n.get.offset(c.container),
                                a = n.get.offset(r);
                            f || (s[o] -= l.scrollPos()), l.scrollTo(a[o] - s[o], i)
                        } else M(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", e)
                    }
                    return l
                }, this.scrollPos = function(t) {
                    return arguments.length ? (n.type.Function(t) ? y = t : M(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'."), l) : y.call(l)
                }, this.info = function(t) {
                    var e = {
                        size: m,
                        vertical: c.vertical,
                        scrollPos: d,
                        scrollDirection: p,
                        container: c.container,
                        isDocument: f
                    };
                    return arguments.length ? void 0 !== e[t] ? e[t] : void M(1, 'ERROR: option "' + t + '" is not available') : e
                }, this.loglevel = function(t) {
                    return arguments.length ? (c.loglevel != t && (c.loglevel = t), l) : c.loglevel
                }, this.enabled = function(t) {
                    return arguments.length ? (g != t && (g = !!t, l.updateScene(h, !0)), l) : g
                }, this.destroy = function(t) {
                    window.clearTimeout(o);
                    for (var e = h.length; e--;) h[e].destroy(t);
                    return c.container.removeEventListener("resize", T), c.container.removeEventListener("scroll", T), n.cAF(r), M(3, "destroyed " + s + " (reset: " + (t ? "true" : "false") + ")"), null
                },
                function() {
                    for (var e in c) a.hasOwnProperty(e) || (M(2, 'WARNING: Unknown option "' + e + '"'), delete c[e]);
                    if (c.container = n.get.elements(c.container)[0], !c.container) throw M(1, "ERROR creating object " + s + ": No valid scroll container supplied"), s + " init failed.";
                    (f = c.container === window || c.container === document.body || !document.body.contains(c.container)) && (c.container = window), m = _(), c.container.addEventListener("resize", T), c.container.addEventListener("scroll", T);
                    var i = parseInt(c.refreshInterval, 10);
                    c.refreshInterval = n.type.Number(i) ? i : a.refreshInterval, v(), M(3, "added new " + s + " controller (v" + t.version + ")")
                }(), l
        };
        var e = {
            defaults: {
                container: window,
                vertical: !0,
                globalSceneOptions: {},
                loglevel: 2,
                refreshInterval: 100
            }
        };
        t.Controller.addOption = function(t, i) {
            e.defaults[t] = i
        }, t.Controller.extend = function(e) {
            var i = this;
            t.Controller = function() {
                return i.apply(this, arguments), this.$super = n.extend({}, this), e.apply(this, arguments) || this
            }, n.extend(t.Controller, i), t.Controller.prototype = i.prototype, t.Controller.prototype.constructor = t.Controller
        }, t.Scene = function(e) {
            var r, o, s = "ScrollMagic.Scene",
                a = i.defaults,
                l = this,
                c = n.extend({}, a, e),
                h = "BEFORE",
                u = 0,
                d = {
                    start: 0,
                    end: 0
                },
                p = 0,
                f = !0,
                m = {};
            this.on = function(t, e) {
                return n.type.Function(e) ? (t = t.trim().split(" ")).forEach(function(t) {
                    var i = t.split("."),
                        n = i[0],
                        r = i[1];
                    "*" != n && (m[n] || (m[n] = []), m[n].push({
                        namespace: r || "",
                        callback: e
                    }))
                }) : g(1, "ERROR when calling '.on()': Supplied callback for '" + t + "' is not a valid function!"), l
            }, this.off = function(t, e) {
                return t ? ((t = t.trim().split(" ")).forEach(function(t, i) {
                    var n = t.split("."),
                        r = n[0],
                        o = n[1] || "";
                    ("*" === r ? Object.keys(m) : [r]).forEach(function(t) {
                        for (var i = m[t] || [], n = i.length; n--;) {
                            var r = i[n];
                            !r || o !== r.namespace && "*" !== o || e && e != r.callback || i.splice(n, 1)
                        }
                        i.length || delete m[t]
                    })
                }), l) : (g(1, "ERROR: Invalid event name supplied."), l)
            }, this.trigger = function(e, i) {
                if (e) {
                    var n = e.trim().split("."),
                        r = n[0],
                        o = n[1],
                        s = m[r];
                    g(3, "event fired:", r, i ? "->" : "", i || ""), s && s.forEach(function(e, n) {
                        o && o !== e.namespace || e.callback.call(l, new t.Event(r, e.namespace, l, i))
                    })
                } else g(1, "ERROR: Invalid event name supplied.");
                return l
            }, l.on("change.internal", function(t) {
                "loglevel" !== t.what && "tweenChanges" !== t.what && ("triggerElement" === t.what ? w() : "reverse" === t.what && l.update())
            }).on("shift.internal", function(t) {
                _(), l.update()
            });
            var g = this._log = function(t, e) {
                c.loglevel >= t && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments))
            };
            this.addTo = function(e) {
                return e instanceof t.Controller ? o != e && (o && o.removeScene(l), o = e, S(), x(!0), w(!0), _(), o.info("container").addEventListener("resize", b), e.addScene(l), l.trigger("add", {
                    controller: o
                }), g(3, "added " + s + " to controller"), l.update()) : g(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller"), l
            }, this.enabled = function(t) {
                return arguments.length ? (f != t && (f = !!t, l.update(!0)), l) : f
            }, this.remove = function() {
                if (o) {
                    o.info("container").removeEventListener("resize", b);
                    var t = o;
                    o = void 0, t.removeScene(l), l.trigger("remove"), g(3, "removed " + s + " from controller")
                }
                return l
            }, this.destroy = function(t) {
                return l.trigger("destroy", {
                    reset: t
                }), l.remove(), l.off("*.*"), g(3, "destroyed " + s + " (reset: " + (t ? "true" : "false") + ")"), null
            }, this.update = function(t) {
                if (o)
                    if (t)
                        if (o.enabled() && f) {
                            var e, i = o.info("scrollPos");
                            e = c.duration > 0 ? (i - d.start) / (d.end - d.start) : i >= d.start ? 1 : 0, l.trigger("update", {
                                startPos: d.start,
                                endPos: d.end,
                                scrollPos: i
                            }), l.progress(e)
                        } else v && "DURING" === h && A(!0);
                else o.updateScene(l, !1);
                return l
            }, this.refresh = function() {
                return x(), w(), l
            }, this.progress = function(t) {
                if (arguments.length) {
                    var e = !1,
                        i = h,
                        n = o ? o.info("scrollDirection") : "PAUSED",
                        r = c.reverse || t >= u;
                    if (0 === c.duration ? (e = u != t, h = 0 === (u = t < 1 && r ? 0 : 1) ? "BEFORE" : "DURING") : t < 0 && "BEFORE" !== h && r ? (u = 0, h = "BEFORE", e = !0) : t >= 0 && t < 1 && r ? (u = t, h = "DURING", e = !0) : t >= 1 && "AFTER" !== h ? (u = 1, h = "AFTER", e = !0) : "DURING" !== h || r || A(), e) {
                        var s = {
                                progress: u,
                                state: h,
                                scrollDirection: n
                            },
                            a = h != i,
                            d = function(t) {
                                l.trigger(t, s)
                            };
                        a && "DURING" !== i && (d("enter"), d("BEFORE" === i ? "start" : "end")), d("progress"), a && "DURING" !== h && (d("BEFORE" === h ? "start" : "end"), d("leave"))
                    }
                    return l
                }
                return u
            };
            var v, y, _ = function() {
                    d = {
                        start: p + c.offset
                    }, o && c.triggerElement && (d.start -= o.info("size") * c.triggerHook), d.end = d.start + c.duration
                },
                x = function(t) {
                    if (r) {
                        M("duration", r.call(l)) && !t && (l.trigger("change", {
                            what: "duration",
                            newval: c.duration
                        }), l.trigger("shift", {
                            reason: "duration"
                        }))
                    }
                },
                w = function(t) {
                    var e = 0,
                        i = c.triggerElement;
                    if (o && (i || p > 0)) {
                        if (i)
                            if (i.parentNode) {
                                for (var r = o.info(), s = n.get.offset(r.container), a = r.vertical ? "top" : "left"; i.parentNode.hasAttribute("data-scrollmagic-pin-spacer");) i = i.parentNode;
                                var h = n.get.offset(i);
                                r.isDocument || (s[a] -= o.scrollPos()), e = h[a] - s[a]
                            } else g(2, "WARNING: triggerElement was removed from DOM and will be reset to", void 0), l.triggerElement(void 0);
                        var u = e != p;
                        p = e, u && !t && l.trigger("shift", {
                            reason: "triggerElementPosition"
                        })
                    }
                },
                b = function(t) {
                    c.triggerHook > 0 && l.trigger("shift", {
                        reason: "containerResize"
                    })
                },
                T = n.extend(i.validate, {
                    duration: function(t) {
                        if (n.type.String(t) && t.match(/^(\.|\d)*\d+%$/)) {
                            var e = parseFloat(t) / 100;
                            t = function() {
                                return o ? o.info("size") * e : 0
                            }
                        }
                        if (n.type.Function(t)) {
                            r = t;
                            try {
                                t = parseFloat(r.call(l))
                            } catch (e) {
                                t = -1
                            }
                        }
                        if (t = parseFloat(t), !n.type.Number(t) || t < 0) throw r ? (r = void 0, ['Invalid return value of supplied function for option "duration":', t]) : ['Invalid value for option "duration":', t];
                        return t
                    }
                }),
                S = function(t) {
                    (t = arguments.length ? [t] : Object.keys(T)).forEach(function(t, e) {
                        var i;
                        if (T[t]) try {
                            i = T[t](c[t])
                        } catch (e) {
                            i = a[t];
                            var r = n.type.String(e) ? [e] : e;
                            n.type.Array(r) ? (r[0] = "ERROR: " + r[0], r.unshift(1), g.apply(this, r)) : g(1, "ERROR: Problem executing validation callback for option '" + t + "':", e.message)
                        } finally {
                            c[t] = i
                        }
                    })
                },
                M = function(t, e) {
                    var i = !1,
                        n = c[t];
                    return c[t] != e && (c[t] = e, S(t), i = n != c[t]), i
                },
                E = function(t) {
                    l[t] || (l[t] = function(e) {
                        return arguments.length ? ("duration" === t && (r = void 0), M(t, e) && (l.trigger("change", {
                            what: t,
                            newval: c[t]
                        }), i.shifts.indexOf(t) > -1 && l.trigger("shift", {
                            reason: t
                        })), l) : c[t]
                    })
                };
            this.controller = function() {
                return o
            }, this.state = function() {
                return h
            }, this.scrollOffset = function() {
                return d.start
            }, this.triggerPosition = function() {
                var t = c.offset;
                return o && (c.triggerElement ? t += p : t += o.info("size") * l.triggerHook()), t
            }, l.on("shift.internal", function(t) {
                var e = "duration" === t.reason;
                ("AFTER" === h && e || "DURING" === h && 0 === c.duration) && A(), e && P()
            }).on("progress.internal", function(t) {
                A()
            }).on("add.internal", function(t) {
                P()
            }).on("destroy.internal", function(t) {
                l.removePin(t.reset)
            });
            var A = function(t) {
                    if (v && o) {
                        var e = o.info(),
                            i = y.spacer.firstChild;
                        if (t || "DURING" !== h) {
                            var r = {
                                    position: y.inFlow ? "relative" : "absolute",
                                    top: 0,
                                    left: 0
                                },
                                s = n.css(i, "position") != r.position;
                            y.pushFollowers ? c.duration > 0 && ("AFTER" === h && 0 === parseFloat(n.css(y.spacer, "padding-top")) ? s = !0 : "BEFORE" === h && 0 === parseFloat(n.css(y.spacer, "padding-bottom")) && (s = !0)) : r[e.vertical ? "top" : "left"] = c.duration * u, n.css(i, r), s && P()
                        } else {
                            "fixed" != n.css(i, "position") && (n.css(i, {
                                position: "fixed"
                            }), P());
                            var a = n.get.offset(y.spacer, !0),
                                l = c.reverse || 0 === c.duration ? e.scrollPos - d.start : Math.round(u * c.duration * 10) / 10;
                            a[e.vertical ? "top" : "left"] += l, n.css(y.spacer.firstChild, {
                                top: a.top,
                                left: a.left
                            })
                        }
                    }
                },
                P = function() {
                    if (v && o && y.inFlow) {
                        var t = "DURING" === h,
                            e = o.info("vertical"),
                            i = y.spacer.firstChild,
                            r = n.isMarginCollapseType(n.css(y.spacer, "display")),
                            s = {};
                        y.relSize.width || y.relSize.autoFullWidth ? t ? n.css(v, {
                            width: n.get.width(y.spacer)
                        }) : n.css(v, {
                            width: "100%"
                        }) : (s["min-width"] = n.get.width(e ? v : i, !0, !0), s.width = t ? s["min-width"] : "auto"), y.relSize.height ? t ? n.css(v, {
                            height: n.get.height(y.spacer) - (y.pushFollowers ? c.duration : 0)
                        }) : n.css(v, {
                            height: "100%"
                        }) : (s["min-height"] = n.get.height(e ? i : v, !0, !r), s.height = t ? s["min-height"] : "auto"), y.pushFollowers && (s["padding" + (e ? "Top" : "Left")] = c.duration * u, s["padding" + (e ? "Bottom" : "Right")] = c.duration * (1 - u)), n.css(y.spacer, s)
                    }
                },
                C = function() {
                    o && v && "DURING" === h && !o.info("isDocument") && A()
                },
                R = function() {
                    o && v && "DURING" === h && ((y.relSize.width || y.relSize.autoFullWidth) && n.get.width(window) != n.get.width(y.spacer.parentNode) || y.relSize.height && n.get.height(window) != n.get.height(y.spacer.parentNode)) && P()
                },
                L = function(t) {
                    o && v && "DURING" === h && !o.info("isDocument") && (t.preventDefault(), o._setScrollPos(o.info("scrollPos") - ((t.wheelDelta || t[o.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -t.detail)))
                };
            this.setPin = function(t, e) {
                var i = e && e.hasOwnProperty("pushFollowers");
                if (e = n.extend({}, {
                        pushFollowers: !0,
                        spacerClass: "scrollmagic-pin-spacer"
                    }, e), !(t = n.get.elements(t)[0])) return g(1, "ERROR calling method 'setPin()': Invalid pin element supplied."), l;
                if ("fixed" === n.css(t, "position")) return g(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'."), l;
                if (v) {
                    if (v === t) return l;
                    l.removePin()
                }
                var r = (v = t).parentNode.style.display,
                    o = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
                v.parentNode.style.display = "none";
                var s = "absolute" != n.css(v, "position"),
                    a = n.css(v, o.concat(["display"])),
                    h = n.css(v, ["width", "height"]);
                v.parentNode.style.display = r, !s && e.pushFollowers && (g(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled."), e.pushFollowers = !1), window.setTimeout(function() {
                    v && 0 === c.duration && i && e.pushFollowers && g(2, "WARNING: pushFollowers =", !0, "has no effect, when scene duration is 0.")
                }, 0);
                var u = v.parentNode.insertBefore(document.createElement("div"), v),
                    d = n.extend(a, {
                        position: s ? "relative" : "absolute",
                        boxSizing: "content-box",
                        mozBoxSizing: "content-box",
                        webkitBoxSizing: "content-box"
                    });
                if (s || n.extend(d, n.css(v, ["width", "height"])), n.css(u, d), u.setAttribute("data-scrollmagic-pin-spacer", ""), n.addClass(u, e.spacerClass), y = {
                        spacer: u,
                        relSize: {
                            width: "%" === h.width.slice(-1),
                            height: "%" === h.height.slice(-1),
                            autoFullWidth: "auto" === h.width && s && n.isMarginCollapseType(a.display)
                        },
                        pushFollowers: e.pushFollowers,
                        inFlow: s
                    }, !v.___origStyle) {
                    v.___origStyle = {};
                    var p = v.style;
                    o.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]).forEach(function(t) {
                        v.___origStyle[t] = p[t] || ""
                    })
                }
                return y.relSize.width && n.css(u, {
                    width: h.width
                }), y.relSize.height && n.css(u, {
                    height: h.height
                }), u.appendChild(v), n.css(v, {
                    position: s ? "relative" : "absolute",
                    margin: "auto",
                    top: "auto",
                    left: "auto",
                    bottom: "auto",
                    right: "auto"
                }), (y.relSize.width || y.relSize.autoFullWidth) && n.css(v, {
                    boxSizing: "border-box",
                    mozBoxSizing: "border-box",
                    webkitBoxSizing: "border-box"
                }), window.addEventListener("scroll", C), window.addEventListener("resize", C), window.addEventListener("resize", R), v.addEventListener("mousewheel", L), v.addEventListener("DOMMouseScroll", L), g(3, "added pin"), A(), l
            }, this.removePin = function(t) {
                if (v) {
                    if ("DURING" === h && A(!0), t || !o) {
                        var e = y.spacer.firstChild;
                        if (e.hasAttribute("data-scrollmagic-pin-spacer")) {
                            var i = y.spacer.style,
                                r = {};
                            ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"].forEach(function(t) {
                                r[t] = i[t] || ""
                            }), n.css(e, r)
                        }
                        y.spacer.parentNode.insertBefore(e, y.spacer), y.spacer.parentNode.removeChild(y.spacer), v.parentNode.hasAttribute("data-scrollmagic-pin-spacer") || (n.css(v, v.___origStyle), delete v.___origStyle)
                    }
                    window.removeEventListener("scroll", C), window.removeEventListener("resize", C), window.removeEventListener("resize", R), v.removeEventListener("mousewheel", L), v.removeEventListener("DOMMouseScroll", L), v = void 0, g(3, "removed pin (reset: " + (t ? "true" : "false") + ")")
                }
                return l
            };
            var O, k = [];
            return l.on("destroy.internal", function(t) {
                    l.removeClassToggle(t.reset)
                }), this.setClassToggle = function(t, e) {
                    var i = n.get.elements(t);
                    return 0 !== i.length && n.type.String(e) ? (k.length > 0 && l.removeClassToggle(), O = e, k = i, l.on("enter.internal_class leave.internal_class", function(t) {
                        var e = "enter" === t.type ? n.addClass : n.removeClass;
                        k.forEach(function(t, i) {
                            e(t, O)
                        })
                    }), l) : (g(1, "ERROR calling method 'setClassToggle()': Invalid " + (0 === i.length ? "element" : "classes") + " supplied."), l)
                }, this.removeClassToggle = function(t) {
                    return t && k.forEach(function(t, e) {
                        n.removeClass(t, O)
                    }), l.off("start.internal_class end.internal_class"), O = void 0, k = [], l
                },
                function() {
                    for (var t in c) a.hasOwnProperty(t) || (g(2, 'WARNING: Unknown option "' + t + '"'), delete c[t]);
                    for (var e in a) E(e);
                    S()
                }(), l
        };
        var i = {
            defaults: {
                duration: 0,
                offset: 0,
                triggerElement: void 0,
                triggerHook: .5,
                reverse: !0,
                loglevel: 2
            },
            validate: {
                offset: function(t) {
                    if (t = parseFloat(t), !n.type.Number(t)) throw ['Invalid value for option "offset":', t];
                    return t
                },
                triggerElement: function(t) {
                    if (t = t || void 0) {
                        var e = n.get.elements(t)[0];
                        if (!e || !e.parentNode) throw ['Element defined in option "triggerElement" was not found:', t];
                        t = e
                    }
                    return t
                },
                triggerHook: function(t) {
                    var e = {
                        onCenter: .5,
                        onEnter: 1,
                        onLeave: 0
                    };
                    if (n.type.Number(t)) t = Math.max(0, Math.min(parseFloat(t), 1));
                    else {
                        if (!(t in e)) throw ['Invalid value for option "triggerHook": ', t];
                        t = e[t]
                    }
                    return t
                },
                reverse: function(t) {
                    return !!t
                },
                loglevel: function(t) {
                    if (t = parseInt(t), !n.type.Number(t) || t < 0 || t > 3) throw ['Invalid value for option "loglevel":', t];
                    return t
                }
            },
            shifts: ["duration", "offset", "triggerHook"]
        };
        t.Scene.addOption = function(e, n, r, o) {
            e in i.defaults ? t._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + e + "', because it already exists.") : (i.defaults[e] = n, i.validate[e] = r, o && i.shifts.push(e))
        }, t.Scene.extend = function(e) {
            var i = this;
            t.Scene = function() {
                return i.apply(this, arguments), this.$super = n.extend({}, this), e.apply(this, arguments) || this
            }, n.extend(t.Scene, i), t.Scene.prototype = i.prototype, t.Scene.prototype.constructor = t.Scene
        }, t.Event = function(t, e, i, n) {
            for (var r in n = n || {}) this[r] = n[r];
            return this.type = t, this.target = this.currentTarget = i, this.namespace = e || "", this.timeStamp = this.timestamp = Date.now(), this
        };
        var n = t._util = function(t) {
            var e, i = {},
                n = function(t) {
                    return parseFloat(t) || 0
                },
                r = function(e) {
                    return e.currentStyle ? e.currentStyle : t.getComputedStyle(e)
                },
                o = function(e, i, o, s) {
                    if ((i = i === document ? t : i) === t) s = !1;
                    else if (!f.DomElement(i)) return 0;
                    e = e.charAt(0).toUpperCase() + e.substr(1).toLowerCase();
                    var a = (o ? i["offset" + e] || i["outer" + e] : i["client" + e] || i["inner" + e]) || 0;
                    if (o && s) {
                        var l = r(i);
                        a += "Height" === e ? n(l.marginTop) + n(l.marginBottom) : n(l.marginLeft) + n(l.marginRight)
                    }
                    return a
                },
                s = function(t) {
                    return t.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, function(t) {
                        return t[1].toUpperCase()
                    })
                };
            i.extend = function(t) {
                for (t = t || {}, e = 1; e < arguments.length; e++)
                    if (arguments[e])
                        for (var i in arguments[e]) arguments[e].hasOwnProperty(i) && (t[i] = arguments[e][i]);
                return t
            }, i.isMarginCollapseType = function(t) {
                return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(t) > -1
            };
            var a = 0,
                l = ["ms", "moz", "webkit", "o"],
                c = t.requestAnimationFrame,
                h = t.cancelAnimationFrame;
            for (e = 0; !c && e < l.length; ++e) c = t[l[e] + "RequestAnimationFrame"], h = t[l[e] + "CancelAnimationFrame"] || t[l[e] + "CancelRequestAnimationFrame"];
            c || (c = function(e) {
                var i = (new Date).getTime(),
                    n = Math.max(0, 16 - (i - a)),
                    r = t.setTimeout(function() {
                        e(i + n)
                    }, n);
                return a = i + n, r
            }), h || (h = function(e) {
                t.clearTimeout(e)
            }), i.rAF = c.bind(t), i.cAF = h.bind(t);
            var u = ["error", "warn", "log"],
                d = t.console || {};
            for (d.log = d.log || function() {}, e = 0; e < u.length; e++) {
                var p = u[e];
                d[p] || (d[p] = d.log)
            }
            i.log = function(t) {
                (t > u.length || t <= 0) && (t = u.length);
                var e = new Date,
                    i = ("0" + e.getHours()).slice(-2) + ":" + ("0" + e.getMinutes()).slice(-2) + ":" + ("0" + e.getSeconds()).slice(-2) + ":" + ("00" + e.getMilliseconds()).slice(-3),
                    n = u[t - 1],
                    r = Array.prototype.splice.call(arguments, 1),
                    o = Function.prototype.bind.call(d[n], d);
                r.unshift(i), o.apply(d, r)
            };
            var f = i.type = function(t) {
                return Object.prototype.toString.call(t).replace(/^\[object (.+)\]$/, "$1").toLowerCase()
            };
            f.String = function(t) {
                return "string" === f(t)
            }, f.Function = function(t) {
                return "function" === f(t)
            }, f.Array = function(t) {
                return Array.isArray(t)
            }, f.Number = function(t) {
                return !f.Array(t) && t - parseFloat(t) + 1 >= 0
            }, f.DomElement = function(t) {
                return "object" == typeof HTMLElement || "function" == typeof HTMLElement ? t instanceof HTMLElement || t instanceof SVGElement : t && "object" == typeof t && null !== t && 1 === t.nodeType && "string" == typeof t.nodeName
            };
            var m = i.get = {};
            return m.elements = function(e) {
                var i = [];
                if (f.String(e)) try {
                    e = document.querySelectorAll(e)
                } catch (t) {
                    return i
                }
                if ("nodelist" === f(e) || f.Array(e) || e instanceof NodeList)
                    for (var n = 0, r = i.length = e.length; n < r; n++) {
                        var o = e[n];
                        i[n] = f.DomElement(o) ? o : m.elements(o)
                    } else(f.DomElement(e) || e === document || e === t) && (i = [e]);
                return i
            }, m.scrollTop = function(e) {
                return e && "number" == typeof e.scrollTop ? e.scrollTop : t.pageYOffset || 0
            }, m.scrollLeft = function(e) {
                return e && "number" == typeof e.scrollLeft ? e.scrollLeft : t.pageXOffset || 0
            }, m.width = function(t, e, i) {
                return o("width", t, e, i)
            }, m.height = function(t, e, i) {
                return o("height", t, e, i)
            }, m.offset = function(t, e) {
                var i = {
                    top: 0,
                    left: 0
                };
                if (t && t.getBoundingClientRect) {
                    var n = t.getBoundingClientRect();
                    i.top = n.top, i.left = n.left, e || (i.top += m.scrollTop(), i.left += m.scrollLeft())
                }
                return i
            }, i.addClass = function(t, e) {
                e && (t.classList ? t.classList.add(e) : t.className += " " + e)
            }, i.removeClass = function(t, e) {
                e && (t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(^|\\b)" + e.split(" ").join("|") + "(\\b|$)", "gi"), " "))
            }, i.css = function(t, e) {
                if (f.String(e)) return r(t)[s(e)];
                if (f.Array(e)) {
                    var i = {},
                        n = r(t);
                    return e.forEach(function(t, e) {
                        i[t] = n[s(t)]
                    }), i
                }
                for (var o in e) {
                    var a = e[o];
                    a == parseFloat(a) && (a += "px"), t.style[s(o)] = a
                }
            }, i
        }(window || {});
        return t.Scene.prototype.addIndicators = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
        }, t.Scene.prototype.removeIndicators = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
        }, t.Scene.prototype.setTween = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
        }, t.Scene.prototype.removeTween = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
        }, t.Scene.prototype.setVelocity = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
        }, t.Scene.prototype.removeVelocity = function() {
            return t._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
        }, t
    }),
    function(t, e) {
        "function" == typeof define && define.amd ? define(["ScrollMagic", "TweenMax", "TimelineMax"], e) : "object" == typeof exports ? (require("gsap"), e(require("scrollmagic"), TweenMax, TimelineMax)) : e(t.ScrollMagic || t.jQuery && t.jQuery.ScrollMagic, t.TweenMax || t.TweenLite, t.TimelineMax || t.TimelineLite)
    }(this, function(t, e, i) {
        "use strict";
        var n = window.console || {},
            r = Function.prototype.bind.call(n.error || n.log || function() {}, n);
        t || r("(animation.gsap) -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs."), e || r("(animation.gsap) -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs."), t.Scene.addOption("tweenChanges", !1, function(t) {
            return !!t
        }), t.Scene.extend(function() {
            var t, n = this,
                r = function() {
                    n._log && (Array.prototype.splice.call(arguments, 1, 0, "(animation.gsap)", "->"), n._log.apply(this, arguments))
                };
            n.on("progress.plugin_gsap", function() {
                o()
            }), n.on("destroy.plugin_gsap", function(t) {
                n.removeTween(t.reset)
            });
            var o = function() {
                if (t) {
                    var e = n.progress(),
                        i = n.state();
                    t.repeat && -1 === t.repeat() ? "DURING" === i && t.paused() ? t.play() : "DURING" === i || t.paused() || t.pause() : e != t.progress() && (0 === n.duration() ? e > 0 ? t.play() : t.reverse() : n.tweenChanges() && t.tweenTo ? t.tweenTo(e * t.duration()) : t.progress(e).pause())
                }
            };
            n.setTween = function(s, a, l) {
                var c;
                arguments.length > 1 && (arguments.length < 3 && (l = a, a = 1), s = e.to(s, a, l));
                try {
                    (c = i ? new i({
                        smoothChildTiming: !0
                    }).add(s) : s).pause()
                } catch (t) {
                    return r(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject"), n
                }
                if (t && n.removeTween(), t = c, s.repeat && -1 === s.repeat() && (t.repeat(-1), t.yoyo(s.yoyo())), n.tweenChanges() && !t.tweenTo && r(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic."), t && n.controller() && n.triggerElement() && n.loglevel() >= 2) {
                    var h = e.getTweensOf(n.triggerElement()),
                        u = n.controller().info("vertical");
                    h.forEach(function(t, e) {
                        var i = t.vars.css || t.vars;
                        if (u ? void 0 !== i.top || void 0 !== i.bottom : void 0 !== i.left || void 0 !== i.right) return r(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!"), !1
                    })
                }
                if (parseFloat(TweenLite.version) >= 1.14)
                    for (var d, p, f = t.getChildren ? t.getChildren(!0, !0, !1) : [t], m = function() {
                            r(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another")
                        }, g = 0; g < f.length; g++) d = f[g], p !== m && (p = d.vars.onOverwrite, d.vars.onOverwrite = function() {
                        p && p.apply(this, arguments), m.apply(this, arguments)
                    });
                return r(3, "added tween"), o(), n
            }, n.removeTween = function(e) {
                return t && (e && t.progress(0).pause(), t.kill(), t = void 0, r(3, "removed tween (reset: " + (e ? "true" : "false") + ")")), n
            }
        })
    });
var hoverEffect = function(t) {
    var e = t.parent || console.warn("no parent"),
        i = t.displacementImage || console.warn("displacement image missing"),
        n = t.image1 || console.warn("first image missing"),
        r = t.image2 || console.warn("second image missing"),
        o = t.intensity || 1,
        s = t.speedIn || 1.6,
        a = t.speedOut || 1.2,
        l = void 0 === t.hover || t.hover,
        c = t.easing || Expo.easeOut;
    if (void 0 === n || void 0 === r) return void console.warn("Images missing, backing out of script.");
    let h = t.coverImage || !0;

    function u(t, e, i, n, r, o) {
        0 === t && (console.warn("No content width passed, using container width instead"), t = i), 0 === e && (console.warn("No content height passed, using container height instead"), e = n);
        var s, a, l = t / e;
        return l > i / n ? (s = n, a = n * l) : (a = i, s = i / l), {
            width: a,
            height: s,
            offsetLeft: (i - a) * (r = void 0 === r ? .5 : r),
            offsetTop: (n - s) * (o = void 0 === o ? .5 : o)
        }
    }
    var d = new THREE.Scene,
        p = new THREE.OrthographicCamera(e.offsetWidth / -2, e.offsetWidth / 2, e.offsetHeight / 2, e.offsetHeight / -2, 1, 1e3);
    p.position.z = 1;
    var f = new THREE.WebGLRenderer({
        antialias: !1
    });
    f.setPixelRatio(window.devicePixelRatio), f.setClearColor(16777215, 0), f.setSize(e.offsetWidth, e.offsetHeight), e.appendChild(f.domElement);
    var m = new THREE.TextureLoader;
    m.crossOrigin = "";
    var g = m.load(n.dataset.src),
        v = m.load(r.dataset.src),
        y = m.load(i);
    y.wrapS = y.wrapT = THREE.RepeatWrapping, g.magFilter = v.magFilter = THREE.LinearFilter, g.minFilter = v.minFilter = THREE.LinearFilter, g.anisotropy = f.capabilities.getMaxAnisotropy(), v.anisotropy = f.capabilities.getMaxAnisotropy();
    var _ = new THREE.ShaderMaterial({
        uniforms: {
            effectFactor: {
                type: "f",
                value: o
            },
            dispFactor: {
                type: "f",
                value: 0
            },
            texture: {
                type: "t",
                value: g
            },
            texture2: {
                type: "t",
                value: v
            },
            disp: {
                type: "t",
                value: y
            }
        },
        vertexShader: "\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n    ",
        fragmentShader: "\n        varying vec2 vUv;\n\n        uniform sampler2D texture;\n        uniform sampler2D texture2;\n        uniform sampler2D disp;\n\n        // uniform float time;\n        // uniform float _rot;\n        uniform float dispFactor;\n        uniform float effectFactor;\n\n        // vec2 rotate(vec2 v, float a) {\n        //  float s = sin(a);\n        //  float c = cos(a);\n        //  mat2 m = mat2(c, -s, s, c);\n        //  return m * v;\n        // }\n\n        void main() {\n\n            vec2 uv = vUv;\n\n            // uv -= 0.5;\n            // vec2 rotUV = rotate(uv, _rot);\n            // uv += 0.5;\n\n            vec4 disp = texture2D(disp, uv);\n\n            vec2 distortedPosition = vec2(uv.x + dispFactor * (disp.r*effectFactor), uv.y);\n            vec2 distortedPosition2 = vec2(uv.x - (1.0 - dispFactor) * (disp.r*effectFactor), uv.y);\n\n            vec4 _texture = texture2D(texture, distortedPosition);\n            vec4 _texture2 = texture2D(texture2, distortedPosition2);\n\n            vec4 finalTexture = mix(_texture, _texture2, dispFactor);\n\n            gl_FragColor = finalTexture;\n            // gl_FragColor = disp;\n        }\n    ",
        transparent: !0,
        opacity: 1
    });

    function x() {
        if (h) {
            let i = u(n.offsetWidth, n.offsetHeight, e.offsetWidth, e.offsetHeight).height,
                r = u(n.offsetWidth, n.offsetHeight, e.offsetWidth, e.offsetHeight).width;
            var t = new THREE.PlaneBufferGeometry(r, i, 1)
        } else t = new THREE.PlaneBufferGeometry(e.offsetWidth, e.offsetHeight, 1);
        return t
    }
    let w = x();
    var b = new THREE.Mesh(w, _);
    d.add(b);
    var T, S, M, E;
    l && (M = "mouseenter", E = "mouseleave", S = !1, T = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(T) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(T.substr(0, 4))) && (S = !0), S && (M = "touchstart", E = "touchend"), e.addEventListener(M, function(t) {
        TweenMax.to(_.uniforms.dispFactor, s, {
            value: 1,
            ease: c
        })
    }), e.addEventListener(E, function(t) {
        TweenMax.to(_.uniforms.dispFactor, a, {
            value: 0,
            ease: c
        })
    })), window.addEventListener("resize", function(t) {
        f.setSize(e.offsetWidth, e.offsetHeight);
        let i = x();
        b.geometry = i, p.left = e.offsetWidth / -2, p.right = e.offsetWidth / 2, p.top = e.offsetHeight / 2, p.bottom = e.offsetHeight / -2, p.updateProjectionMatrix()
    }), this.next = function() {
        TweenMax.to(_.uniforms.dispFactor, s, {
            value: 1,
            ease: c
        })
    }, this.previous = function() {
        TweenMax.to(_.uniforms.dispFactor, a, {
            value: 0,
            ease: c
        })
    };
    var A = function() {
        requestAnimationFrame(A), f.render(d, p)
    };
    A()
};
! function() {
    "use strict";
    var t = 0,
        e = {};

    function i(n) {
        if (!n) throw new Error("No options passed to Waypoint constructor");
        if (!n.element) throw new Error("No element option passed to Waypoint constructor");
        if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
        this.key = "waypoint-" + t, this.options = i.Adapter.extend({}, i.defaults, n), this.element = this.options.element, this.adapter = new i.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = i.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        }), this.context = i.Context.findOrCreateByElement(this.options.context), i.offsetAliases[this.options.offset] && (this.options.offset = i.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), e[this.key] = this, t += 1
    }
    i.prototype.queueTrigger = function(t) {
        this.group.queueTrigger(this, t)
    }, i.prototype.trigger = function(t) {
        this.enabled && this.callback && this.callback.apply(this, t)
    }, i.prototype.destroy = function() {
        this.context.remove(this), this.group.remove(this), delete e[this.key]
    }, i.prototype.disable = function() {
        return this.enabled = !1, this
    }, i.prototype.enable = function() {
        return this.context.refresh(), this.enabled = !0, this
    }, i.prototype.next = function() {
        return this.group.next(this)
    }, i.prototype.previous = function() {
        return this.group.previous(this)
    }, i.invokeAll = function(t) {
        var i = [];
        for (var n in e) i.push(e[n]);
        for (var r = 0, o = i.length; r < o; r++) i[r][t]()
    }, i.destroyAll = function() {
        i.invokeAll("destroy")
    }, i.disableAll = function() {
        i.invokeAll("disable")
    }, i.enableAll = function() {
        for (var t in i.Context.refreshAll(), e) e[t].enabled = !0;
        return this
    }, i.refreshAll = function() {
        i.Context.refreshAll()
    }, i.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight
    }, i.viewportWidth = function() {
        return document.documentElement.clientWidth
    }, i.adapters = [], i.defaults = {
        context: window,
        continuous: !0,
        enabled: !0,
        group: "default",
        horizontal: !1,
        offset: 0
    }, i.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }, window.Waypoint = i
}(),
function() {
    "use strict";

    function t(t) {
        window.setTimeout(t, 1e3 / 60)
    }
    var e = 0,
        i = {},
        n = window.Waypoint,
        r = window.onload;

    function o(t) {
        this.element = t, this.Adapter = n.Adapter, this.adapter = new this.Adapter(t), this.key = "waypoint-context-" + e, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }, this.waypoints = {
            vertical: {},
            horizontal: {}
        }, t.waypointContextKey = this.key, i[t.waypointContextKey] = this, e += 1, n.windowContext || (n.windowContext = !0, n.windowContext = new o(window)), this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
    }
    o.prototype.add = function(t) {
        var e = t.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[e][t.key] = t, this.refresh()
    }, o.prototype.checkEmpty = function() {
        var t = this.Adapter.isEmptyObject(this.waypoints.horizontal),
            e = this.Adapter.isEmptyObject(this.waypoints.vertical),
            n = this.element == this.element.window;
        t && e && !n && (this.adapter.off(".waypoints"), delete i[this.key])
    }, o.prototype.createThrottledResizeHandler = function() {
        var t = this;

        function e() {
            t.handleResize(), t.didResize = !1
        }
        this.adapter.on("resize.waypoints", function() {
            t.didResize || (t.didResize = !0, n.requestAnimationFrame(e))
        })
    }, o.prototype.createThrottledScrollHandler = function() {
        var t = this;

        function e() {
            t.handleScroll(), t.didScroll = !1
        }
        this.adapter.on("scroll.waypoints", function() {
            t.didScroll && !n.isTouch || (t.didScroll = !0, n.requestAnimationFrame(e))
        })
    }, o.prototype.handleResize = function() {
        n.Context.refreshAll()
    }, o.prototype.handleScroll = function() {
        var t = {},
            e = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
        for (var i in e) {
            var n = e[i],
                r = n.newScroll > n.oldScroll ? n.forward : n.backward;
            for (var o in this.waypoints[i]) {
                var s = this.waypoints[i][o];
                if (null !== s.triggerPoint) {
                    var a = n.oldScroll < s.triggerPoint,
                        l = n.newScroll >= s.triggerPoint;
                    (a && l || !a && !l) && (s.queueTrigger(r), t[s.group.id] = s.group)
                }
            }
        }
        for (var c in t) t[c].flushTriggers();
        this.oldScroll = {
            x: e.horizontal.newScroll,
            y: e.vertical.newScroll
        }
    }, o.prototype.innerHeight = function() {
        return this.element == this.element.window ? n.viewportHeight() : this.adapter.innerHeight()
    }, o.prototype.remove = function(t) {
        delete this.waypoints[t.axis][t.key], this.checkEmpty()
    }, o.prototype.innerWidth = function() {
        return this.element == this.element.window ? n.viewportWidth() : this.adapter.innerWidth()
    }, o.prototype.destroy = function() {
        var t = [];
        for (var e in this.waypoints)
            for (var i in this.waypoints[e]) t.push(this.waypoints[e][i]);
        for (var n = 0, r = t.length; n < r; n++) t[n].destroy()
    }, o.prototype.refresh = function() {
        var t, e = this.element == this.element.window,
            i = e ? void 0 : this.adapter.offset(),
            r = {};
        for (var o in this.handleScroll(), t = {
                horizontal: {
                    contextOffset: e ? 0 : i.left,
                    contextScroll: e ? 0 : this.oldScroll.x,
                    contextDimension: this.innerWidth(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left",
                    offsetProp: "left"
                },
                vertical: {
                    contextOffset: e ? 0 : i.top,
                    contextScroll: e ? 0 : this.oldScroll.y,
                    contextDimension: this.innerHeight(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up",
                    offsetProp: "top"
                }
            }) {
            var s = t[o];
            for (var a in this.waypoints[o]) {
                var l, c, h, u, d = this.waypoints[o][a],
                    p = d.options.offset,
                    f = d.triggerPoint,
                    m = 0,
                    g = null == f;
                d.element !== d.element.window && (m = d.adapter.offset()[s.offsetProp]), "function" == typeof p ? p = p.apply(d) : "string" == typeof p && (p = parseFloat(p), d.options.offset.indexOf("%") > -1 && (p = Math.ceil(s.contextDimension * p / 100))), l = s.contextScroll - s.contextOffset, d.triggerPoint = Math.floor(m + l - p), c = f < s.oldScroll, h = d.triggerPoint >= s.oldScroll, u = !c && !h, !g && (c && h) ? (d.queueTrigger(s.backward), r[d.group.id] = d.group) : !g && u ? (d.queueTrigger(s.forward), r[d.group.id] = d.group) : g && s.oldScroll >= d.triggerPoint && (d.queueTrigger(s.forward), r[d.group.id] = d.group)
            }
        }
        return n.requestAnimationFrame(function() {
            for (var t in r) r[t].flushTriggers()
        }), this
    }, o.findOrCreateByElement = function(t) {
        return o.findByElement(t) || new o(t)
    }, o.refreshAll = function() {
        for (var t in i) i[t].refresh()
    }, o.findByElement = function(t) {
        return i[t.waypointContextKey]
    }, window.onload = function() {
        r && r(), o.refreshAll()
    }, n.requestAnimationFrame = function(e) {
        (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || t).call(window, e)
    }, n.Context = o
}(),
function() {
    "use strict";

    function t(t, e) {
        return t.triggerPoint - e.triggerPoint
    }

    function e(t, e) {
        return e.triggerPoint - t.triggerPoint
    }
    var i = {
            vertical: {},
            horizontal: {}
        },
        n = window.Waypoint;

    function r(t) {
        this.name = t.name, this.axis = t.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), i[this.axis][this.name] = this
    }
    r.prototype.add = function(t) {
        this.waypoints.push(t)
    }, r.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }, r.prototype.flushTriggers = function() {
        for (var i in this.triggerQueues) {
            var n = this.triggerQueues[i],
                r = "up" === i || "left" === i;
            n.sort(r ? e : t);
            for (var o = 0, s = n.length; o < s; o += 1) {
                var a = n[o];
                (a.options.continuous || o === n.length - 1) && a.trigger([i])
            }
        }
        this.clearTriggerQueues()
    }, r.prototype.next = function(e) {
        this.waypoints.sort(t);
        var i = n.Adapter.inArray(e, this.waypoints);
        return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1]
    }, r.prototype.previous = function(e) {
        this.waypoints.sort(t);
        var i = n.Adapter.inArray(e, this.waypoints);
        return i ? this.waypoints[i - 1] : null
    }, r.prototype.queueTrigger = function(t, e) {
        this.triggerQueues[e].push(t)
    }, r.prototype.remove = function(t) {
        var e = n.Adapter.inArray(t, this.waypoints);
        e > -1 && this.waypoints.splice(e, 1)
    }, r.prototype.first = function() {
        return this.waypoints[0]
    }, r.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1]
    }, r.findOrCreate = function(t) {
        return i[t.axis][t.name] || new r(t)
    }, n.Group = r
}(),
function() {
    "use strict";
    var t = window.jQuery,
        e = window.Waypoint;

    function i(e) {
        this.$element = t(e)
    }
    t.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], function(t, e) {
        i.prototype[e] = function() {
            var t = Array.prototype.slice.call(arguments);
            return this.$element[e].apply(this.$element, t)
        }
    }), t.each(["extend", "inArray", "isEmptyObject"], function(e, n) {
        i[n] = t[n]
    }), e.adapters.push({
        name: "jquery",
        Adapter: i
    }), e.Adapter = i
}(),
function() {
    "use strict";
    var t = window.Waypoint;

    function e(e) {
        return function() {
            var i = [],
                n = arguments[0];
            return e.isFunction(arguments[0]) && ((n = e.extend({}, arguments[1])).handler = arguments[0]), this.each(function() {
                var r = e.extend({}, n, {
                    element: this
                });
                "string" == typeof r.context && (r.context = e(this).closest(r.context)[0]), i.push(new t(r))
            }), i
        }
    }
    window.jQuery && (window.jQuery.fn.waypoint = e(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = e(window.Zepto))
}(),
function(t) {
    "use strict";
    "function" == typeof define && define.amd ? define(["jquery"], t) : "undefined" != typeof exports ? module.exports = t(require("jquery")) : t(jQuery)
}(function(t) {
    "use strict";
    var e = window.Slick || {};
    (e = function() {
        var e = 0;
        return function(i, n) {
            var r, o = this;
            o.defaults = {
                accessibility: !0,
                adaptiveHeight: !1,
                appendArrows: t(i),
                appendDots: t(i),
                arrows: !0,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: !1,
                autoplaySpeed: 3e3,
                centerMode: !1,
                centerPadding: "50px",
                cssEase: "ease",
                customPaging: function(e, i) {
                    return t('<button type="button" />').text(i + 1)
                },
                dots: !1,
                dotsClass: "slick-dots",
                draggable: !0,
                easing: "linear",
                edgeFriction: .35,
                fade: !1,
                focusOnSelect: !1,
                focusOnChange: !1,
                infinite: !0,
                initialSlide: 0,
                lazyLoad: "ondemand",
                mobileFirst: !1,
                pauseOnHover: !0,
                pauseOnFocus: !0,
                pauseOnDotsHover: !1,
                respondTo: "window",
                responsive: null,
                rows: 1,
                rtl: !1,
                slide: "",
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: !0,
                swipeToSlide: !1,
                touchMove: !0,
                touchThreshold: 5,
                useCSS: !0,
                useTransform: !0,
                variableWidth: !1,
                vertical: !1,
                verticalSwiping: !1,
                waitForAnimate: !0,
                zIndex: 1e3
            }, o.initials = {
                animating: !1,
                dragging: !1,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                scrolling: !1,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: !1,
                slideOffset: 0,
                swipeLeft: null,
                swiping: !1,
                $list: null,
                touchObject: {},
                transformsEnabled: !1,
                unslicked: !1
            }, t.extend(o, o.initials), o.activeBreakpoint = null, o.animType = null, o.animProp = null, o.breakpoints = [], o.breakpointSettings = [], o.cssTransitions = !1, o.focussed = !1, o.interrupted = !1, o.hidden = "hidden", o.paused = !0, o.positionProp = null, o.respondTo = null, o.rowCount = 1, o.shouldClick = !0, o.$slider = t(i), o.$slidesCache = null, o.transformType = null, o.transitionType = null, o.visibilityChange = "visibilitychange", o.windowWidth = 0, o.windowTimer = null, r = t(i).data("slick") || {}, o.options = t.extend({}, o.defaults, n, r), o.currentSlide = o.options.initialSlide, o.originalSettings = o.options, void 0 !== document.mozHidden ? (o.hidden = "mozHidden", o.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (o.hidden = "webkitHidden", o.visibilityChange = "webkitvisibilitychange"), o.autoPlay = t.proxy(o.autoPlay, o), o.autoPlayClear = t.proxy(o.autoPlayClear, o), o.autoPlayIterator = t.proxy(o.autoPlayIterator, o), o.changeSlide = t.proxy(o.changeSlide, o), o.clickHandler = t.proxy(o.clickHandler, o), o.selectHandler = t.proxy(o.selectHandler, o), o.setPosition = t.proxy(o.setPosition, o), o.swipeHandler = t.proxy(o.swipeHandler, o), o.dragHandler = t.proxy(o.dragHandler, o), o.keyHandler = t.proxy(o.keyHandler, o), o.instanceUid = e++, o.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, o.registerBreakpoints(), o.init(!0)
        }
    }()).prototype.activateADA = function() {
        this.$slideTrack.find(".slick-active").attr({
            "aria-hidden": "false"
        }).find("a, input, button, select").attr({
            tabindex: "0"
        })
    }, e.prototype.addSlide = e.prototype.slickAdd = function(e, i, n) {
        var r = this;
        if ("boolean" == typeof i) n = i, i = null;
        else if (i < 0 || i >= r.slideCount) return !1;
        r.unload(), "number" == typeof i ? 0 === i && 0 === r.$slides.length ? t(e).appendTo(r.$slideTrack) : n ? t(e).insertBefore(r.$slides.eq(i)) : t(e).insertAfter(r.$slides.eq(i)) : !0 === n ? t(e).prependTo(r.$slideTrack) : t(e).appendTo(r.$slideTrack), r.$slides = r.$slideTrack.children(this.options.slide), r.$slideTrack.children(this.options.slide).detach(), r.$slideTrack.append(r.$slides), r.$slides.each(function(e, i) {
            t(i).attr("data-slick-index", e)
        }), r.$slidesCache = r.$slides, r.reinit()
    }, e.prototype.animateHeight = function() {
        var t = this;
        if (1 === t.options.slidesToShow && !0 === t.options.adaptiveHeight && !1 === t.options.vertical) {
            var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
            t.$list.animate({
                height: e
            }, t.options.speed)
        }
    }, e.prototype.animateSlide = function(e, i) {
        var n = {},
            r = this;
        r.animateHeight(), !0 === r.options.rtl && !1 === r.options.vertical && (e = -e), !1 === r.transformsEnabled ? !1 === r.options.vertical ? r.$slideTrack.animate({
            left: e
        }, r.options.speed, r.options.easing, i) : r.$slideTrack.animate({
            top: e
        }, r.options.speed, r.options.easing, i) : !1 === r.cssTransitions ? (!0 === r.options.rtl && (r.currentLeft = -r.currentLeft), t({
            animStart: r.currentLeft
        }).animate({
            animStart: e
        }, {
            duration: r.options.speed,
            easing: r.options.easing,
            step: function(t) {
                t = Math.ceil(t), !1 === r.options.vertical ? (n[r.animType] = "translate(" + t + "px, 0px)", r.$slideTrack.css(n)) : (n[r.animType] = "translate(0px," + t + "px)", r.$slideTrack.css(n))
            },
            complete: function() {
                i && i.call()
            }
        })) : (r.applyTransition(), e = Math.ceil(e), !1 === r.options.vertical ? n[r.animType] = "translate3d(" + e + "px, 0px, 0px)" : n[r.animType] = "translate3d(0px," + e + "px, 0px)", r.$slideTrack.css(n), i && setTimeout(function() {
            r.disableTransition(), i.call()
        }, r.options.speed))
    }, e.prototype.getNavTarget = function() {
        var e = this.options.asNavFor;
        return e && null !== e && (e = t(e).not(this.$slider)), e
    }, e.prototype.asNavFor = function(e) {
        var i = this.getNavTarget();
        null !== i && "object" == typeof i && i.each(function() {
            var i = t(this).slick("getSlick");
            i.unslicked || i.slideHandler(e, !0)
        })
    }, e.prototype.applyTransition = function(t) {
        var e = this,
            i = {};
        !1 === e.options.fade ? i[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : i[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, !1 === e.options.fade ? e.$slideTrack.css(i) : e.$slides.eq(t).css(i)
    }, e.prototype.autoPlay = function() {
        var t = this;
        t.autoPlayClear(), t.slideCount > t.options.slidesToShow && (t.autoPlayTimer = setInterval(t.autoPlayIterator, t.options.autoplaySpeed))
    }, e.prototype.autoPlayClear = function() {
        this.autoPlayTimer && clearInterval(this.autoPlayTimer)
    }, e.prototype.autoPlayIterator = function() {
        var t = this,
            e = t.currentSlide + t.options.slidesToScroll;
        t.paused || t.interrupted || t.focussed || (!1 === t.options.infinite && (1 === t.direction && t.currentSlide + 1 === t.slideCount - 1 ? t.direction = 0 : 0 === t.direction && (e = t.currentSlide - t.options.slidesToScroll, t.currentSlide - 1 == 0 && (t.direction = 1))), t.slideHandler(e))
    }, e.prototype.buildArrows = function() {
        var e = this;
        !0 === e.options.arrows && (e.$prevArrow = t(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = t(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), !0 !== e.options.infinite && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
            "aria-disabled": "true",
            tabindex: "-1"
        }))
    }, e.prototype.buildDots = function() {
        var e, i, n = this;
        if (!0 === n.options.dots && n.slideCount > n.options.slidesToShow) {
            for (n.$slider.addClass("slick-dotted"), i = t("<ul />").addClass(n.options.dotsClass), e = 0; e <= n.getDotCount(); e += 1) i.append(t("<li />").append(n.options.customPaging.call(this, n, e)));
            n.$dots = i.appendTo(n.options.appendDots), n.$dots.find("li").first().addClass("slick-active")
        }
    }, e.prototype.buildOut = function() {
        var e = this;
        e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function(e, i) {
            t(i).attr("data-slick-index", e).data("originalStyling", t(i).attr("style") || "")
        }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? t('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(), e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(), e.$slideTrack.css("opacity", 0), !0 !== e.options.centerMode && !0 !== e.options.swipeToSlide || (e.options.slidesToScroll = 1), t("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), !0 === e.options.draggable && e.$list.addClass("draggable")
    }, e.prototype.buildRows = function() {
        var t, e, i, n, r, o, s, a = this;
        if (n = document.createDocumentFragment(), o = a.$slider.children(), a.options.rows > 0) {
            for (s = a.options.slidesPerRow * a.options.rows, r = Math.ceil(o.length / s), t = 0; t < r; t++) {
                var l = document.createElement("div");
                for (e = 0; e < a.options.rows; e++) {
                    var c = document.createElement("div");
                    for (i = 0; i < a.options.slidesPerRow; i++) {
                        var h = t * s + (e * a.options.slidesPerRow + i);
                        o.get(h) && c.appendChild(o.get(h))
                    }
                    l.appendChild(c)
                }
                n.appendChild(l)
            }
            a.$slider.empty().append(n), a.$slider.children().children().children().css({
                width: 100 / a.options.slidesPerRow + "%",
                display: "inline-block"
            })
        }
    }, e.prototype.checkResponsive = function(e, i) {
        var n, r, o, s = this,
            a = !1,
            l = s.$slider.width(),
            c = window.innerWidth || t(window).width();
        if ("window" === s.respondTo ? o = c : "slider" === s.respondTo ? o = l : "min" === s.respondTo && (o = Math.min(c, l)), s.options.responsive && s.options.responsive.length && null !== s.options.responsive) {
            for (n in r = null, s.breakpoints) s.breakpoints.hasOwnProperty(n) && (!1 === s.originalSettings.mobileFirst ? o < s.breakpoints[n] && (r = s.breakpoints[n]) : o > s.breakpoints[n] && (r = s.breakpoints[n]));
            null !== r ? null !== s.activeBreakpoint ? (r !== s.activeBreakpoint || i) && (s.activeBreakpoint = r, "unslick" === s.breakpointSettings[r] ? s.unslick(r) : (s.options = t.extend({}, s.originalSettings, s.breakpointSettings[r]), !0 === e && (s.currentSlide = s.options.initialSlide), s.refresh(e)), a = r) : (s.activeBreakpoint = r, "unslick" === s.breakpointSettings[r] ? s.unslick(r) : (s.options = t.extend({}, s.originalSettings, s.breakpointSettings[r]), !0 === e && (s.currentSlide = s.options.initialSlide), s.refresh(e)), a = r) : null !== s.activeBreakpoint && (s.activeBreakpoint = null, s.options = s.originalSettings, !0 === e && (s.currentSlide = s.options.initialSlide), s.refresh(e), a = r), e || !1 === a || s.$slider.trigger("breakpoint", [s, a])
        }
    }, e.prototype.changeSlide = function(e, i) {
        var n, r, o = this,
            s = t(e.currentTarget);
        switch (s.is("a") && e.preventDefault(), s.is("li") || (s = s.closest("li")), n = o.slideCount % o.options.slidesToScroll != 0 ? 0 : (o.slideCount - o.currentSlide) % o.options.slidesToScroll, e.data.message) {
            case "previous":
                r = 0 === n ? o.options.slidesToScroll : o.options.slidesToShow - n, o.slideCount > o.options.slidesToShow && o.slideHandler(o.currentSlide - r, !1, i);
                break;
            case "next":
                r = 0 === n ? o.options.slidesToScroll : n, o.slideCount > o.options.slidesToShow && o.slideHandler(o.currentSlide + r, !1, i);
                break;
            case "index":
                var a = 0 === e.data.index ? 0 : e.data.index || s.index() * o.options.slidesToScroll;
                o.slideHandler(o.checkNavigable(a), !1, i), s.children().trigger("focus");
                break;
            default:
                return
        }
    }, e.prototype.checkNavigable = function(t) {
        var e, i;
        if (i = 0, t > (e = this.getNavigableIndexes())[e.length - 1]) t = e[e.length - 1];
        else
            for (var n in e) {
                if (t < e[n]) {
                    t = i;
                    break
                }
                i = e[n]
            }
        return t
    }, e.prototype.cleanUpEvents = function() {
        var e = this;
        e.options.dots && null !== e.$dots && (t("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", t.proxy(e.interrupt, e, !0)).off("mouseleave.slick", t.proxy(e.interrupt, e, !1)), !0 === e.options.accessibility && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), !0 === e.options.accessibility && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), t(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), !0 === e.options.accessibility && e.$list.off("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && t(e.$slideTrack).children().off("click.slick", e.selectHandler), t(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), t(window).off("resize.slick.slick-" + e.instanceUid, e.resize), t("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), t(window).off("load.slick.slick-" + e.instanceUid, e.setPosition)
    }, e.prototype.cleanUpSlideEvents = function() {
        var e = this;
        e.$list.off("mouseenter.slick", t.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", t.proxy(e.interrupt, e, !1))
    }, e.prototype.cleanUpRows = function() {
        var t, e = this;
        e.options.rows > 0 && ((t = e.$slides.children().children()).removeAttr("style"), e.$slider.empty().append(t))
    }, e.prototype.clickHandler = function(t) {
        !1 === this.shouldClick && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault())
    }, e.prototype.destroy = function(e) {
        var i = this;
        i.autoPlayClear(), i.touchObject = {}, i.cleanUpEvents(), t(".slick-cloned", i.$slider).detach(), i.$dots && i.$dots.remove(), i.$prevArrow && i.$prevArrow.length && (i.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), i.htmlExpr.test(i.options.prevArrow) && i.$prevArrow.remove()), i.$nextArrow && i.$nextArrow.length && (i.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), i.htmlExpr.test(i.options.nextArrow) && i.$nextArrow.remove()), i.$slides && (i.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function() {
            t(this).attr("style", t(this).data("originalStyling"))
        }), i.$slideTrack.children(this.options.slide).detach(), i.$slideTrack.detach(), i.$list.detach(), i.$slider.append(i.$slides)), i.cleanUpRows(), i.$slider.removeClass("slick-slider"), i.$slider.removeClass("slick-initialized"), i.$slider.removeClass("slick-dotted"), i.unslicked = !0, e || i.$slider.trigger("destroy", [i])
    }, e.prototype.disableTransition = function(t) {
        var e = this,
            i = {};
        i[e.transitionType] = "", !1 === e.options.fade ? e.$slideTrack.css(i) : e.$slides.eq(t).css(i)
    }, e.prototype.fadeSlide = function(t, e) {
        var i = this;
        !1 === i.cssTransitions ? (i.$slides.eq(t).css({
            zIndex: i.options.zIndex
        }), i.$slides.eq(t).animate({
            opacity: 1
        }, i.options.speed, i.options.easing, e)) : (i.applyTransition(t), i.$slides.eq(t).css({
            opacity: 1,
            zIndex: i.options.zIndex
        }), e && setTimeout(function() {
            i.disableTransition(t), e.call()
        }, i.options.speed))
    }, e.prototype.fadeSlideOut = function(t) {
        var e = this;
        !1 === e.cssTransitions ? e.$slides.eq(t).animate({
            opacity: 0,
            zIndex: e.options.zIndex - 2
        }, e.options.speed, e.options.easing) : (e.applyTransition(t), e.$slides.eq(t).css({
            opacity: 0,
            zIndex: e.options.zIndex - 2
        }))
    }, e.prototype.filterSlides = e.prototype.slickFilter = function(t) {
        var e = this;
        null !== t && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(t).appendTo(e.$slideTrack), e.reinit())
    }, e.prototype.focusHandler = function() {
        var e = this;
        e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function(i) {
            i.stopImmediatePropagation();
            var n = t(this);
            setTimeout(function() {
                e.options.pauseOnFocus && (e.focussed = n.is(":focus"), e.autoPlay())
            }, 0)
        })
    }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function() {
        return this.currentSlide
    }, e.prototype.getDotCount = function() {
        var t = this,
            e = 0,
            i = 0,
            n = 0;
        if (!0 === t.options.infinite)
            if (t.slideCount <= t.options.slidesToShow) ++n;
            else
                for (; e < t.slideCount;) ++n, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
        else if (!0 === t.options.centerMode) n = t.slideCount;
        else if (t.options.asNavFor)
            for (; e < t.slideCount;) ++n, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
        else n = 1 + Math.ceil((t.slideCount - t.options.slidesToShow) / t.options.slidesToScroll);
        return n - 1
    }, e.prototype.getLeft = function(t) {
        var e, i, n, r, o = this,
            s = 0;
        return o.slideOffset = 0, i = o.$slides.first().outerHeight(!0), !0 === o.options.infinite ? (o.slideCount > o.options.slidesToShow && (o.slideOffset = o.slideWidth * o.options.slidesToShow * -1, r = -1, !0 === o.options.vertical && !0 === o.options.centerMode && (2 === o.options.slidesToShow ? r = -1.5 : 1 === o.options.slidesToShow && (r = -2)), s = i * o.options.slidesToShow * r), o.slideCount % o.options.slidesToScroll != 0 && t + o.options.slidesToScroll > o.slideCount && o.slideCount > o.options.slidesToShow && (t > o.slideCount ? (o.slideOffset = (o.options.slidesToShow - (t - o.slideCount)) * o.slideWidth * -1, s = (o.options.slidesToShow - (t - o.slideCount)) * i * -1) : (o.slideOffset = o.slideCount % o.options.slidesToScroll * o.slideWidth * -1, s = o.slideCount % o.options.slidesToScroll * i * -1))) : t + o.options.slidesToShow > o.slideCount && (o.slideOffset = (t + o.options.slidesToShow - o.slideCount) * o.slideWidth, s = (t + o.options.slidesToShow - o.slideCount) * i), o.slideCount <= o.options.slidesToShow && (o.slideOffset = 0, s = 0), !0 === o.options.centerMode && o.slideCount <= o.options.slidesToShow ? o.slideOffset = o.slideWidth * Math.floor(o.options.slidesToShow) / 2 - o.slideWidth * o.slideCount / 2 : !0 === o.options.centerMode && !0 === o.options.infinite ? o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2) - o.slideWidth : !0 === o.options.centerMode && (o.slideOffset = 0, o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2)), e = !1 === o.options.vertical ? t * o.slideWidth * -1 + o.slideOffset : t * i * -1 + s, !0 === o.options.variableWidth && (n = o.slideCount <= o.options.slidesToShow || !1 === o.options.infinite ? o.$slideTrack.children(".slick-slide").eq(t) : o.$slideTrack.children(".slick-slide").eq(t + o.options.slidesToShow), e = !0 === o.options.rtl ? n[0] ? -1 * (o.$slideTrack.width() - n[0].offsetLeft - n.width()) : 0 : n[0] ? -1 * n[0].offsetLeft : 0, !0 === o.options.centerMode && (n = o.slideCount <= o.options.slidesToShow || !1 === o.options.infinite ? o.$slideTrack.children(".slick-slide").eq(t) : o.$slideTrack.children(".slick-slide").eq(t + o.options.slidesToShow + 1), e = !0 === o.options.rtl ? n[0] ? -1 * (o.$slideTrack.width() - n[0].offsetLeft - n.width()) : 0 : n[0] ? -1 * n[0].offsetLeft : 0, e += (o.$list.width() - n.outerWidth()) / 2)), e
    }, e.prototype.getOption = e.prototype.slickGetOption = function(t) {
        return this.options[t]
    }, e.prototype.getNavigableIndexes = function() {
        var t, e = this,
            i = 0,
            n = 0,
            r = [];
        for (!1 === e.options.infinite ? t = e.slideCount : (i = -1 * e.options.slidesToScroll, n = -1 * e.options.slidesToScroll, t = 2 * e.slideCount); i < t;) r.push(i), i = n + e.options.slidesToScroll, n += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
        return r
    }, e.prototype.getSlick = function() {
        return this
    }, e.prototype.getSlideCount = function() {
        var e, i, n = this;
        return i = !0 === n.options.centerMode ? n.slideWidth * Math.floor(n.options.slidesToShow / 2) : 0, !0 === n.options.swipeToSlide ? (n.$slideTrack.find(".slick-slide").each(function(r, o) {
            if (o.offsetLeft - i + t(o).outerWidth() / 2 > -1 * n.swipeLeft) return e = o, !1
        }), Math.abs(t(e).attr("data-slick-index") - n.currentSlide) || 1) : n.options.slidesToScroll
    }, e.prototype.goTo = e.prototype.slickGoTo = function(t, e) {
        this.changeSlide({
            data: {
                message: "index",
                index: parseInt(t)
            }
        }, e)
    }, e.prototype.init = function(e) {
        var i = this;
        t(i.$slider).hasClass("slick-initialized") || (t(i.$slider).addClass("slick-initialized"), i.buildRows(), i.buildOut(), i.setProps(), i.startLoad(), i.loadSlider(), i.initializeEvents(), i.updateArrows(), i.updateDots(), i.checkResponsive(!0), i.focusHandler()), e && i.$slider.trigger("init", [i]), !0 === i.options.accessibility && i.initADA(), i.options.autoplay && (i.paused = !1, i.autoPlay())
    }, e.prototype.initADA = function() {
        var e = this,
            i = Math.ceil(e.slideCount / e.options.slidesToShow),
            n = e.getNavigableIndexes().filter(function(t) {
                return t >= 0 && t < e.slideCount
            });
        e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
            "aria-hidden": "true",
            tabindex: "-1"
        }).find("a, input, button, select").attr({
            tabindex: "-1"
        }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function(i) {
            var r = n.indexOf(i);
            if (t(this).attr({
                    role: "tabpanel",
                    id: "slick-slide" + e.instanceUid + i,
                    tabindex: -1
                }), -1 !== r) {
                var o = "slick-slide-control" + e.instanceUid + r;
                t("#" + o).length && t(this).attr({
                    "aria-describedby": o
                })
            }
        }), e.$dots.attr("role", "tablist").find("li").each(function(r) {
            var o = n[r];
            t(this).attr({
                role: "presentation"
            }), t(this).find("button").first().attr({
                role: "tab",
                id: "slick-slide-control" + e.instanceUid + r,
                "aria-controls": "slick-slide" + e.instanceUid + o,
                "aria-label": r + 1 + " of " + i,
                "aria-selected": null,
                tabindex: "-1"
            })
        }).eq(e.currentSlide).find("button").attr({
            "aria-selected": "true",
            tabindex: "0"
        }).end());
        for (var r = e.currentSlide, o = r + e.options.slidesToShow; r < o; r++) e.options.focusOnChange ? e.$slides.eq(r).attr({
            tabindex: "0"
        }) : e.$slides.eq(r).removeAttr("tabindex");
        e.activateADA()
    }, e.prototype.initArrowEvents = function() {
        var t = this;
        !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow.off("click.slick").on("click.slick", {
            message: "previous"
        }, t.changeSlide), t.$nextArrow.off("click.slick").on("click.slick", {
            message: "next"
        }, t.changeSlide), !0 === t.options.accessibility && (t.$prevArrow.on("keydown.slick", t.keyHandler), t.$nextArrow.on("keydown.slick", t.keyHandler)))
    }, e.prototype.initDotEvents = function() {
        var e = this;
        !0 === e.options.dots && e.slideCount > e.options.slidesToShow && (t("li", e.$dots).on("click.slick", {
            message: "index"
        }, e.changeSlide), !0 === e.options.accessibility && e.$dots.on("keydown.slick", e.keyHandler)), !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && e.slideCount > e.options.slidesToShow && t("li", e.$dots).on("mouseenter.slick", t.proxy(e.interrupt, e, !0)).on("mouseleave.slick", t.proxy(e.interrupt, e, !1))
    }, e.prototype.initSlideEvents = function() {
        var e = this;
        e.options.pauseOnHover && (e.$list.on("mouseenter.slick", t.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", t.proxy(e.interrupt, e, !1)))
    }, e.prototype.initializeEvents = function() {
        var e = this;
        e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {
            action: "start"
        }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {
            action: "move"
        }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {
            action: "end"
        }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {
            action: "end"
        }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), t(document).on(e.visibilityChange, t.proxy(e.visibility, e)), !0 === e.options.accessibility && e.$list.on("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && t(e.$slideTrack).children().on("click.slick", e.selectHandler), t(window).on("orientationchange.slick.slick-" + e.instanceUid, t.proxy(e.orientationChange, e)), t(window).on("resize.slick.slick-" + e.instanceUid, t.proxy(e.resize, e)), t("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), t(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), t(e.setPosition)
    }, e.prototype.initUI = function() {
        var t = this;
        !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow.show(), t.$nextArrow.show()), !0 === t.options.dots && t.slideCount > t.options.slidesToShow && t.$dots.show()
    }, e.prototype.keyHandler = function(t) {
        var e = this;
        t.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === t.keyCode && !0 === e.options.accessibility ? e.changeSlide({
            data: {
                message: !0 === e.options.rtl ? "next" : "previous"
            }
        }) : 39 === t.keyCode && !0 === e.options.accessibility && e.changeSlide({
            data: {
                message: !0 === e.options.rtl ? "previous" : "next"
            }
        }))
    }, e.prototype.lazyLoad = function() {
        var e, i, n, r = this;

        function o(e) {
            t("img[data-lazy]", e).each(function() {
                var e = t(this),
                    i = t(this).attr("data-lazy"),
                    n = t(this).attr("data-srcset"),
                    o = t(this).attr("data-sizes") || r.$slider.attr("data-sizes"),
                    s = document.createElement("img");
                s.onload = function() {
                    e.animate({
                        opacity: 0
                    }, 100, function() {
                        n && (e.attr("srcset", n), o && e.attr("sizes", o)), e.attr("src", i).animate({
                            opacity: 1
                        }, 200, function() {
                            e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                        }), r.$slider.trigger("lazyLoaded", [r, e, i])
                    })
                }, s.onerror = function() {
                    e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), r.$slider.trigger("lazyLoadError", [r, e, i])
                }, s.src = i
            })
        }
        if (!0 === r.options.centerMode ? !0 === r.options.infinite ? n = (i = r.currentSlide + (r.options.slidesToShow / 2 + 1)) + r.options.slidesToShow + 2 : (i = Math.max(0, r.currentSlide - (r.options.slidesToShow / 2 + 1)), n = r.options.slidesToShow / 2 + 1 + 2 + r.currentSlide) : (i = r.options.infinite ? r.options.slidesToShow + r.currentSlide : r.currentSlide, n = Math.ceil(i + r.options.slidesToShow), !0 === r.options.fade && (i > 0 && i--, n <= r.slideCount && n++)), e = r.$slider.find(".slick-slide").slice(i, n), "anticipated" === r.options.lazyLoad)
            for (var s = i - 1, a = n, l = r.$slider.find(".slick-slide"), c = 0; c < r.options.slidesToScroll; c++) s < 0 && (s = r.slideCount - 1), e = (e = e.add(l.eq(s))).add(l.eq(a)), s--, a++;
        o(e), r.slideCount <= r.options.slidesToShow ? o(r.$slider.find(".slick-slide")) : r.currentSlide >= r.slideCount - r.options.slidesToShow ? o(r.$slider.find(".slick-cloned").slice(0, r.options.slidesToShow)) : 0 === r.currentSlide && o(r.$slider.find(".slick-cloned").slice(-1 * r.options.slidesToShow))
    }, e.prototype.loadSlider = function() {
        var t = this;
        t.setPosition(), t.$slideTrack.css({
            opacity: 1
        }), t.$slider.removeClass("slick-loading"), t.initUI(), "progressive" === t.options.lazyLoad && t.progressiveLazyLoad()
    }, e.prototype.next = e.prototype.slickNext = function() {
        this.changeSlide({
            data: {
                message: "next"
            }
        })
    }, e.prototype.orientationChange = function() {
        this.checkResponsive(), this.setPosition()
    }, e.prototype.pause = e.prototype.slickPause = function() {
        this.autoPlayClear(), this.paused = !0
    }, e.prototype.play = e.prototype.slickPlay = function() {
        var t = this;
        t.autoPlay(), t.options.autoplay = !0, t.paused = !1, t.focussed = !1, t.interrupted = !1
    }, e.prototype.postSlide = function(e) {
        var i = this;
        i.unslicked || (i.$slider.trigger("afterChange", [i, e]), i.animating = !1, i.slideCount > i.options.slidesToShow && i.setPosition(), i.swipeLeft = null, i.options.autoplay && i.autoPlay(), !0 === i.options.accessibility && (i.initADA(), i.options.focusOnChange && t(i.$slides.get(i.currentSlide)).attr("tabindex", 0).focus()))
    }, e.prototype.prev = e.prototype.slickPrev = function() {
        this.changeSlide({
            data: {
                message: "previous"
            }
        })
    }, e.prototype.preventDefault = function(t) {
        t.preventDefault()
    }, e.prototype.progressiveLazyLoad = function(e) {
        e = e || 1;
        var i, n, r, o, s, a = this,
            l = t("img[data-lazy]", a.$slider);
        l.length ? (i = l.first(), n = i.attr("data-lazy"), r = i.attr("data-srcset"), o = i.attr("data-sizes") || a.$slider.attr("data-sizes"), (s = document.createElement("img")).onload = function() {
            r && (i.attr("srcset", r), o && i.attr("sizes", o)), i.attr("src", n).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === a.options.adaptiveHeight && a.setPosition(), a.$slider.trigger("lazyLoaded", [a, i, n]), a.progressiveLazyLoad()
        }, s.onerror = function() {
            e < 3 ? setTimeout(function() {
                a.progressiveLazyLoad(e + 1)
            }, 500) : (i.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), a.$slider.trigger("lazyLoadError", [a, i, n]), a.progressiveLazyLoad())
        }, s.src = n) : a.$slider.trigger("allImagesLoaded", [a])
    }, e.prototype.refresh = function(e) {
        var i, n, r = this;
        n = r.slideCount - r.options.slidesToShow, !r.options.infinite && r.currentSlide > n && (r.currentSlide = n), r.slideCount <= r.options.slidesToShow && (r.currentSlide = 0), i = r.currentSlide, r.destroy(!0), t.extend(r, r.initials, {
            currentSlide: i
        }), r.init(), e || r.changeSlide({
            data: {
                message: "index",
                index: i
            }
        }, !1)
    }, e.prototype.registerBreakpoints = function() {
        var e, i, n, r = this,
            o = r.options.responsive || null;
        if ("array" === t.type(o) && o.length) {
            for (e in r.respondTo = r.options.respondTo || "window", o)
                if (n = r.breakpoints.length - 1, o.hasOwnProperty(e)) {
                    for (i = o[e].breakpoint; n >= 0;) r.breakpoints[n] && r.breakpoints[n] === i && r.breakpoints.splice(n, 1), n--;
                    r.breakpoints.push(i), r.breakpointSettings[i] = o[e].settings
                } r.breakpoints.sort(function(t, e) {
                return r.options.mobileFirst ? t - e : e - t
            })
        }
    }, e.prototype.reinit = function() {
        var e = this;
        e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), !0 === e.options.focusOnSelect && t(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e])
    }, e.prototype.resize = function() {
        var e = this;
        t(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function() {
            e.windowWidth = t(window).width(), e.checkResponsive(), e.unslicked || e.setPosition()
        }, 50))
    }, e.prototype.removeSlide = e.prototype.slickRemove = function(t, e, i) {
        var n = this;
        if (t = "boolean" == typeof t ? !0 === (e = t) ? 0 : n.slideCount - 1 : !0 === e ? --t : t, n.slideCount < 1 || t < 0 || t > n.slideCount - 1) return !1;
        n.unload(), !0 === i ? n.$slideTrack.children().remove() : n.$slideTrack.children(this.options.slide).eq(t).remove(), n.$slides = n.$slideTrack.children(this.options.slide), n.$slideTrack.children(this.options.slide).detach(), n.$slideTrack.append(n.$slides), n.$slidesCache = n.$slides, n.reinit()
    }, e.prototype.setCSS = function(t) {
        var e, i, n = this,
            r = {};
        !0 === n.options.rtl && (t = -t), e = "left" == n.positionProp ? Math.ceil(t) + "px" : "0px", i = "top" == n.positionProp ? Math.ceil(t) + "px" : "0px", r[n.positionProp] = t, !1 === n.transformsEnabled ? n.$slideTrack.css(r) : (r = {}, !1 === n.cssTransitions ? (r[n.animType] = "translate(" + e + ", " + i + ")", n.$slideTrack.css(r)) : (r[n.animType] = "translate3d(" + e + ", " + i + ", 0px)", n.$slideTrack.css(r)))
    }, e.prototype.setDimensions = function() {
        var t = this;
        !1 === t.options.vertical ? !0 === t.options.centerMode && t.$list.css({
            padding: "0px " + t.options.centerPadding
        }) : (t.$list.height(t.$slides.first().outerHeight(!0) * t.options.slidesToShow), !0 === t.options.centerMode && t.$list.css({
            padding: t.options.centerPadding + " 0px"
        })), t.listWidth = t.$list.width(), t.listHeight = t.$list.height(), !1 === t.options.vertical && !1 === t.options.variableWidth ? (t.slideWidth = Math.ceil(t.listWidth / t.options.slidesToShow), t.$slideTrack.width(Math.ceil(t.slideWidth * t.$slideTrack.children(".slick-slide").length))) : !0 === t.options.variableWidth ? t.$slideTrack.width(5e3 * t.slideCount) : (t.slideWidth = Math.ceil(t.listWidth), t.$slideTrack.height(Math.ceil(t.$slides.first().outerHeight(!0) * t.$slideTrack.children(".slick-slide").length)));
        var e = t.$slides.first().outerWidth(!0) - t.$slides.first().width();
        !1 === t.options.variableWidth && t.$slideTrack.children(".slick-slide").width(t.slideWidth - e)
    }, e.prototype.setFade = function() {
        var e, i = this;
        i.$slides.each(function(n, r) {
            e = i.slideWidth * n * -1, !0 === i.options.rtl ? t(r).css({
                position: "relative",
                right: e,
                top: 0,
                zIndex: i.options.zIndex - 2,
                opacity: 0
            }) : t(r).css({
                position: "relative",
                left: e,
                top: 0,
                zIndex: i.options.zIndex - 2,
                opacity: 0
            })
        }), i.$slides.eq(i.currentSlide).css({
            zIndex: i.options.zIndex - 1,
            opacity: 1
        })
    }, e.prototype.setHeight = function() {
        var t = this;
        if (1 === t.options.slidesToShow && !0 === t.options.adaptiveHeight && !1 === t.options.vertical) {
            var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
            t.$list.css("height", e)
        }
    }, e.prototype.setOption = e.prototype.slickSetOption = function() {
        var e, i, n, r, o, s = this,
            a = !1;
        if ("object" === t.type(arguments[0]) ? (n = arguments[0], a = arguments[1], o = "multiple") : "string" === t.type(arguments[0]) && (n = arguments[0], r = arguments[1], a = arguments[2], "responsive" === arguments[0] && "array" === t.type(arguments[1]) ? o = "responsive" : void 0 !== arguments[1] && (o = "single")), "single" === o) s.options[n] = r;
        else if ("multiple" === o) t.each(n, function(t, e) {
            s.options[t] = e
        });
        else if ("responsive" === o)
            for (i in r)
                if ("array" !== t.type(s.options.responsive)) s.options.responsive = [r[i]];
                else {
                    for (e = s.options.responsive.length - 1; e >= 0;) s.options.responsive[e].breakpoint === r[i].breakpoint && s.options.responsive.splice(e, 1), e--;
                    s.options.responsive.push(r[i])
                } a && (s.unload(), s.reinit())
    }, e.prototype.setPosition = function() {
        var t = this;
        t.setDimensions(), t.setHeight(), !1 === t.options.fade ? t.setCSS(t.getLeft(t.currentSlide)) : t.setFade(), t.$slider.trigger("setPosition", [t])
    }, e.prototype.setProps = function() {
        var t = this,
            e = document.body.style;
        t.positionProp = !0 === t.options.vertical ? "top" : "left", "top" === t.positionProp ? t.$slider.addClass("slick-vertical") : t.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === t.options.useCSS && (t.cssTransitions = !0), t.options.fade && ("number" == typeof t.options.zIndex ? t.options.zIndex < 3 && (t.options.zIndex = 3) : t.options.zIndex = t.defaults.zIndex), void 0 !== e.OTransform && (t.animType = "OTransform", t.transformType = "-o-transform", t.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.MozTransform && (t.animType = "MozTransform", t.transformType = "-moz-transform", t.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (t.animType = !1)), void 0 !== e.webkitTransform && (t.animType = "webkitTransform", t.transformType = "-webkit-transform", t.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.msTransform && (t.animType = "msTransform", t.transformType = "-ms-transform", t.transitionType = "msTransition", void 0 === e.msTransform && (t.animType = !1)), void 0 !== e.transform && !1 !== t.animType && (t.animType = "transform", t.transformType = "transform", t.transitionType = "transition"), t.transformsEnabled = t.options.useTransform && null !== t.animType && !1 !== t.animType
    }, e.prototype.setSlideClasses = function(t) {
        var e, i, n, r, o = this;
        if (i = o.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), o.$slides.eq(t).addClass("slick-current"), !0 === o.options.centerMode) {
            var s = o.options.slidesToShow % 2 == 0 ? 1 : 0;
            e = Math.floor(o.options.slidesToShow / 2), !0 === o.options.infinite && (t >= e && t <= o.slideCount - 1 - e ? o.$slides.slice(t - e + s, t + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (n = o.options.slidesToShow + t, i.slice(n - e + 1 + s, n + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === t ? i.eq(i.length - 1 - o.options.slidesToShow).addClass("slick-center") : t === o.slideCount - 1 && i.eq(o.options.slidesToShow).addClass("slick-center")), o.$slides.eq(t).addClass("slick-center")
        } else t >= 0 && t <= o.slideCount - o.options.slidesToShow ? o.$slides.slice(t, t + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : i.length <= o.options.slidesToShow ? i.addClass("slick-active").attr("aria-hidden", "false") : (r = o.slideCount % o.options.slidesToShow, n = !0 === o.options.infinite ? o.options.slidesToShow + t : t, o.options.slidesToShow == o.options.slidesToScroll && o.slideCount - t < o.options.slidesToShow ? i.slice(n - (o.options.slidesToShow - r), n + r).addClass("slick-active").attr("aria-hidden", "false") : i.slice(n, n + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
        "ondemand" !== o.options.lazyLoad && "anticipated" !== o.options.lazyLoad || o.lazyLoad()
    }, e.prototype.setupInfinite = function() {
        var e, i, n, r = this;
        if (!0 === r.options.fade && (r.options.centerMode = !1), !0 === r.options.infinite && !1 === r.options.fade && (i = null, r.slideCount > r.options.slidesToShow)) {
            for (n = !0 === r.options.centerMode ? r.options.slidesToShow + 1 : r.options.slidesToShow, e = r.slideCount; e > r.slideCount - n; e -= 1) i = e - 1, t(r.$slides[i]).clone(!0).attr("id", "").attr("data-slick-index", i - r.slideCount).prependTo(r.$slideTrack).addClass("slick-cloned");
            for (e = 0; e < n + r.slideCount; e += 1) i = e, t(r.$slides[i]).clone(!0).attr("id", "").attr("data-slick-index", i + r.slideCount).appendTo(r.$slideTrack).addClass("slick-cloned");
            r.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                t(this).attr("id", "")
            })
        }
    }, e.prototype.interrupt = function(t) {
        t || this.autoPlay(), this.interrupted = t
    }, e.prototype.selectHandler = function(e) {
        var i = this,
            n = t(e.target).is(".slick-slide") ? t(e.target) : t(e.target).parents(".slick-slide"),
            r = parseInt(n.attr("data-slick-index"));
        r || (r = 0), i.slideCount <= i.options.slidesToShow ? i.slideHandler(r, !1, !0) : i.slideHandler(r)
    }, e.prototype.slideHandler = function(t, e, i) {
        var n, r, o, s, a, l, c = this;
        if (e = e || !1, !(!0 === c.animating && !0 === c.options.waitForAnimate || !0 === c.options.fade && c.currentSlide === t))
            if (!1 === e && c.asNavFor(t), n = t, a = c.getLeft(n), s = c.getLeft(c.currentSlide), c.currentLeft = null === c.swipeLeft ? s : c.swipeLeft, !1 === c.options.infinite && !1 === c.options.centerMode && (t < 0 || t > c.getDotCount() * c.options.slidesToScroll)) !1 === c.options.fade && (n = c.currentSlide, !0 !== i && c.slideCount > c.options.slidesToShow ? c.animateSlide(s, function() {
                c.postSlide(n)
            }) : c.postSlide(n));
            else if (!1 === c.options.infinite && !0 === c.options.centerMode && (t < 0 || t > c.slideCount - c.options.slidesToScroll)) !1 === c.options.fade && (n = c.currentSlide, !0 !== i && c.slideCount > c.options.slidesToShow ? c.animateSlide(s, function() {
            c.postSlide(n)
        }) : c.postSlide(n));
        else {
            if (c.options.autoplay && clearInterval(c.autoPlayTimer), r = n < 0 ? c.slideCount % c.options.slidesToScroll != 0 ? c.slideCount - c.slideCount % c.options.slidesToScroll : c.slideCount + n : n >= c.slideCount ? c.slideCount % c.options.slidesToScroll != 0 ? 0 : n - c.slideCount : n, c.animating = !0, c.$slider.trigger("beforeChange", [c, c.currentSlide, r]), o = c.currentSlide, c.currentSlide = r, c.setSlideClasses(c.currentSlide), c.options.asNavFor && (l = (l = c.getNavTarget()).slick("getSlick")).slideCount <= l.options.slidesToShow && l.setSlideClasses(c.currentSlide), c.updateDots(), c.updateArrows(), !0 === c.options.fade) return !0 !== i ? (c.fadeSlideOut(o), c.fadeSlide(r, function() {
                c.postSlide(r)
            })) : c.postSlide(r), void c.animateHeight();
            !0 !== i && c.slideCount > c.options.slidesToShow ? c.animateSlide(a, function() {
                c.postSlide(r)
            }) : c.postSlide(r)
        }
    }, e.prototype.startLoad = function() {
        var t = this;
        !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow.hide(), t.$nextArrow.hide()), !0 === t.options.dots && t.slideCount > t.options.slidesToShow && t.$dots.hide(), t.$slider.addClass("slick-loading")
    }, e.prototype.swipeDirection = function() {
        var t, e, i, n, r = this;
        return t = r.touchObject.startX - r.touchObject.curX, e = r.touchObject.startY - r.touchObject.curY, i = Math.atan2(e, t), (n = Math.round(180 * i / Math.PI)) < 0 && (n = 360 - Math.abs(n)), n <= 45 && n >= 0 ? !1 === r.options.rtl ? "left" : "right" : n <= 360 && n >= 315 ? !1 === r.options.rtl ? "left" : "right" : n >= 135 && n <= 225 ? !1 === r.options.rtl ? "right" : "left" : !0 === r.options.verticalSwiping ? n >= 35 && n <= 135 ? "down" : "up" : "vertical"
    }, e.prototype.swipeEnd = function(t) {
        var e, i, n = this;
        if (n.dragging = !1, n.swiping = !1, n.scrolling) return n.scrolling = !1, !1;
        if (n.interrupted = !1, n.shouldClick = !(n.touchObject.swipeLength > 10), void 0 === n.touchObject.curX) return !1;
        if (!0 === n.touchObject.edgeHit && n.$slider.trigger("edge", [n, n.swipeDirection()]), n.touchObject.swipeLength >= n.touchObject.minSwipe) {
            switch (i = n.swipeDirection()) {
                case "left":
                case "down":
                    e = n.options.swipeToSlide ? n.checkNavigable(n.currentSlide + n.getSlideCount()) : n.currentSlide + n.getSlideCount(), n.currentDirection = 0;
                    break;
                case "right":
                case "up":
                    e = n.options.swipeToSlide ? n.checkNavigable(n.currentSlide - n.getSlideCount()) : n.currentSlide - n.getSlideCount(), n.currentDirection = 1
            }
            "vertical" != i && (n.slideHandler(e), n.touchObject = {}, n.$slider.trigger("swipe", [n, i]))
        } else n.touchObject.startX !== n.touchObject.curX && (n.slideHandler(n.currentSlide), n.touchObject = {})
    }, e.prototype.swipeHandler = function(t) {
        var e = this;
        if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== t.type.indexOf("mouse"))) switch (e.touchObject.fingerCount = t.originalEvent && void 0 !== t.originalEvent.touches ? t.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), t.data.action) {
            case "start":
                e.swipeStart(t);
                break;
            case "move":
                e.swipeMove(t);
                break;
            case "end":
                e.swipeEnd(t)
        }
    }, e.prototype.swipeMove = function(t) {
        var e, i, n, r, o, s, a = this;
        return o = void 0 !== t.originalEvent ? t.originalEvent.touches : null, !(!a.dragging || a.scrolling || o && 1 !== o.length) && (e = a.getLeft(a.currentSlide), a.touchObject.curX = void 0 !== o ? o[0].pageX : t.clientX, a.touchObject.curY = void 0 !== o ? o[0].pageY : t.clientY, a.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(a.touchObject.curX - a.touchObject.startX, 2))), s = Math.round(Math.sqrt(Math.pow(a.touchObject.curY - a.touchObject.startY, 2))), !a.options.verticalSwiping && !a.swiping && s > 4 ? (a.scrolling = !0, !1) : (!0 === a.options.verticalSwiping && (a.touchObject.swipeLength = s), i = a.swipeDirection(), void 0 !== t.originalEvent && a.touchObject.swipeLength > 4 && (a.swiping = !0, t.preventDefault()), r = (!1 === a.options.rtl ? 1 : -1) * (a.touchObject.curX > a.touchObject.startX ? 1 : -1), !0 === a.options.verticalSwiping && (r = a.touchObject.curY > a.touchObject.startY ? 1 : -1), n = a.touchObject.swipeLength, a.touchObject.edgeHit = !1, !1 === a.options.infinite && (0 === a.currentSlide && "right" === i || a.currentSlide >= a.getDotCount() && "left" === i) && (n = a.touchObject.swipeLength * a.options.edgeFriction, a.touchObject.edgeHit = !0), !1 === a.options.vertical ? a.swipeLeft = e + n * r : a.swipeLeft = e + n * (a.$list.height() / a.listWidth) * r, !0 === a.options.verticalSwiping && (a.swipeLeft = e + n * r), !0 !== a.options.fade && !1 !== a.options.touchMove && (!0 === a.animating ? (a.swipeLeft = null, !1) : void a.setCSS(a.swipeLeft))))
    }, e.prototype.swipeStart = function(t) {
        var e, i = this;
        if (i.interrupted = !0, 1 !== i.touchObject.fingerCount || i.slideCount <= i.options.slidesToShow) return i.touchObject = {}, !1;
        void 0 !== t.originalEvent && void 0 !== t.originalEvent.touches && (e = t.originalEvent.touches[0]), i.touchObject.startX = i.touchObject.curX = void 0 !== e ? e.pageX : t.clientX, i.touchObject.startY = i.touchObject.curY = void 0 !== e ? e.pageY : t.clientY, i.dragging = !0
    }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function() {
        var t = this;
        null !== t.$slidesCache && (t.unload(), t.$slideTrack.children(this.options.slide).detach(), t.$slidesCache.appendTo(t.$slideTrack), t.reinit())
    }, e.prototype.unload = function() {
        var e = this;
        t(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
    }, e.prototype.unslick = function(t) {
        var e = this;
        e.$slider.trigger("unslick", [e, t]), e.destroy()
    }, e.prototype.updateArrows = function() {
        var t = this;
        Math.floor(t.options.slidesToShow / 2), !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && !t.options.infinite && (t.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), t.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === t.currentSlide ? (t.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), t.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : t.currentSlide >= t.slideCount - t.options.slidesToShow && !1 === t.options.centerMode ? (t.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), t.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : t.currentSlide >= t.slideCount - 1 && !0 === t.options.centerMode && (t.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), t.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
    }, e.prototype.updateDots = function() {
        var t = this;
        null !== t.$dots && (t.$dots.find("li").removeClass("slick-active").end(), t.$dots.find("li").eq(Math.floor(t.currentSlide / t.options.slidesToScroll)).addClass("slick-active"))
    }, e.prototype.visibility = function() {
        var t = this;
        t.options.autoplay && (document[t.hidden] ? t.interrupted = !0 : t.interrupted = !1)
    }, t.fn.slick = function() {
        var t, i, n = this,
            r = arguments[0],
            o = Array.prototype.slice.call(arguments, 1),
            s = n.length;
        for (t = 0; t < s; t++)
            if ("object" == typeof r || void 0 === r ? n[t].slick = new e(n[t], r) : i = n[t].slick[r].apply(n[t].slick, o), void 0 !== i) return i;
        return n
    }
}),
function() {
    var t, e;
    t = this.jQuery || window.jQuery, e = t(window), t.fn.stick_in_parent = function(i) {
        var n, r, o, s, a, l, c, h, u, d, p;
        for (null == i && (i = {}), p = i.sticky_class, a = i.inner_scrolling, d = i.recalc_every, u = i.parent, h = i.offset_top, c = i.spacer, r = i.bottoming, null == h && (h = 0), null == u && (u = void 0), null == a && (a = !0), null == p && (p = "is_stuck"), n = t(document), null == r && (r = !0), o = function(i, o, s, l, f, m, g, v) {
                var y, _, x, w, b, T, S, M, E, A, P, C;
                if (!i.data("sticky_kit")) {
                    if (i.data("sticky_kit", !0), b = n.height(), S = i.parent(), null != u && (S = S.closest(u)), !S.length) throw "failed to find stick parent";
                    if (y = x = !1, (P = null != c ? c && i.closest(c) : t("<div />")) && P.css("position", i.css("position")), (M = function() {
                            var t, e, r;
                            if (!v && (b = n.height(), t = parseInt(S.css("border-top-width"), 10), e = parseInt(S.css("padding-top"), 10), o = parseInt(S.css("padding-bottom"), 10), s = S.offset().top + t + e, l = S.height(), x && (y = x = !1, null == c && (i.insertAfter(P), P.detach()), i.css({
                                    position: "",
                                    top: "",
                                    width: "",
                                    bottom: ""
                                }).removeClass(p), r = !0), f = i.offset().top - (parseInt(i.css("margin-top"), 10) || 0) - h, m = i.outerHeight(!0), g = i.css("float"), P && P.css({
                                    width: i.outerWidth(!0),
                                    height: m,
                                    display: i.css("display"),
                                    "vertical-align": i.css("vertical-align"),
                                    float: g
                                }), r)) return C()
                        })(), m !== l) return w = void 0, T = h, A = d, C = function() {
                        var t, u, _, E;
                        if (!v && (_ = !1, null != A && (0 >= --A && (A = d, M(), _ = !0)), _ || n.height() === b || M(), _ = e.scrollTop(), null != w && (u = _ - w), w = _, x ? (r && (E = _ + m + T > l + s, y && !E && (y = !1, i.css({
                                position: "fixed",
                                bottom: "",
                                top: T
                            }).trigger("sticky_kit:unbottom"))), _ < f && (x = !1, T = h, null == c && ("left" !== g && "right" !== g || i.insertAfter(P), P.detach()), t = {
                                position: "",
                                width: "",
                                top: ""
                            }, i.css(t).removeClass(p).trigger("sticky_kit:unstick")), a && (t = e.height(), m + h > t && !y && (T -= u, T = Math.max(t - m, T), T = Math.min(h, T), x && i.css({
                                top: T + "px"
                            })))) : _ > f && (x = !0, (t = {
                                position: "fixed",
                                top: T
                            }).width = "border-box" === i.css("box-sizing") ? i.outerWidth() + "px" : i.width() + "px", i.css(t).addClass(p), null == c && (i.after(P), "left" !== g && "right" !== g || P.append(i)), i.trigger("sticky_kit:stick")), x && r && (null == E && (E = _ + m + T > l + s), !y && E))) return y = !0, "static" === S.css("position") && S.css({
                            position: "relative"
                        }), i.css({
                            position: "absolute",
                            bottom: o,
                            top: "auto"
                        }).trigger("sticky_kit:bottom")
                    }, E = function() {
                        return M(), C()
                    }, _ = function() {
                        if (v = !0, e.off("touchmove", C), e.off("scroll", C), e.off("resize", E), t(document.body).off("sticky_kit:recalc", E), i.off("sticky_kit:detach", _), i.removeData("sticky_kit"), i.css({
                                position: "",
                                bottom: "",
                                top: "",
                                width: ""
                            }), S.position("position", ""), x) return null == c && ("left" !== g && "right" !== g || i.insertAfter(P), P.remove()), i.removeClass(p)
                    }, e.on("touchmove", C), e.on("scroll", C), e.on("resize", E), t(document.body).on("sticky_kit:recalc", E), i.on("sticky_kit:detach", _), setTimeout(C, 0)
                }
            }, s = 0, l = this.length; s < l; s++) i = this[s], o(t(i));
        return this
    }
}.call(this),
    function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).THREE = {})
    }(this, function(t) {
        function e() {}

        function i(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function n(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
        }

        function r(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function o() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function s(t, e, n, r, a, l, c, h, u, d) {
            Object.defineProperty(this, "id", {
                value: Do++
            }), this.uuid = Po.generateUUID(), this.name = "", this.image = void 0 !== t ? t : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== a ? a : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null
        }

        function a(t, e, i, n) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
        }

        function l(t, e, i) {
            this.width = t, this.height = e, this.scissor = new a(0, 0, t, e), this.scissorTest = !1, this.viewport = new a(0, 0, t, e), i = i || {}, this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function c(t, e, i) {
            l.call(this, t, e, i), this.samples = 4
        }

        function h() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function u(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || u.DefaultOrder
        }

        function d() {
            this.mask = 1
        }

        function p() {
            Object.defineProperty(this, "id", {
                value: Vo++
            }), this.uuid = Po.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = p.DefaultUp.clone();
            var t = new r,
                e = new u,
                i = new n,
                s = new r(1, 1, 1);
            e._onChange(function() {
                i.setFromEuler(e, !1)
            }), i._onChange(function() {
                e.setFromQuaternion(i, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: s
                },
                modelViewMatrix: {
                    value: new h
                },
                normalMatrix: {
                    value: new o
                }
            }), this.matrix = new h, this.matrixWorld = new h, this.matrixAutoUpdate = p.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new d, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
        }

        function f() {
            p.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function m(t, e) {
            this.min = void 0 !== t ? t : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new r(-1 / 0, -1 / 0, -1 / 0)
        }

        function g(t, e, i, n, r) {
            var o, s = 0;
            for (o = t.length - 3; s <= o; s += 3) {
                fs.fromArray(t, s);
                var a = r.x * Math.abs(fs.x) + r.y * Math.abs(fs.y) + r.z * Math.abs(fs.z),
                    l = e.dot(fs),
                    c = i.dot(fs),
                    h = n.dot(fs);
                if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1
            }
            return !0
        }

        function v(t, e) {
            this.center = void 0 !== t ? t : new r, this.radius = void 0 !== e ? e : 0
        }

        function y(t, e) {
            this.origin = void 0 !== t ? t : new r, this.direction = void 0 !== e ? e : new r
        }

        function _(t, e, i) {
            this.a = void 0 !== t ? t : new r, this.b = void 0 !== e ? e : new r, this.c = void 0 !== i ? i : new r
        }

        function x(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        function w(t, e, i) {
            return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : .5 > i ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
        }

        function b(t) {
            return .04045 > t ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
        }

        function T(t) {
            return .0031308 > t ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
        }

        function S(t, e, i, n, o, s) {
            this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new x, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== s ? s : 0
        }

        function M() {
            Object.defineProperty(this, "id", {
                value: Ns++
            }), this.uuid = Po.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilZPass = this.stencilZFail = this.stencilFail = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.toneMapped = this.visible = !0, this.userData = {}, this.needsUpdate = !0
        }

        function E(t) {
            M.call(this), this.type = "MeshBasicMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function A(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function P(t, e, i) {
            A.call(this, new Int8Array(t), e, i)
        }

        function C(t, e, i) {
            A.call(this, new Uint8Array(t), e, i)
        }

        function R(t, e, i) {
            A.call(this, new Uint8ClampedArray(t), e, i)
        }

        function L(t, e, i) {
            A.call(this, new Int16Array(t), e, i)
        }

        function O(t, e, i) {
            A.call(this, new Uint16Array(t), e, i)
        }

        function k(t, e, i) {
            A.call(this, new Int32Array(t), e, i)
        }

        function D(t, e, i) {
            A.call(this, new Uint32Array(t), e, i)
        }

        function I(t, e, i) {
            A.call(this, new Float32Array(t), e, i)
        }

        function N(t, e, i) {
            A.call(this, new Float64Array(t), e, i)
        }

        function z() {
            this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
        }

        function F(t) {
            if (0 === t.length) return -1 / 0;
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }

        function B() {
            Object.defineProperty(this, "id", {
                value: zs += 2
            }), this.uuid = Po.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }

        function H(t, e) {
            p.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new B, this.material = void 0 !== e ? e : new E({
                color: 16777215 * Math.random()
            }), this.drawMode = 0, this.updateMorphTargets()
        }

        function U(t, e, i, n, r, o, s, a) {
            return null === (1 === e.side ? n.intersectTriangle(s, o, r, !0, a) : n.intersectTriangle(r, o, s, 2 !== e.side, a)) ? null : (sa.copy(a), sa.applyMatrix4(t.matrixWorld), (e = i.ray.origin.distanceTo(sa)) < i.near || e > i.far ? null : {
                distance: e,
                point: sa.clone(),
                object: t
            })
        }

        function G(t, e, n, r, o, s, a, l, c, h, u) {
            if (Xs.fromBufferAttribute(o, c), $s.fromBufferAttribute(o, h), Ys.fromBufferAttribute(o, u), o = t.morphTargetInfluences, e.morphTargets && s && o) {
                Ks.set(0, 0, 0), ta.set(0, 0, 0), ea.set(0, 0, 0);
                for (var d = 0, p = s.length; d < p; d++) {
                    var f = o[d],
                        m = s[d];
                    0 !== f && (Zs.fromBufferAttribute(m, c), Js.fromBufferAttribute(m, h), Qs.fromBufferAttribute(m, u), Ks.addScaledVector(Zs.sub(Xs), f), ta.addScaledVector(Js.sub($s), f), ea.addScaledVector(Qs.sub(Ys), f))
                }
                Xs.add(Ks), $s.add(ta), Ys.add(ea)
            }
            return (t = U(t, e, n, r, Xs, $s, Ys, oa)) && (a && (ia.fromBufferAttribute(a, c), na.fromBufferAttribute(a, h), ra.fromBufferAttribute(a, u), t.uv = _.getUV(oa, Xs, $s, Ys, ia, na, ra, new i)), l && (ia.fromBufferAttribute(l, c), na.fromBufferAttribute(l, h), ra.fromBufferAttribute(l, u), t.uv2 = _.getUV(oa, Xs, $s, Ys, ia, na, ra, new i)), a = new S(c, h, u), _.getNormal(Xs, $s, Ys, a.normal), t.face = a), t
        }

        function j() {
            Object.defineProperty(this, "id", {
                value: aa += 2
            }), this.uuid = Po.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
        }

        function V(t) {
            var e, i = {};
            for (e in t)
                for (var n in i[e] = {}, t[e]) {
                    var r = t[e][n];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[e][n] = r.clone() : Array.isArray(r) ? i[e][n] = r.slice() : i[e][n] = r
                }
            return i
        }

        function W(t) {
            for (var e = {}, i = 0; i < t.length; i++) {
                var n, r = V(t[i]);
                for (n in r) e[n] = r[n]
            }
            return e
        }

        function q(t) {
            M.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function X() {
            p.call(this), this.type = "Camera", this.matrixWorldInverse = new h, this.projectionMatrix = new h, this.projectionMatrixInverse = new h
        }

        function $(t, e, i, n) {
            X.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function Y(t, e, i, n) {
            p.call(this), this.type = "CubeCamera";
            var o = new $(90, 1, t, e);
            o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o);
            var s = new $(90, 1, t, e);
            s.up.set(0, -1, 0), s.lookAt(new r(-1, 0, 0)), this.add(s);
            var a = new $(90, 1, t, e);
            a.up.set(0, 0, 1), a.lookAt(new r(0, 1, 0)), this.add(a);
            var l = new $(90, 1, t, e);
            l.up.set(0, 0, -1), l.lookAt(new r(0, -1, 0)), this.add(l);
            var c = new $(90, 1, t, e);
            c.up.set(0, -1, 0), c.lookAt(new r(0, 0, 1)), this.add(c);
            var h = new $(90, 1, t, e);
            h.up.set(0, -1, 0), h.lookAt(new r(0, 0, -1)), this.add(h), n = n || {
                format: 1022,
                magFilter: 1006,
                minFilter: 1006
            }, this.renderTarget = new Z(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = t.getRenderTarget(),
                    n = this.renderTarget,
                    r = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, o), t.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, a), t.setRenderTarget(n, 3), t.render(e, l), t.setRenderTarget(n, 4), t.render(e, c), n.texture.generateMipmaps = r, t.setRenderTarget(n, 5), t.render(e, h), t.setRenderTarget(i)
            }, this.clear = function(t, e, i, n) {
                for (var r = t.getRenderTarget(), o = this.renderTarget, s = 0; 6 > s; s++) t.setRenderTarget(o, s), t.clear(e, i, n);
                t.setRenderTarget(r)
            }
        }

        function Z(t, e, i) {
            l.call(this, t, e, i)
        }

        function J(t, e, i, n, r, o, a, l, c, h, u, d) {
            s.call(this, null, o, a, l, c, h, n, r, u, d), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1
            }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1, this.needsUpdate = !0
        }

        function Q(t, e) {
            this.normal = void 0 !== t ? t : new r(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function K(t, e, i, n, r, o) {
            this.planes = [void 0 !== t ? t : new Q, void 0 !== e ? e : new Q, void 0 !== i ? i : new Q, void 0 !== n ? n : new Q, void 0 !== r ? r : new Q, void 0 !== o ? o : new Q]
        }

        function tt() {
            function t(r, o) {
                !1 !== i && (n(r, o), e.requestAnimationFrame(t))
            }
            var e = null,
                i = !1,
                n = null;
            return {
                start: function() {
                    !0 !== i && null !== n && (e.requestAnimationFrame(t), i = !0)
                },
                stop: function() {
                    i = !1
                },
                setAnimationLoop: function(t) {
                    n = t
                },
                setContext: function(t) {
                    e = t
                }
            }
        }

        function et(t) {
            var e = new WeakMap;
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                },
                remove: function(i) {
                    i.isInterleavedBufferAttribute && (i = i.data);
                    var n = e.get(i);
                    n && (t.deleteBuffer(n.buffer), e.delete(i))
                },
                update: function(i, n) {
                    i.isInterleavedBufferAttribute && (i = i.data);
                    var r = e.get(i);
                    if (void 0 === r) e.set(i, function(e, i) {
                        var n = e.array,
                            r = e.dynamic ? 35048 : 35044,
                            o = t.createBuffer();
                        return t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
                            buffer: o,
                            type: i,
                            bytesPerElement: n.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }(i, n));
                    else if (r.version < i.version) {
                        var o = i,
                            s = o.array,
                            a = o.updateRange;
                        t.bindBuffer(n, r.buffer), !1 === o.dynamic ? t.bufferData(n, s, 35044) : -1 === a.count ? t.bufferSubData(n, 0, s) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), r.version = i.version
                    }
                }
            }
        }

        function it(t, e, i, n) {
            j.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            }, this.fromBufferGeometry(new nt(t, e, i, n)), this.mergeVertices()
        }

        function nt(t, e, i, n) {
            B.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            var r = (t = t || 1) / 2,
                o = (e = e || 1) / 2,
                s = (i = Math.floor(i) || 1) + 1,
                a = (n = Math.floor(n) || 1) + 1,
                l = t / i,
                c = e / n,
                h = [],
                u = [],
                d = [],
                p = [];
            for (t = 0; t < a; t++) {
                var f = t * c - o;
                for (e = 0; e < s; e++) u.push(e * l - r, -f, 0), d.push(0, 0, 1), p.push(e / i), p.push(1 - t / n)
            }
            for (t = 0; t < n; t++)
                for (e = 0; e < i; e++) r = e + s * (t + 1), o = e + 1 + s * (t + 1), a = e + 1 + s * t, h.push(e + s * t, r, a), h.push(r, o, a);
            this.setIndex(h), this.addAttribute("position", new I(u, 3)), this.addAttribute("normal", new I(d, 3)), this.addAttribute("uv", new I(p, 2))
        }

        function rt(t, e, i, n) {
            function r(t, i) {
                e.buffers.color.setClear(t.r, t.g, t.b, i, n)
            }
            var o, s, a = new x(0),
                l = 0,
                c = null,
                h = 0;
            return {
                getClearColor: function() {
                    return a
                },
                setClearColor: function(t, e) {
                    a.set(t), r(a, l = void 0 !== e ? e : 1)
                },
                getClearAlpha: function() {
                    return l
                },
                setClearAlpha: function(t) {
                    r(a, l = t)
                },
                render: function(e, n, u, d) {
                    n = n.background, (u = (u = t.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null), null === n ? (r(a, l), c = null, h = 0) : n && n.isColor && (r(n, 1), d = !0, c = null, h = 0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === s && ((s = new H(new da(1, 1, 1), new q({
                        type: "BackgroundCubeMaterial",
                        uniforms: V(wa.cube.uniforms),
                        vertexShader: wa.cube.vertexShader,
                        fragmentShader: wa.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function(t, e, i) {
                        this.matrixWorld.copyPosition(i.matrixWorld)
                    }, Object.defineProperty(s.material, "map", {
                        get: function() {
                            return this.uniforms.tCube.value
                        }
                    }), i.update(s)), d = n.isWebGLRenderTargetCube ? n.texture : n, s.material.uniforms.tCube.value = d, s.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && h === d.version || (s.material.needsUpdate = !0, c = n, h = d.version), e.unshift(s, s.geometry, s.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new H(new nt(2, 2), new q({
                        type: "BackgroundMaterial",
                        uniforms: V(wa.background.uniforms),
                        vertexShader: wa.background.vertexShader,
                        fragmentShader: wa.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), c === n && h === n.version || (o.material.needsUpdate = !0, c = n, h = n.version), e.unshift(o, o.geometry, o.material, 0, 0, null))
                }
            }
        }

        function ot(t, e, i, n) {
            var r;
            this.setMode = function(t) {
                r = t
            }, this.render = function(e, n) {
                t.drawArrays(r, e, n), i.update(n, r)
            }, this.renderInstances = function(o, s, a, l) {
                if (0 !== l) {
                    if (n.isWebGL2) {
                        o = t;
                        var c = "drawArraysInstanced"
                    } else if (c = "drawArraysInstancedANGLE", null === (o = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    o[c](r, s, a, l), i.update(a, r, l)
                }
            }
        }

        function st(t, e, i) {
            function n(e) {
                if ("highp" === e) {
                    if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
            }
            var r, o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                s = void 0 !== i.precision ? i.precision : "highp",
                a = n(s);
            a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a), i = !0 === i.logarithmicDepthBuffer, a = t.getParameter(34930);
            var l = t.getParameter(35660),
                c = t.getParameter(3379),
                h = t.getParameter(34076),
                u = t.getParameter(34921),
                d = t.getParameter(36347),
                p = t.getParameter(36348),
                f = t.getParameter(36349),
                m = 0 < l,
                g = o || !!e.get("OES_texture_float");
            return {
                isWebGL2: o,
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    var i = e.get("EXT_texture_filter_anisotropic");
                    return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: n,
                precision: s,
                logarithmicDepthBuffer: i,
                maxTextures: a,
                maxVertexTextures: l,
                maxTextureSize: c,
                maxCubemapSize: h,
                maxAttributes: u,
                maxVertexUniforms: d,
                maxVaryings: p,
                maxFragmentUniforms: f,
                vertexTextures: m,
                floatFragmentTextures: g,
                floatVertexTextures: m && g,
                maxSamples: o ? t.getParameter(36183) : 0
            }
        }

        function at() {
            function t() {
                h.value !== n && (h.value = n, h.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
            }

            function e(t, e, n, r) {
                var o = null !== t ? t.length : 0,
                    s = null;
                if (0 !== o) {
                    if (s = h.value, !0 !== r || null === s)
                        for (r = n + 4 * o, e = e.matrixWorldInverse, c.getNormalMatrix(e), (null === s || s.length < r) && (s = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) l.copy(t[r]).applyMatrix4(e, c), l.normal.toArray(s, n), s[n + 3] = l.constant;
                    h.value = s, h.needsUpdate = !0
                }
                return i.numPlanes = o, s
            }
            var i = this,
                n = null,
                r = 0,
                s = !1,
                a = !1,
                l = new Q,
                c = new o,
                h = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function(t, i, o) {
                var a = 0 !== t.length || i || 0 !== r || s;
                return s = i, n = e(t, o, 0), r = t.length, a
            }, this.beginShadows = function() {
                a = !0, e(null)
            }, this.endShadows = function() {
                a = !1, t()
            }, this.setState = function(i, o, l, c, u, d) {
                if (!s || null === i || 0 === i.length || a && !l) a ? e(null) : t();
                else {
                    var p = 4 * (l = a ? 0 : r),
                        f = u.clippingState || null;
                    for (h.value = f, f = e(i, c, p, d), i = 0; i !== p; ++i) f[i] = n[i];
                    u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
                }
            }
        }

        function lt(t) {
            var e = {};
            return {
                get: function(i) {
                    if (void 0 !== e[i]) return e[i];
                    switch (i) {
                        case "WEBGL_depth_texture":
                            var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(i)
                    }
                    return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n
                }
            }
        }

        function ct(t, e, i) {
            function n(t) {
                var r = t.target;
                for (var a in null !== (t = o.get(r)).index && e.remove(t.index), t.attributes) e.remove(t.attributes[a]);
                r.removeEventListener("dispose", n), o.delete(r), (a = s.get(t)) && (e.remove(a), s.delete(t)), i.memory.geometries--
            }

            function r(t) {
                var i = [],
                    n = t.index,
                    r = t.attributes.position;
                if (null !== n) {
                    var o = n.array;
                    n = n.version, r = 0;
                    for (var a = o.length; r < a; r += 3) {
                        var l = o[r + 0],
                            c = o[r + 1],
                            h = o[r + 2];
                        i.push(l, c, c, h, h, l)
                    }
                } else
                    for (o = r.array, n = r.version, r = 0, a = o.length / 3 - 1; r < a; r += 3) l = r + 0, c = r + 1, h = r + 2, i.push(l, c, c, h, h, l);
                (i = new(65535 < F(i) ? D : O)(i, 1)).version = n, e.update(i, 34963), (o = s.get(t)) && e.remove(o), s.set(t, i)
            }
            var o = new WeakMap,
                s = new WeakMap;
            return {
                get: function(t, e) {
                    var r = o.get(e);
                    return r || (e.addEventListener("dispose", n), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new B).setFromObject(t)), r = e._bufferGeometry), o.set(e, r), i.memory.geometries++, r)
                },
                update: function(t) {
                    var i = t.index,
                        n = t.attributes;
                    for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962);
                    for (r in t = t.morphAttributes) {
                        n = 0;
                        for (var o = (i = t[r]).length; n < o; n++) e.update(i[n], 34962)
                    }
                },
                getWireframeAttribute: function(t) {
                    var e = s.get(t);
                    if (e) {
                        var i = t.index;
                        null !== i && e.version < i.version && r(t)
                    } else r(t);
                    return s.get(t)
                }
            }
        }

        function ht(t, e, i, n) {
            var r, o, s;
            this.setMode = function(t) {
                r = t
            }, this.setIndex = function(t) {
                o = t.type, s = t.bytesPerElement
            }, this.render = function(e, n) {
                t.drawElements(r, n, o, e * s), i.update(n, r)
            }, this.renderInstances = function(a, l, c, h) {
                if (0 !== h) {
                    if (n.isWebGL2) {
                        a = t;
                        var u = "drawElementsInstanced"
                    } else if (u = "drawElementsInstancedANGLE", null === (a = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    a[u](r, c, o, l * s, h), i.update(c, r, h)
                }
            }
        }

        function ut(t) {
            var e = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: e,
                programs: null,
                autoReset: !0,
                reset: function() {
                    e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                },
                update: function(t, i, n) {
                    switch (n = n || 1, e.calls++, i) {
                        case 4:
                            e.triangles += t / 3 * n;
                            break;
                        case 5:
                        case 6:
                            e.triangles += n * (t - 2);
                            break;
                        case 1:
                            e.lines += t / 2 * n;
                            break;
                        case 3:
                            e.lines += n * (t - 1);
                            break;
                        case 2:
                            e.lines += n * t;
                            break;
                        case 0:
                            e.points += n * t;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }

        function dt(t, e) {
            return Math.abs(e[1]) - Math.abs(t[1])
        }

        function pt(t) {
            var e = {},
                i = new Float32Array(8);
            return {
                update: function(n, r, o, s) {
                    var a = n.morphTargetInfluences,
                        l = a.length;
                    if (void 0 === (n = e[r.id])) {
                        n = [];
                        for (var c = 0; c < l; c++) n[c] = [c, 0];
                        e[r.id] = n
                    }
                    var h = o.morphTargets && r.morphAttributes.position;
                    for (o = o.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
                        var u = n[c];
                        0 !== u[1] && (h && r.removeAttribute("morphTarget" + c), o && r.removeAttribute("morphNormal" + c))
                    }
                    for (c = 0; c < l; c++)(u = n[c])[0] = c, u[1] = a[c];
                    for (n.sort(dt), c = 0; 8 > c; c++)(u = n[c]) && (a = u[0], l = u[1]) ? (h && r.addAttribute("morphTarget" + c, h[a]), o && r.addAttribute("morphNormal" + c, o[a]), i[c] = l) : i[c] = 0;
                    s.getUniforms().setValue(t, "morphTargetInfluences", i)
                }
            }
        }

        function ft(t, e, i, n) {
            var r = {};
            return {
                update: function(t) {
                    var o = n.render.frame,
                        s = t.geometry,
                        a = e.get(t, s);
                    return r[a.id] !== o && (s.isGeometry && a.updateFromObject(t), e.update(a), r[a.id] = o), t.isInstancedMesh && i.update(t.instanceMatrix, 34962), a
                },
                dispose: function() {
                    r = {}
                }
            }
        }

        function mt(t, e, i, n, r, o, a, l, c, h) {
            t = void 0 !== t ? t : [], s.call(this, t, void 0 !== e ? e : 301, i, n, r, o, void 0 !== a ? a : 1022, l, c, h), this.flipY = !1
        }

        function gt(t, e, i, n) {
            s.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1,
                depth: n || 1
            }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0
        }

        function vt(t, e, i, n) {
            s.call(this, null), this.image = {
                data: t || null,
                width: e || 1,
                height: i || 1,
                depth: n || 1
            }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1, this.needsUpdate = !0
        }

        function yt(t, e, i) {
            var n = t[0];
            if (0 >= n || 0 < n) return t;
            var r = e * i,
                o = Ea[r];
            if (void 0 === o && (o = new Float32Array(r), Ea[r] = o), 0 !== e)
                for (n.toArray(o, 0), n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(o, r);
            return o
        }

        function _t(t, e) {
            if (t.length !== e.length) return !1;
            for (var i = 0, n = t.length; i < n; i++)
                if (t[i] !== e[i]) return !1;
            return !0
        }

        function xt(t, e) {
            for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
        }

        function wt(t, e) {
            var i = Aa[e];
            void 0 === i && (i = new Int32Array(e), Aa[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
            return i
        }

        function bt(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
        }

        function Tt(t, e) {
            var i = this.cache;
            void 0 !== e.x ? i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : _t(i, e) || (t.uniform2fv(this.addr, e), xt(i, e))
        }

        function St(t, e) {
            var i = this.cache;
            void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : void 0 !== e.r ? i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : _t(i, e) || (t.uniform3fv(this.addr, e), xt(i, e))
        }

        function Mt(t, e) {
            var i = this.cache;
            void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : _t(i, e) || (t.uniform4fv(this.addr, e), xt(i, e))
        }

        function Et(t, e) {
            var i = this.cache,
                n = e.elements;
            void 0 === n ? _t(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), xt(i, e)) : _t(i, n) || (Ra.set(n), t.uniformMatrix2fv(this.addr, !1, Ra), xt(i, n))
        }

        function At(t, e) {
            var i = this.cache,
                n = e.elements;
            void 0 === n ? _t(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), xt(i, e)) : _t(i, n) || (Ca.set(n), t.uniformMatrix3fv(this.addr, !1, Ca), xt(i, n))
        }

        function Pt(t, e) {
            var i = this.cache,
                n = e.elements;
            void 0 === n ? _t(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), xt(i, e)) : _t(i, n) || (Pa.set(n), t.uniformMatrix4fv(this.addr, !1, Pa), xt(i, n))
        }

        function Ct(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || ba, r)
        }

        function Rt(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || Ta, r)
        }

        function Lt(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Sa, r)
        }

        function Ot(t, e, i) {
            var n = this.cache,
                r = i.allocateTextureUnit();
            n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || Ma, r)
        }

        function kt(t, e) {
            var i = this.cache;
            i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
        }

        function Dt(t, e) {
            var i = this.cache;
            _t(i, e) || (t.uniform2iv(this.addr, e), xt(i, e))
        }

        function It(t, e) {
            var i = this.cache;
            _t(i, e) || (t.uniform3iv(this.addr, e), xt(i, e))
        }

        function Nt(t, e) {
            var i = this.cache;
            _t(i, e) || (t.uniform4iv(this.addr, e), xt(i, e))
        }

        function zt(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function Ft(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function Bt(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function Ht(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function Ut(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function Gt(t, e) {
            e = yt(e, this.size, 2), t.uniform2fv(this.addr, e)
        }

        function jt(t, e) {
            e = yt(e, this.size, 3), t.uniform3fv(this.addr, e)
        }

        function Vt(t, e) {
            e = yt(e, this.size, 4), t.uniform4fv(this.addr, e)
        }

        function Wt(t, e) {
            e = yt(e, this.size, 4), t.uniformMatrix2fv(this.addr, !1, e)
        }

        function qt(t, e) {
            e = yt(e, this.size, 9), t.uniformMatrix3fv(this.addr, !1, e)
        }

        function Xt(t, e) {
            e = yt(e, this.size, 16), t.uniformMatrix4fv(this.addr, !1, e)
        }

        function $t(t, e, i) {
            var n = e.length,
                r = wt(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || ba, r[t])
        }

        function Yt(t, e, i) {
            var n = e.length,
                r = wt(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || Ma, r[t])
        }

        function Zt(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return bt;
                    case 35664:
                        return Tt;
                    case 35665:
                        return St;
                    case 35666:
                        return Mt;
                    case 35674:
                        return Et;
                    case 35675:
                        return At;
                    case 35676:
                        return Pt;
                    case 35678:
                    case 36198:
                        return Ct;
                    case 35679:
                        return Lt;
                    case 35680:
                        return Ot;
                    case 36289:
                        return Rt;
                    case 5124:
                    case 35670:
                        return kt;
                    case 35667:
                    case 35671:
                        return Dt;
                    case 35668:
                    case 35672:
                        return It;
                    case 35669:
                    case 35673:
                        return Nt
                }
            }(e.type)
        }

        function Jt(t, e, i) {
            this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                switch (t) {
                    case 5126:
                        return zt;
                    case 35664:
                        return Gt;
                    case 35665:
                        return jt;
                    case 35666:
                        return Vt;
                    case 35674:
                        return Wt;
                    case 35675:
                        return qt;
                    case 35676:
                        return Xt;
                    case 35678:
                        return $t;
                    case 35680:
                        return Yt;
                    case 5124:
                    case 35670:
                        return Ft;
                    case 35667:
                    case 35671:
                        return Bt;
                    case 35668:
                    case 35672:
                        return Ht;
                    case 35669:
                    case 35673:
                        return Ut
                }
            }(e.type)
        }

        function Qt(t) {
            this.id = t, this.seq = [], this.map = {}
        }

        function Kt(t, e) {
            this.seq = [], this.map = {};
            for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) {
                var r = t.getActiveUniform(e, n),
                    o = t.getUniformLocation(e, r.name),
                    s = this,
                    a = r.name,
                    l = a.length;
                for (La.lastIndex = 0;;) {
                    var c = La.exec(a),
                        h = La.lastIndex,
                        u = c[1],
                        d = c[3];
                    if ("]" === c[2] && (u |= 0), void 0 === d || "[" === d && h + 2 === l) {
                        a = s, r = void 0 === d ? new Zt(u, r, o) : new Jt(u, r, o), a.seq.push(r), a.map[r.id] = r;
                        break
                    }
                    void 0 === (d = s.map[u]) && (d = new Qt(u), u = s, s = d, u.seq.push(s), u.map[s.id] = s), s = d
                }
            }
        }

        function te(t, e, i) {
            return e = t.createShader(e), t.shaderSource(e, i), t.compileShader(e), e
        }

        function ee(t) {
            switch (t) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                case 3003:
                    return ["LogLuv", "( value )"];
                default:
                    throw Error("unsupported encoding: " + t)
            }
        }

        function ie(t, e, i) {
            var n = t.getShaderParameter(e, 35713),
                r = t.getShaderInfoLog(e).trim();
            if (n && "" === r) return "";
            for (t = t.getShaderSource(e).split("\n"), e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
            return "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + r + (t = t.join("\n"))
        }

        function ne(t, e) {
            return "vec4 " + t + "( vec4 value ) { return " + (e = ee(e))[0] + "ToLinear" + e[1] + "; }"
        }

        function re(t, e) {
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + (e = ee(e))[0] + e[1] + "; }"
        }

        function oe(t, e) {
            switch (e) {
                case 1:
                    e = "Linear";
                    break;
                case 2:
                    e = "Reinhard";
                    break;
                case 3:
                    e = "Uncharted2";
                    break;
                case 4:
                    e = "OptimizedCineon";
                    break;
                case 5:
                    e = "ACESFilmic";
                    break;
                default:
                    throw Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
        }

        function se(t) {
            return "" !== t
        }

        function ae(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
        }

        function le(t, e) {
            return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
        }

        function ce(t, e) {
            if (void 0 === (t = _a[e])) throw Error("Can not resolve #include <" + e + ">");
            return t.replace(ka, ce)
        }

        function he(t, e, i, n) {
            for (t = "", e = parseInt(e); e < parseInt(i); e++) t += n.replace(/\[ i \]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return t
        }

        function ue(t) {
            var e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
            return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
        }

        function de(t, e, i, n, r, o) {
            var s, a, l = t.getContext(),
                c = n.defines,
                h = r.vertexShader,
                u = r.fragmentShader,
                d = function(t) {
                    var e = "SHADOWMAP_TYPE_BASIC";
                    return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                }(o),
                p = function(t, e) {
                    var i = "ENVMAP_TYPE_CUBE";
                    if (t.envMap) switch (e.envMap.mapping) {
                        case 301:
                        case 302:
                            i = "ENVMAP_TYPE_CUBE";
                            break;
                        case 306:
                        case 307:
                            i = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case 303:
                        case 304:
                            i = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case 305:
                            i = "ENVMAP_TYPE_SPHERE"
                    }
                    return i
                }(o, n),
                f = function(t, e) {
                    var i = "ENVMAP_MODE_REFLECTION";
                    if (t.envMap) switch (e.envMap.mapping) {
                        case 302:
                        case 304:
                            i = "ENVMAP_MODE_REFRACTION"
                    }
                    return i
                }(o, n),
                m = function(t, e) {
                    var i = "ENVMAP_BLENDING_MULTIPLY";
                    if (t.envMap) switch (e.combine) {
                        case 0:
                            i = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            i = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            i = "ENVMAP_BLENDING_ADD"
                    }
                    return i
                }(o, n),
                g = 0 < t.gammaFactor ? t.gammaFactor : 1,
                v = o.isWebGL2 ? "" : function(t, e, i) {
                    return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(se).join("\n")
                }(n.extensions, o, e),
                y = function(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        !1 !== n && i.push("#define " + e + " " + n)
                    }
                    return i.join("\n")
                }(c),
                _ = l.createProgram(),
                x = (c = t.getRenderTarget()) && c.isWebGLMultiviewRenderTarget ? c.numViews : 0;
            return n.isRawShaderMaterial ? (0 < (c = [y].filter(se).join("\n")).length && (c += "\n"), 0 < (e = [v, y].filter(se).join("\n")).length && (e += "\n")) : (c = [ue(o), "#define SHADER_NAME " + r.name, y, o.instancing ? "#define USE_INSTANCING" : "", o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(se).join("\n"), e = [v, ue(o), "#define SHADER_NAME " + r.name, y, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp2 ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.normalMap && o.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", o.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.sheen ? "#define USE_SHEEN" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.vertexUvs ? "#define USE_UV" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensions && n.extensions.shaderTextureLOD || o.envMap) && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? _a.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? oe("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? _a.encodings_pars_fragment : "", o.mapEncoding ? ne("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? ne("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? ne("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? ne("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? re("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(se).join("\n")), h = le(h = ae(h = h.replace(ka, ce), o), o), u = le(u = ae(u = u.replace(ka, ce), o), o), h = h.replace(Da, he), u = u.replace(Da, he), o.isWebGL2 && !n.isRawShaderMaterial && (d = !1, p = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== h.match(p) && null !== u.match(p) && (d = !0, h = h.replace(p, ""), u = u.replace(p, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, e = ["#version 300 es\n\n#define varying in", d ? "" : "out highp vec4 pc_fragColor;", d ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + e, 0 < x && (c = (c = c.replace("#version 300 es\n", ["#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + x + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n"))).replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + x + "];", "uniform mat4 projectionMatrices[" + x + "];", "uniform mat4 viewMatrices[" + x + "];", "uniform mat3 normalMatrices[" + x + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), e = (e = e.replace("#version 300 es\n", "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR")).replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + x + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n")))), u = e + u, h = te(l, 35633, c + h), u = te(l, 35632, u), l.attachShader(_, h), l.attachShader(_, u), void 0 !== n.index0AttributeName ? l.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(_, 0, "position"), l.linkProgram(_), t.debug.checkShaderErrors && (t = l.getProgramInfoLog(_).trim(), o = l.getShaderInfoLog(h).trim(), d = l.getShaderInfoLog(u).trim(), f = p = !0, !1 === l.getProgramParameter(_, 35714) ? (p = !1, m = ie(l, h, "vertex"), g = ie(l, u, "fragment"), console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(_, 35715), "gl.getProgramInfoLog", t, m, g)) : "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== o && "" !== d || (f = !1), f && (this.diagnostics = {
                runnable: p,
                material: n,
                programLog: t,
                vertexShader: {
                    log: o,
                    prefix: c
                },
                fragmentShader: {
                    log: d,
                    prefix: e
                }
            })), l.deleteShader(h), l.deleteShader(u), this.getUniforms = function() {
                return void 0 === s && (s = new Kt(l, _)), s
            }, this.getAttributes = function() {
                if (void 0 === a) {
                    for (var t = {}, e = l.getProgramParameter(_, 35721), i = 0; i < e; i++) {
                        var n = l.getActiveAttrib(_, i).name;
                        t[n] = l.getAttribLocation(_, n)
                    }
                    a = t
                }
                return a
            }, this.destroy = function() {
                l.deleteProgram(_), this.program = void 0
            }, this.name = r.name, this.id = Oa++, this.code = i, this.usedTimes = 1, this.program = _, this.vertexShader = h, this.fragmentShader = u, this.numMultiviewViews = x, this
        }

        function pe(t, e, i) {
            function n(t, e) {
                if (t) t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding);
                else var i = 3e3;
                return 3e3 === i && e && (i = 3007), i
            }
            var r = [],
                o = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distanceRGBA",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                },
                s = "precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
            this.getParameters = function(e, r, s, a, l, c, h) {
                var u = o[e.type];
                if (h.isSkinnedMesh) {
                    var d = h.skeleton.bones;
                    if (i.floatVertexTextures) d = 1024;
                    else {
                        var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length);
                        p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p
                    }
                } else d = 0;
                p = i.precision, null !== e.precision && ((p = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead."));
                var f = t.getRenderTarget();
                return {
                    isWebGL2: i.isWebGL2,
                    shaderID: u,
                    precision: p,
                    instancing: !0 === h.isInstancedMesh,
                    supportsVertexTextures: i.vertexTextures,
                    outputEncoding: n(f ? f.texture : null, t.gammaOutput),
                    map: !!e.map,
                    mapEncoding: n(e.map, t.gammaInput),
                    matcap: !!e.matcap,
                    matcapEncoding: n(e.matcap, t.gammaInput),
                    envMap: !!e.envMap,
                    envMapMode: e.envMap && e.envMap.mapping,
                    envMapEncoding: n(e.envMap, t.gammaInput),
                    envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping),
                    lightMap: !!e.lightMap,
                    aoMap: !!e.aoMap,
                    emissiveMap: !!e.emissiveMap,
                    emissiveMapEncoding: n(e.emissiveMap, t.gammaInput),
                    bumpMap: !!e.bumpMap,
                    normalMap: !!e.normalMap,
                    objectSpaceNormalMap: 1 === e.normalMapType,
                    tangentSpaceNormalMap: 0 === e.normalMapType,
                    clearcoatNormalMap: !!e.clearcoatNormalMap,
                    displacementMap: !!e.displacementMap,
                    roughnessMap: !!e.roughnessMap,
                    metalnessMap: !!e.metalnessMap,
                    specularMap: !!e.specularMap,
                    alphaMap: !!e.alphaMap,
                    gradientMap: !!e.gradientMap,
                    sheen: !!e.sheen,
                    combine: e.combine,
                    vertexTangents: e.normalMap && e.vertexTangents,
                    vertexColors: e.vertexColors,
                    vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap),
                    fog: !!a,
                    useFog: e.fog,
                    fogExp2: a && a.isFogExp2,
                    flatShading: e.flatShading,
                    sizeAttenuation: e.sizeAttenuation,
                    logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                    skinning: e.skinning && 0 < d,
                    maxBones: d,
                    useVertexTexture: i.floatVertexTextures,
                    morphTargets: e.morphTargets,
                    morphNormals: e.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: r.directional.length,
                    numPointLights: r.point.length,
                    numSpotLights: r.spot.length,
                    numRectAreaLights: r.rectArea.length,
                    numHemiLights: r.hemi.length,
                    numDirLightShadows: r.directionalShadowMap.length,
                    numPointLightShadows: r.pointShadowMap.length,
                    numSpotLightShadows: r.spotShadowMap.length,
                    numClippingPlanes: l,
                    numClipIntersection: c,
                    dithering: e.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && 0 < s.length,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: e.toneMapped ? t.toneMapping : 0,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: e.premultipliedAlpha,
                    alphaTest: e.alphaTest,
                    doubleSided: 2 === e.side,
                    flipSided: 1 === e.side,
                    depthPacking: void 0 !== e.depthPacking && e.depthPacking
                }
            }, this.getProgramCode = function(e, i) {
                var n = [];
                if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                    for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                for (r = 0; r < s.length; r++) n.push(i[s[r]]);
                return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join()
            }, this.acquireProgram = function(i, n, o, s) {
                for (var a, l = 0, c = r.length; l < c; l++) {
                    var h = r[l];
                    if (h.code === s) {
                        ++(a = h).usedTimes;
                        break
                    }
                }
                return void 0 === a && (a = new de(t, e, s, i, n, o), r.push(a)), a
            }, this.releaseProgram = function(t) {
                if (0 == --t.usedTimes) {
                    var e = r.indexOf(t);
                    r[e] = r[r.length - 1], r.pop(), t.destroy()
                }
            }, this.programs = r
        }

        function fe() {
            var t = new WeakMap;
            return {
                get: function(e) {
                    var i = t.get(e);
                    return void 0 === i && (i = {}, t.set(e, i)), i
                },
                remove: function(e) {
                    t.delete(e)
                },
                update: function(e, i, n) {
                    t.get(e)[i] = n
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }

        function me(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function ge(t, e) {
            return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function ve() {
            function t(t, n, r, s, a, l) {
                var c = e[i];
                return void 0 === c ? (c = {
                    id: t.id,
                    object: t,
                    geometry: n,
                    material: r,
                    program: r.program || o,
                    groupOrder: s,
                    renderOrder: t.renderOrder,
                    z: a,
                    group: l
                }, e[i] = c) : (c.id = t.id, c.object = t, c.geometry = n, c.material = r, c.program = r.program || o, c.groupOrder = s, c.renderOrder = t.renderOrder, c.z = a, c.group = l), i++, c
            }
            var e = [],
                i = 0,
                n = [],
                r = [],
                o = {
                    id: -1
                };
            return {
                opaque: n,
                transparent: r,
                init: function() {
                    i = 0, n.length = 0, r.length = 0
                },
                push: function(e, i, o, s, a, l) {
                    e = t(e, i, o, s, a, l), (!0 === o.transparent ? r : n).push(e)
                },
                unshift: function(e, i, o, s, a, l) {
                    e = t(e, i, o, s, a, l), (!0 === o.transparent ? r : n).unshift(e)
                },
                sort: function() {
                    1 < n.length && n.sort(me), 1 < r.length && r.sort(ge)
                }
            }
        }

        function ye() {
            function t(i) {
                (i = i.target).removeEventListener("dispose", t), e.delete(i)
            }
            var e = new WeakMap;
            return {
                get: function(i, n) {
                    var r = e.get(i);
                    if (void 0 === r) {
                        var o = new ve;
                        e.set(i, new WeakMap), e.get(i).set(n, o), i.addEventListener("dispose", t)
                    } else void 0 === (o = r.get(n)) && (o = new ve, r.set(n, o));
                    return o
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function _e() {
            var t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    switch (e.type) {
                        case "DirectionalLight":
                            var n = {
                                direction: new r,
                                color: new x,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new r,
                                direction: new r,
                                color: new x,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new r,
                                color: new x,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new r,
                                skyColor: new x,
                                groundColor: new x
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new x,
                                position: new r,
                                halfWidth: new r,
                                halfHeight: new r
                            }
                    }
                    return t[e.id] = n
                }
            }
        }

        function xe(t, e) {
            return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
        }

        function we() {
            for (var t = new _e, e = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1
                }, i = 0; 9 > i; i++) e.probe.push(new r);
            var n = new r,
                o = new h,
                s = new h;
            return {
                setup: function(i, r, a) {
                    for (var l = 0, c = 0, h = 0, u = 0; 9 > u; u++) e.probe[u].set(0, 0, 0);
                    var d = r = 0,
                        p = 0,
                        f = 0,
                        m = 0,
                        g = 0,
                        v = 0,
                        y = 0;
                    a = a.matrixWorldInverse, i.sort(xe), u = 0;
                    for (var _ = i.length; u < _; u++) {
                        var x = i[u],
                            w = x.color,
                            b = x.intensity,
                            T = x.distance,
                            S = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                        if (x.isAmbientLight) l += w.r * b, c += w.g * b, h += w.b * b;
                        else if (x.isLightProbe)
                            for (S = 0; 9 > S; S++) e.probe[S].addScaledVector(x.sh.coefficients[S], b);
                        else if (x.isDirectionalLight) {
                            var M = t.get(x);
                            M.color.copy(x.color).multiplyScalar(x.intensity), M.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(a), (M.shadow = x.castShadow) && (b = x.shadow, M.shadowBias = b.bias, M.shadowRadius = b.radius, M.shadowMapSize = b.mapSize, e.directionalShadowMap[r] = S, e.directionalShadowMatrix[r] = x.shadow.matrix, g++), e.directional[r] = M, r++
                        } else x.isSpotLight ? ((M = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(a), M.color.copy(w).multiplyScalar(b), M.distance = T, M.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), M.direction.sub(n), M.direction.transformDirection(a), M.coneCos = Math.cos(x.angle), M.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), M.decay = x.decay, (M.shadow = x.castShadow) && (b = x.shadow, M.shadowBias = b.bias, M.shadowRadius = b.radius, M.shadowMapSize = b.mapSize, e.spotShadowMap[p] = S, e.spotShadowMatrix[p] = x.shadow.matrix, y++), e.spot[p] = M, p++) : x.isRectAreaLight ? ((M = t.get(x)).color.copy(w).multiplyScalar(b), M.position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(a), s.identity(), o.copy(x.matrixWorld), o.premultiply(a), s.extractRotation(o), M.halfWidth.set(.5 * x.width, 0, 0), M.halfHeight.set(0, .5 * x.height, 0), M.halfWidth.applyMatrix4(s), M.halfHeight.applyMatrix4(s), e.rectArea[f] = M, f++) : x.isPointLight ? ((M = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), M.position.applyMatrix4(a), M.color.copy(x.color).multiplyScalar(x.intensity), M.distance = x.distance, M.decay = x.decay, (M.shadow = x.castShadow) && (b = x.shadow, M.shadowBias = b.bias, M.shadowRadius = b.radius, M.shadowMapSize = b.mapSize, M.shadowCameraNear = b.camera.near, M.shadowCameraFar = b.camera.far, e.pointShadowMap[d] = S, e.pointShadowMatrix[d] = x.shadow.matrix, v++), e.point[d] = M, d++) : x.isHemisphereLight && ((M = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld), M.direction.transformDirection(a), M.direction.normalize(), M.skyColor.copy(x.color).multiplyScalar(b), M.groundColor.copy(x.groundColor).multiplyScalar(b), e.hemi[m] = M, m++)
                    }
                    e.ambient[0] = l, e.ambient[1] = c, e.ambient[2] = h, (i = e.hash).directionalLength === r && i.pointLength === d && i.spotLength === p && i.rectAreaLength === f && i.hemiLength === m && i.numDirectionalShadows === g && i.numPointShadows === v && i.numSpotShadows === y || (e.directional.length = r, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.directionalShadowMap.length = g, e.pointShadowMap.length = v, e.spotShadowMap.length = y, e.directionalShadowMatrix.length = g, e.pointShadowMatrix.length = v, e.spotShadowMatrix.length = y, i.directionalLength = r, i.pointLength = d, i.spotLength = p, i.rectAreaLength = f, i.hemiLength = m, i.numDirectionalShadows = g, i.numPointShadows = v, i.numSpotShadows = y, e.version = Ia++)
                },
                state: e
            }
        }

        function be() {
            var t = new we,
                e = [],
                i = [];
            return {
                init: function() {
                    e.length = 0, i.length = 0
                },
                state: {
                    lightsArray: e,
                    shadowsArray: i,
                    lights: t
                },
                setupLights: function(n) {
                    t.setup(e, i, n)
                },
                pushLight: function(t) {
                    e.push(t)
                },
                pushShadow: function(t) {
                    i.push(t)
                }
            }
        }

        function Te() {
            function t(i) {
                (i = i.target).removeEventListener("dispose", t), e.delete(i)
            }
            var e = new WeakMap;
            return {
                get: function(i, n) {
                    if (!1 === e.has(i)) {
                        var r = new be;
                        e.set(i, new WeakMap), e.get(i).set(n, r), i.addEventListener("dispose", t)
                    } else !1 === e.get(i).has(n) ? (r = new be, e.get(i).set(n, r)) : r = e.get(i).get(n);
                    return r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Se(t) {
            M.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
        }

        function Me(t) {
            M.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
        }

        function Ee(t, e, n) {
            function r(e, i, n, r, o, s) {
                var a = e.geometry,
                    l = d,
                    c = e.customDepthMaterial;
                return n.isPointLight && (l = p, c = e.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (a && a.isBufferGeometry ? c = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (c = a.morphTargets && 0 < a.morphTargets.length)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e), a = 0, c && (a |= 1), (e = e.isSkinnedMesh && i.skinning) && (a |= 2), l = l[a]), t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (a = l.uuid, c = i.uuid, void 0 === (e = f[a]) && (e = {}, f[a] = e), void 0 === (a = e[c]) && (a = l.clone(), e[c] = a), l = a), l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === s ? null != i.shadowSide ? i.shadowSide : i.side : null != i.shadowSide ? i.shadowSide : m[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n.isPointLight && l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(n.matrixWorld), l.nearDistance = r, l.farDistance = o), l
            }

            function o(i, n, a, l, c) {
                if (!1 !== i.visible) {
                    if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && 3 === c) && (!i.frustumCulled || s.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld);
                        var h = e.update(i),
                            u = i.material;
                        if (Array.isArray(u))
                            for (var d = h.groups, p = 0, f = d.length; p < f; p++) {
                                var m = d[p],
                                    g = u[m.materialIndex];
                                g && g.visible && (g = r(i, g, l, a.near, a.far, c), t.renderBufferDirect(a, null, h, g, i, m))
                            } else u.visible && (g = r(i, u, l, a.near, a.far, c), t.renderBufferDirect(a, null, h, g, i, null))
                    }
                    for (h = 0, u = (i = i.children).length; h < u; h++) o(i[h], n, a, l, c)
                }
            }
            var s = new K,
                c = new i,
                h = new i,
                u = new a,
                d = Array(4),
                p = Array(4),
                f = {},
                m = {
                    0: 1,
                    1: 0,
                    2: 2
                },
                g = new q({
                    defines: {
                        SAMPLE_RATE: .25,
                        HALF_SAMPLE_RATE: .125
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new i
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}"
                }),
                v = g.clone();
            v.defines.HORIZONAL_PASS = 1;
            var y = new B;
            y.addAttribute("position", new A(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            var _ = new H(y, g);
            for (y = 0; 4 !== y; ++y) {
                var x = 0 != (1 & y),
                    w = 0 != (2 & y),
                    b = new Se({
                        depthPacking: 3201,
                        morphTargets: x,
                        skinning: w
                    });
                d[y] = b, x = new Me({
                    morphTargets: x,
                    skinning: w
                }), p[y] = x
            }
            var T = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(i, r, a) {
                if (!1 !== T.enabled && (!1 !== T.autoUpdate || !1 !== T.needsUpdate) && 0 !== i.length) {
                    var d = t.getRenderTarget(),
                        p = t.getActiveCubeFace(),
                        f = t.getActiveMipmapLevel(),
                        m = t.state;
                    m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
                    for (var y = 0, x = i.length; y < x; y++) {
                        var w = i[y],
                            b = w.shadow;
                        if (void 0 === b) console.warn("THREE.WebGLShadowMap:", w, "has no shadow.");
                        else {
                            c.copy(b.mapSize);
                            var S = b.getFrameExtents();
                            c.multiply(S), h.copy(b.mapSize), (c.x > n || c.y > n) && (console.warn("THREE.WebGLShadowMap:", w, "has shadow exceeding max texture size, reducing"), c.x > n && (h.x = Math.floor(n / S.x), c.x = h.x * S.x, b.mapSize.x = h.x), c.y > n && (h.y = Math.floor(n / S.y), c.y = h.y * S.y, b.mapSize.y = h.y)), null !== b.map || b.isPointLightShadow || 3 !== this.type || (S = {
                                minFilter: 1006,
                                magFilter: 1006,
                                format: 1023
                            }, b.map = new l(c.x, c.y, S), b.map.texture.name = w.name + ".shadowMap", b.mapPass = new l(c.x, c.y, S), b.camera.updateProjectionMatrix()), null === b.map && (S = {
                                minFilter: 1003,
                                magFilter: 1003,
                                format: 1023
                            }, b.map = new l(c.x, c.y, S), b.map.texture.name = w.name + ".shadowMap", b.camera.updateProjectionMatrix()), t.setRenderTarget(b.map), t.clear(), S = b.getViewportCount();
                            for (var M = 0; M < S; M++) {
                                var E = b.getViewport(M);
                                u.set(h.x * E.x, h.y * E.y, h.x * E.z, h.y * E.w), m.viewport(u), b.updateMatrices(w, a, M), s = b.getFrustum(), o(r, a, b.camera, w, this.type)
                            }
                            b.isPointLightShadow || 3 !== this.type || (w = b, b = a, S = e.update(_), g.uniforms.shadow_pass.value = w.map.texture, g.uniforms.resolution.value = w.mapSize, g.uniforms.radius.value = w.radius, t.setRenderTarget(w.mapPass), t.clear(), t.renderBufferDirect(b, null, S, g, _, null), v.uniforms.shadow_pass.value = w.mapPass.texture, v.uniforms.resolution.value = w.mapSize, v.uniforms.radius.value = w.radius, t.setRenderTarget(w.map), t.clear(), t.renderBufferDirect(b, null, S, v, _, null))
                        }
                    }
                    T.needsUpdate = !1, t.setRenderTarget(d, p, f)
                }
            }
        }

        function Ae(t, e, i, n) {
            function r(e, i, n) {
                var r = new Uint8Array(4),
                    o = t.createTexture();
                for (t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728), e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                return o
            }

            function o(i, r) {
                y[i] = 1, 0 === _[i] && (t.enableVertexAttribArray(i), _[i] = 1), x[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), x[i] = r)
            }

            function s(e) {
                !0 !== w[e] && (t.enable(e), w[e] = !0)
            }

            function l(e) {
                !1 !== w[e] && (t.disable(e), w[e] = !1)
            }

            function c(e, n, r, o, a, c, h, u) {
                if (0 === e) S && (l(3042), S = !1);
                else if (S || (s(3042), S = !0), 5 !== e) {
                    if (e !== M || u !== O) {
                        if (100 === E && 100 === C || (t.blendEquation(32774), C = E = 100), u) switch (e) {
                            case 1:
                                t.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(1, 1);
                                break;
                            case 3:
                                t.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                t.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        } else switch (e) {
                            case 1:
                                t.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                t.blendFunc(770, 1);
                                break;
                            case 3:
                                t.blendFunc(0, 769);
                                break;
                            case 4:
                                t.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                        L = R = P = A = null, M = e, O = u
                    }
                } else a = a || n, c = c || r, h = h || o, n === E && a === C || (t.blendEquationSeparate(i.convert(n), i.convert(a)), E = n, C = a), r === A && o === P && c === R && h === L || (t.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(c), i.convert(h)), A = r, P = o, R = c, L = h), M = e, O = null
            }

            function h(e) {
                k !== e && (e ? t.frontFace(2304) : t.frontFace(2305), k = e)
            }

            function u(e) {
                0 !== e ? (s(2884), e !== D && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : l(2884), D = e
            }

            function d(e, i, n) {
                e ? (s(32823), (N !== i || z !== n) && (t.polygonOffset(i, n), N = i, z = n)) : l(32823)
            }

            function p(e) {
                void 0 === e && (e = 33984 + F - 1), H !== e && (t.activeTexture(e), H = e)
            }
            var f = new function() {
                    var e = !1,
                        i = new a,
                        n = null,
                        r = new a(0, 0, 0, 0);
                    return {
                        setMask: function(i) {
                            n === i || e || (t.colorMask(i, i, i, i), n = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, n, o, s, a) {
                            !0 === a && (e *= s, n *= s, o *= s), i.set(e, n, o, s), !1 === r.equals(i) && (t.clearColor(e, n, o, s), r.copy(i))
                        },
                        reset: function() {
                            e = !1, n = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                m = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null;
                    return {
                        setTest: function(t) {
                            t ? s(2929) : l(2929)
                        },
                        setMask: function(n) {
                            i === n || e || (t.depthMask(n), i = n)
                        },
                        setFunc: function(e) {
                            if (n !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(512);
                                        break;
                                    case 1:
                                        t.depthFunc(519);
                                        break;
                                    case 2:
                                        t.depthFunc(513);
                                        break;
                                    case 3:
                                        t.depthFunc(515);
                                        break;
                                    case 4:
                                        t.depthFunc(514);
                                        break;
                                    case 5:
                                        t.depthFunc(518);
                                        break;
                                    case 6:
                                        t.depthFunc(516);
                                        break;
                                    case 7:
                                        t.depthFunc(517);
                                        break;
                                    default:
                                        t.depthFunc(515)
                                } else t.depthFunc(515);
                                n = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function() {
                            e = !1, r = n = i = null
                        }
                    }
                },
                g = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null,
                        o = null,
                        a = null,
                        c = null,
                        h = null,
                        u = null;
                    return {
                        setTest: function(t) {
                            e || (t ? s(2960) : l(2960))
                        },
                        setMask: function(n) {
                            i === n || e || (t.stencilMask(n), i = n)
                        },
                        setFunc: function(e, i, s) {
                            n === e && r === i && o === s || (t.stencilFunc(e, i, s), n = e, r = i, o = s)
                        },
                        setOp: function(e, i, n) {
                            a === e && c === i && h === n || (t.stencilOp(e, i, n), a = e, c = i, h = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            u !== e && (t.clearStencil(e), u = e)
                        },
                        reset: function() {
                            e = !1, u = h = c = a = o = r = n = i = null
                        }
                    }
                },
                v = t.getParameter(34921),
                y = new Uint8Array(v),
                _ = new Uint8Array(v),
                x = new Uint8Array(v),
                w = {},
                b = null,
                T = null,
                S = null,
                M = null,
                E = null,
                A = null,
                P = null,
                C = null,
                R = null,
                L = null,
                O = !1,
                k = null,
                D = null,
                I = null,
                N = null,
                z = null,
                F = t.getParameter(35661),
                B = !1;
            v = 0, -1 !== (v = t.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), B = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), B = 2 <= v);
            var H = null,
                U = {},
                G = new a,
                j = new a,
                V = {};
            return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), s(2929), m.setFunc(3), h(!1), u(1), s(2884), c(0), {
                buffers: {
                    color: f,
                    depth: m,
                    stencil: g
                },
                initAttributes: function() {
                    for (var t = 0, e = y.length; t < e; t++) y[t] = 0
                },
                enableAttribute: function(t) {
                    o(t, 0)
                },
                enableAttributeAndDivisor: o,
                disableUnusedAttributes: function() {
                    for (var e = 0, i = _.length; e !== i; ++e) _[e] !== y[e] && (t.disableVertexAttribArray(e), _[e] = 0)
                },
                enable: s,
                disable: l,
                getCompressedTextureFormats: function() {
                    if (null === b && (b = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                        for (var i = t.getParameter(34467), n = 0; n < i.length; n++) b.push(i[n]);
                    return b
                },
                useProgram: function(e) {
                    return T !== e && (t.useProgram(e), T = e, !0)
                },
                setBlending: c,
                setMaterial: function(t, e) {
                    2 === t.side ? l(2884) : s(2884);
                    var i = 1 === t.side;
                    e && (i = !i), h(i), 1 === t.blending && !1 === t.transparent ? c(0) : c(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), m.setFunc(t.depthFunc), m.setTest(t.depthTest), m.setMask(t.depthWrite), f.setMask(t.colorWrite), e = t.stencilWrite, g.setTest(e), e && (g.setMask(t.stencilWriteMask), g.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), g.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), d(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                },
                setFlipSided: h,
                setCullFace: u,
                setLineWidth: function(e) {
                    e !== I && (B && t.lineWidth(e), I = e)
                },
                setPolygonOffset: d,
                setScissorTest: function(t) {
                    t ? s(3089) : l(3089)
                },
                activeTexture: p,
                bindTexture: function(e, i) {
                    null === H && p();
                    var n = U[H];
                    void 0 === n && (n = {
                        type: void 0,
                        texture: void 0
                    }, U[H] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || V[e]), n.type = e, n.texture = i)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                texImage3D: function() {
                    try {
                        t.texImage3D.apply(t, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                },
                scissor: function(e) {
                    !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e))
                },
                viewport: function(e) {
                    !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), j.copy(e))
                },
                reset: function() {
                    for (var e = 0; e < _.length; e++) 1 === _[e] && (t.disableVertexAttribArray(e), _[e] = 0);
                    w = {}, H = b = null, U = {}, D = k = M = T = null, f.reset(), m.reset(), g.reset()
                }
            }
        }

        function Pe(t, e, i, n, r, o, s) {
            function a(t, e) {
                return A ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
            }

            function l(t, e, i, n) {
                var r = 1;
                if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), 1 > r || !0 === e) {
                    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) return e = (n = e ? Po.floorPowerOfTwo : Math.floor)(r * t.width), r = n(r * t.height), void 0 === M && (M = a(e, r)), (i = i ? a(e, r) : M).width = e, i.height = r, i.getContext("2d").drawImage(t, 0, 0, e, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + e + "x" + r + ")."), i;
                    "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ").")
                }
                return t
            }

            function c(t) {
                return Po.isPowerOfTwo(t.width) && Po.isPowerOfTwo(t.height)
            }

            function h(t, e) {
                return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
            }

            function u(e, i, r, o) {
                t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
            }

            function d(t, i) {
                if (!r.isWebGL2) return t;
                var n = t;
                return 6403 === t && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === t && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === t && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? e.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
            }

            function p(t) {
                return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
            }

            function f(e) {
                (e = e.target).removeEventListener("dispose", f);
                var i = n.get(e);
                void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture), n.remove(e)), e.isVideoTexture && E.delete(e), s.memory.textures--
            }

            function m(e) {
                (e = e.target).removeEventListener("dispose", m);
                var i = n.get(e),
                    r = n.get(e.texture);
                if (e) {
                    if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                        for (r = 0; 6 > r; r++) t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                    else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                    if (e.isWebGLMultiviewRenderTarget) {
                        t.deleteTexture(i.__webglColorTexture), t.deleteTexture(i.__webglDepthStencilTexture), s.memory.textures -= 2, r = 0;
                        for (var o = i.__webglViewFramebuffers.length; r < o; r++) t.deleteFramebuffer(i.__webglViewFramebuffers[r])
                    }
                    n.remove(e.texture), n.remove(e)
                }
                s.memory.textures--
            }

            function g(t, e) {
                var r = n.get(t);
                if (t.isVideoTexture) {
                    var o = s.render.frame;
                    E.get(t) !== o && (E.set(t, o), t.update())
                }
                if (0 < t.version && r.__version !== t.version)
                    if (void 0 === (o = t.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                    else {
                        if (!1 !== o.complete) return void w(r, t, e);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    } i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
            }

            function v(e, s) {
                if (6 === e.image.length) {
                    var a = n.get(e);
                    if (0 < e.version && a.__version !== e.version) {
                        x(a, e), i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture), t.pixelStorei(37440, e.flipY);
                        var p = e && e.isCompressedTexture;
                        s = e.image[0] && e.image[0].isDataTexture;
                        for (var f = [], m = 0; 6 > m; m++) f[m] = p || s ? s ? e.image[m].image : e.image[m] : l(e.image[m], !1, !0, r.maxCubemapSize);
                        var g = f[0],
                            v = c(g) || r.isWebGL2,
                            y = o.convert(e.format),
                            w = o.convert(e.type),
                            b = d(y, w);
                        if (_(34067, e, v), p) {
                            for (m = 0; 6 > m; m++) {
                                var T = f[m].mipmaps;
                                for (p = 0; p < T.length; p++) {
                                    var S = T[p];
                                    1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, p, b, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, p, b, S.width, S.height, 0, y, w, S.data)
                                }
                            }
                            a.__maxMipLevel = T.length - 1
                        } else {
                            for (T = e.mipmaps, m = 0; 6 > m; m++)
                                if (s)
                                    for (i.texImage2D(34069 + m, 0, b, f[m].width, f[m].height, 0, y, w, f[m].data), p = 0; p < T.length; p++) S = (S = T[p]).image[m].image, i.texImage2D(34069 + m, p + 1, b, S.width, S.height, 0, y, w, S.data);
                                else
                                    for (i.texImage2D(34069 + m, 0, b, y, w, f[m]), p = 0; p < T.length; p++) S = T[p], i.texImage2D(34069 + m, p + 1, b, y, w, S.image[m]);
                            a.__maxMipLevel = T.length
                        }
                        h(e, v) && u(34067, e, g.width, g.height), a.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture)
                }
            }

            function y(t, e) {
                i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
            }

            function _(i, s, a) {
                a ? (t.texParameteri(i, 10242, o.convert(s.wrapS)), t.texParameteri(i, 10243, o.convert(s.wrapT)), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, o.convert(s.wrapR)), t.texParameteri(i, 10240, o.convert(s.magFilter)), t.texParameteri(i, 10241, o.convert(s.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, p(s.magFilter)), t.texParameteri(i, 10241, p(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(a = e.get("EXT_texture_filter_anisotropic")) || 1015 === s.type && null === e.get("OES_texture_float_linear") || 1016 === s.type && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear")) || !(1 < s.anisotropy || n.get(s).__currentAnisotropy) || (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy)
            }

            function x(e, i) {
                void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", f), e.__webglTexture = t.createTexture(), s.memory.textures++)
            }

            function w(e, n, s) {
                var a = 3553;
                n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), x(e, n), i.activeTexture(33984 + s), i.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), s = (s = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === c(n.image);
                var p = c(s = l(n.image, s, !1, r.maxTextureSize)) || r.isWebGL2,
                    f = o.convert(n.format),
                    m = o.convert(n.type),
                    g = d(f, m);
                _(a, n, p);
                var v = n.mipmaps;
                if (n.isDepthTexture) {
                    if (g = 6402, 1015 === n.type) {
                        if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                        g = 36012
                    } else r.isWebGL2 && (g = 33189);
                    1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, null)
                } else if (n.isDataTexture)
                    if (0 < v.length && p) {
                        for (var y = 0, w = v.length; y < w; y++) a = v[y], i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
                        n.generateMipmaps = !1, e.__maxMipLevel = v.length - 1
                    } else i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, s.data), e.__maxMipLevel = 0;
                else if (n.isCompressedTexture) {
                    for (y = 0, w = v.length; y < w; y++) a = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
                    e.__maxMipLevel = v.length - 1
                } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), e.__maxMipLevel = 0;
                else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), e.__maxMipLevel = 0;
                else if (0 < v.length && p) {
                    for (y = 0, w = v.length; y < w; y++) a = v[y], i.texImage2D(3553, y, g, f, m, a);
                    n.generateMipmaps = !1, e.__maxMipLevel = v.length - 1
                } else i.texImage2D(3553, 0, g, f, m, s), e.__maxMipLevel = 0;
                h(n, p) && u(3553, n, s.width, s.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
            }

            function b(e, r, s, a) {
                var l = o.convert(r.texture.format),
                    c = o.convert(r.texture.type),
                    h = d(l, c);
                i.texImage2D(a, 0, h, r.width, r.height, 0, l, c, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
            }

            function T(e, i, n) {
                if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) n ? (n = S(i), t.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : t.renderbufferStorage(36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161, e);
                else if (i.depthBuffer && i.stencilBuffer) n ? (n = S(i), t.renderbufferStorageMultisample(36161, n, 35056, i.width, i.height)) : t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e);
                else {
                    e = d(e = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = S(i), t.renderbufferStorageMultisample(36161, n, e, i.width, i.height)) : t.renderbufferStorage(36161, e, i.width, i.height)
                }
                t.bindRenderbuffer(36161, null)
            }

            function S(t) {
                return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
            }
            var M, E = new WeakMap,
                A = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d"),
                P = 0,
                C = !1,
                R = !1;
            this.allocateTextureUnit = function() {
                var t = P;
                return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), P += 1, t
            }, this.resetTextureUnits = function() {
                P = 0
            }, this.setTexture2D = g, this.setTexture2DArray = function(t, e) {
                var r = n.get(t);
                0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture))
            }, this.setTexture3D = function(t, e) {
                var r = n.get(t);
                0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
            }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(a) {
                var l = n.get(a),
                    p = n.get(a.texture);
                a.addEventListener("dispose", m), p.__webglTexture = t.createTexture(), s.memory.textures++;
                var f = !0 === a.isWebGLRenderTargetCube,
                    v = !0 === a.isWebGLMultisampleRenderTarget,
                    y = !0 === a.isWebGLMultiviewRenderTarget,
                    x = c(a) || r.isWebGL2;
                if (f) {
                    l.__webglFramebuffer = [];
                    for (var w = 0; 6 > w; w++) l.__webglFramebuffer[w] = t.createFramebuffer()
                } else if (l.__webglFramebuffer = t.createFramebuffer(), v)
                    if (r.isWebGL2) {
                        l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer), v = o.convert(a.texture.format);
                        var M = o.convert(a.texture.type);
                        v = d(v, M), M = S(a), t.renderbufferStorageMultisample(36161, M, v, a.width, a.height), t.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), a.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), T(l.__webglDepthRenderbuffer, a, !0)), t.bindFramebuffer(36160, null)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                else if (y) {
                    w = a.width;
                    var E = a.height;
                    v = a.numViews, t.bindFramebuffer(36160, l.__webglFramebuffer);
                    var A = e.get("OVR_multiview2");
                    s.memory.textures += 2, M = t.createTexture(), t.bindTexture(35866, M), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 32856, w, E, v, 0, 6408, 5121, null), A.framebufferTextureMultiviewOVR(36160, 36064, M, 0, 0, v);
                    var P = t.createTexture();
                    for (t.bindTexture(35866, P), t.texParameteri(35866, 10240, 9728), t.texParameteri(35866, 10241, 9728), t.texImage3D(35866, 0, 35056, w, E, v, 0, 34041, 34042, null), A.framebufferTextureMultiviewOVR(36160, 33306, P, 0, 0, v), E = Array(v), w = 0; w < v; ++w) E[w] = t.createFramebuffer(), t.bindFramebuffer(36160, E[w]), t.framebufferTextureLayer(36160, 36064, M, 0, w);
                    l.__webglColorTexture = M, l.__webglDepthStencilTexture = P, l.__webglViewFramebuffers = E, t.bindFramebuffer(36160, null), t.bindTexture(35866, null)
                }
                if (f) {
                    for (i.bindTexture(34067, p.__webglTexture), _(34067, a.texture, x), w = 0; 6 > w; w++) b(l.__webglFramebuffer[w], a, 36064, 34069 + w);
                    h(a.texture, x) && u(34067, a.texture, a.width, a.height), i.bindTexture(34067, null)
                } else y || (i.bindTexture(3553, p.__webglTexture), _(3553, a.texture, x), b(l.__webglFramebuffer, a, 36064, 3553), h(a.texture, x) && u(3553, a.texture, a.width, a.height), i.bindTexture(3553, null));
                if (a.depthBuffer) {
                    if (l = n.get(a), p = !0 === a.isWebGLRenderTargetCube, a.depthTexture) {
                        if (p) throw Error("target.depthTexture not supported in Cube render targets");
                        if (a && a.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(36160, l.__webglFramebuffer), !a.depthTexture || !a.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        if (n.get(a.depthTexture).__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width, a.depthTexture.image.height = a.height, a.depthTexture.needsUpdate = !0), g(a.depthTexture, 0), l = n.get(a.depthTexture).__webglTexture, 1026 === a.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, l, 0);
                        else {
                            if (1027 !== a.depthTexture.format) throw Error("Unknown depthTexture format");
                            t.framebufferTexture2D(36160, 33306, 3553, l, 0)
                        }
                    } else if (p)
                        for (l.__webglDepthbuffer = [], p = 0; 6 > p; p++) t.bindFramebuffer(36160, l.__webglFramebuffer[p]), l.__webglDepthbuffer[p] = t.createRenderbuffer(), T(l.__webglDepthbuffer[p], a);
                    else t.bindFramebuffer(36160, l.__webglFramebuffer), l.__webglDepthbuffer = t.createRenderbuffer(), T(l.__webglDepthbuffer, a);
                    t.bindFramebuffer(36160, null)
                }
            }, this.updateRenderTargetMipmap = function(t) {
                var e = t.texture,
                    o = c(t) || r.isWebGL2;
                if (h(e, o)) {
                    o = t.isWebGLRenderTargetCube ? 34067 : 3553;
                    var s = n.get(e).__webglTexture;
                    i.bindTexture(o, s), u(o, e, t.width, t.height), i.bindTexture(o, null)
                }
            }, this.updateMultisampleRenderTarget = function(e) {
                if (e.isWebGLMultisampleRenderTarget)
                    if (r.isWebGL2) {
                        var i = n.get(e);
                        t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, i.__webglFramebuffer), i = e.width;
                        var o = e.height,
                            s = 16384;
                        e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728)
                    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
            }, this.safeSetTexture2D = function(t, e) {
                t && t.isWebGLRenderTarget && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), C = !0), t = t.texture), g(t, e)
            }, this.safeSetTextureCube = function(t, e) {
                t && t.isWebGLRenderTargetCube && (!1 === R && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), R = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? v(t, e) : y(t, e)
            }
        }

        function Ce(t, e, i) {
            return {
                convert: function(t) {
                    if (1e3 === t) return 10497;
                    if (1001 === t) return 33071;
                    if (1002 === t) return 33648;
                    if (1003 === t) return 9728;
                    if (1004 === t) return 9984;
                    if (1005 === t) return 9986;
                    if (1006 === t) return 9729;
                    if (1007 === t) return 9985;
                    if (1008 === t) return 9987;
                    if (1009 === t) return 5121;
                    if (1017 === t) return 32819;
                    if (1018 === t) return 32820;
                    if (1019 === t) return 33635;
                    if (1010 === t) return 5120;
                    if (1011 === t) return 5122;
                    if (1012 === t) return 5123;
                    if (1013 === t) return 5124;
                    if (1014 === t) return 5125;
                    if (1015 === t) return 5126;
                    if (1016 === t) {
                        if (i.isWebGL2) return 5131;
                        var n = e.get("OES_texture_half_float");
                        if (null !== n) return n.HALF_FLOAT_OES
                    }
                    if (1021 === t) return 6406;
                    if (1022 === t) return 6407;
                    if (1023 === t) return 6408;
                    if (1024 === t) return 6409;
                    if (1025 === t) return 6410;
                    if (1026 === t) return 6402;
                    if (1027 === t) return 34041;
                    if (1028 === t) return 6403;
                    if (100 === t) return 32774;
                    if (101 === t) return 32778;
                    if (102 === t) return 32779;
                    if (200 === t) return 0;
                    if (201 === t) return 1;
                    if (202 === t) return 768;
                    if (203 === t) return 769;
                    if (204 === t) return 770;
                    if (205 === t) return 771;
                    if (206 === t) return 772;
                    if (207 === t) return 773;
                    if (208 === t) return 774;
                    if (209 === t) return 775;
                    if (210 === t) return 776;
                    if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === t && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
                    if (103 === t || 104 === t) {
                        if (i.isWebGL2) {
                            if (103 === t) return 32775;
                            if (104 === t) return 32776
                        }
                        if (null !== (n = e.get("EXT_blend_minmax"))) {
                            if (103 === t) return n.MIN_EXT;
                            if (104 === t) return n.MAX_EXT
                        }
                    }
                    if (1020 === t) {
                        if (i.isWebGL2) return 34042;
                        if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                    }
                    return 0
                }
            }
        }

        function Re(t, e, i, n) {
            l.call(this, t, e, n), this.stencilBuffer = this.depthBuffer = !1, this.numViews = i
        }

        function Le(t, e) {
            function n(t) {
                return t.isArrayCamera ? t.cameras : (c[0] = t, c)
            }
            var r, s, a, l, c, u, d, p = t.extensions,
                f = t.properties,
                m = 0;
            this.isAvailable = function() {
                if (void 0 === d) {
                    var t = p.get("OVR_multiview2");
                    if (d = null !== t && !1 === e.getContextAttributes().antialias)
                        for (m = e.getParameter(t.MAX_VIEWS_OVR), r = new Re(0, 0, 2), u = new i, l = [], a = [], c = [], t = 0; t < m; t++) l[t] = new h, a[t] = new o
                }
                return d
            }, this.attachCamera = function(e) {
                if (!1 !== function(t) {
                        if (void 0 === t.isArrayCamera) return !0;
                        if ((t = t.cameras).length > m) return !1;
                        for (var e = 1, i = t.length; e < i; e++)
                            if (t[0].viewport.z !== t[e].viewport.z || t[0].viewport.w !== t[e].viewport.w) return !1;
                        return !0
                    }(e)) {
                    if ((s = t.getRenderTarget()) ? u.set(s.width, s.height) : t.getDrawingBufferSize(u), e.isArrayCamera) {
                        var i = e.cameras[0].viewport;
                        r.setSize(i.z, i.w), r.setNumViews(e.cameras.length)
                    } else r.setSize(u.x, u.y), r.setNumViews(2);
                    t.setRenderTarget(r)
                }
            }, this.detachCamera = function(i) {
                if (r === t.getRenderTarget()) {
                    t.setRenderTarget(s);
                    var n = r,
                        o = n.numViews,
                        a = f.get(n).__webglViewFramebuffers,
                        l = n.width;
                    if (n = n.height, i.isArrayCamera)
                        for (var c = 0; c < o; c++) {
                            var h = i.cameras[c].viewport,
                                d = h.x,
                                p = h.y,
                                m = d + h.z;
                            h = p + h.w, e.bindFramebuffer(36008, a[c]), e.blitFramebuffer(0, 0, l, n, d, p, m, h, 16384, 9728)
                        } else e.bindFramebuffer(36008, a[0]), e.blitFramebuffer(0, 0, l, n, 0, 0, u.x, u.y, 16384, 9728)
                }
            }, this.updateCameraProjectionMatricesUniform = function(t, i) {
                t = n(t);
                for (var r = 0; r < t.length; r++) l[r].copy(t[r].projectionMatrix);
                i.setValue(e, "projectionMatrices", l)
            }, this.updateCameraViewMatricesUniform = function(t, i) {
                t = n(t);
                for (var r = 0; r < t.length; r++) l[r].copy(t[r].matrixWorldInverse);
                i.setValue(e, "viewMatrices", l)
            }, this.updateObjectMatricesUniforms = function(t, i, r) {
                i = n(i);
                for (var o = 0; o < i.length; o++) l[o].multiplyMatrices(i[o].matrixWorldInverse, t.matrixWorld), a[o].getNormalMatrix(l[o]);
                r.setValue(e, "modelViewMatrices", l), r.setValue(e, "normalMatrices", a)
            }
        }

        function Oe() {
            p.call(this), this.type = "Group"
        }

        function ke(t) {
            $.call(this), this.cameras = t || []
        }

        function De(t, e, i) {
            Na.setFromMatrixPosition(e.matrixWorld), za.setFromMatrixPosition(i.matrixWorld);
            var n = Na.distanceTo(za),
                r = e.projectionMatrix.elements,
                o = i.projectionMatrix.elements,
                s = r[14] / (r[10] - 1);
            i = r[14] / (r[10] + 1);
            var a = (r[9] + 1) / r[5],
                l = (r[9] - 1) / r[5],
                c = (r[8] - 1) / r[0],
                h = (o[8] + 1) / o[0];
            r = s * c, o = s * h, c = (h = n / (-c + h)) * -c, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(c), t.translateZ(h), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = s + h, s = i + h, t.projectionMatrix.makePerspective(r - c, o + (n - c), a * i / s * e, l * i / s * e, e, s)
        }

        function Ie(t) {
            function e() {
                return null !== d && !0 === d.isPresenting
            }

            function o() {
                if (e()) {
                    var i = d.getEyeParameters("left");
                    l = 2 * i.renderWidth * y, c = i.renderHeight * y, E = t.getPixelRatio(), t.getSize(A), t.setDrawingBufferSize(l, c, 1), T.viewport.set(0, 0, l / 2, c), S.viewport.set(l / 2, 0, l / 2, c), C.start(), u.dispatchEvent({
                        type: "sessionstart"
                    })
                } else u.enabled && t.setDrawingBufferSize(A.width, A.height, E), C.stop(), u.dispatchEvent({
                    type: "sessionend"
                })
            }

            function s(t, e) {
                null !== e && 4 === e.length && t.set(e[0] * l, e[1] * c, e[2] * l, e[3] * c)
            }
            var l, c, u = this,
                d = null,
                p = null,
                f = null,
                m = [],
                g = new h,
                v = new h,
                y = 1,
                _ = "local-floor";
            "undefined" != typeof window && "VRFrameData" in window && (p = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
            var x = new h,
                w = new n,
                b = new r,
                T = new $;
            T.viewport = new a, T.layers.enable(1);
            var S = new $;
            S.viewport = new a, S.layers.enable(2);
            var M = new ke([T, S]);
            M.layers.enable(1), M.layers.enable(2);
            var E, A = new i,
                P = [];
            this.enabled = !1, this.getController = function(t) {
                var e = m[t];
                return void 0 === e && ((e = new Oe).matrixAutoUpdate = !1, e.visible = !1, m[t] = e), e
            }, this.getDevice = function() {
                return d
            }, this.setDevice = function(t) {
                void 0 !== t && (d = t), C.setContext(t)
            }, this.setFramebufferScaleFactor = function(t) {
                y = t
            }, this.setReferenceSpaceType = function(t) {
                _ = t
            }, this.setPoseTarget = function(t) {
                void 0 !== t && (f = t)
            }, this.getCamera = function(t) {
                var i = "local-floor" === _ ? 1.6 : 0;
                if (!1 === e()) return t.position.set(0, i, 0), t.rotation.set(0, 0, 0), t;
                if (d.depthNear = t.near, d.depthFar = t.far, d.getFrameData(p), "local-floor" === _) {
                    var n = d.stageParameters;
                    n ? g.fromArray(n.sittingToStandingTransform) : g.makeTranslation(0, i, 0)
                }
                i = p.pose, (n = null !== f ? f : t).matrix.copy(g), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (w.fromArray(i.orientation), n.quaternion.multiply(w)), null !== i.position && (w.setFromRotationMatrix(g), b.fromArray(i.position), b.applyQuaternion(w), n.position.add(b)), n.updateMatrixWorld(), T.near = t.near, S.near = t.near, T.far = t.far, S.far = t.far, T.matrixWorldInverse.fromArray(p.leftViewMatrix), S.matrixWorldInverse.fromArray(p.rightViewMatrix), v.getInverse(g), "local-floor" === _ && (T.matrixWorldInverse.multiply(v), S.matrixWorldInverse.multiply(v)), null !== (t = n.parent) && (x.getInverse(t.matrixWorld), T.matrixWorldInverse.multiply(x), S.matrixWorldInverse.multiply(x)), T.matrixWorld.getInverse(T.matrixWorldInverse), S.matrixWorld.getInverse(S.matrixWorldInverse), T.projectionMatrix.fromArray(p.leftProjectionMatrix), S.projectionMatrix.fromArray(p.rightProjectionMatrix), De(M, T, S), (t = d.getLayers()).length && (t = t[0], s(T.viewport, t.leftBounds), s(S.viewport, t.rightBounds));
                t: for (t = 0; t < m.length; t++) {
                    i = m[t];
                    e: {
                        n = t;
                        for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, a = 0, l = r.length; o < l; o++) {
                            var c = r[o];
                            if (c && ("Daydream Controller" === c.id || "Gear VR Controller" === c.id || "Oculus Go Controller" === c.id || "OpenVR Gamepad" === c.id || c.id.startsWith("Oculus Touch") || c.id.startsWith("HTC Vive Focus") || c.id.startsWith("Spatial Controller"))) {
                                if (a === n) {
                                    n = c;
                                    break e
                                }
                                a++
                            }
                        }
                        n = void 0
                    }
                    if (void 0 !== n && void 0 !== n.pose) {
                        if (null === n.pose) break t;
                        !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(g), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === P[t] && (P[t] = !1), P[t] !== n.buttons[r].pressed && (P[t] = n.buttons[r].pressed, !0 === P[t] ? i.dispatchEvent({
                            type: "selectstart"
                        }) : (i.dispatchEvent({
                            type: "selectend"
                        }), i.dispatchEvent({
                            type: "select"
                        })))
                    } else i.visible = !1
                }
                return M
            }, this.getStandingMatrix = function() {
                return g
            }, this.isPresenting = e;
            var C = new tt;
            this.setAnimationLoop = function(t) {
                C.setAnimationLoop(t), e() && C.start()
            }, this.submitFrame = function() {
                e() && d.submitFrame()
            }, this.dispose = function() {
                "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
            }, this.setFrameOfReferenceType = function() {
                console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
            }
        }

        function Ne(t, e) {
            function i() {
                return null !== c && null !== u
            }

            function n(t) {
                for (var e = 0; e < f.length; e++) m[e] === t.inputSource && f[e].dispatchEvent({
                    type: t.type
                })
            }

            function r() {
                t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), x.stop(), l.dispatchEvent({
                    type: "sessionend"
                })
            }

            function o(t) {
                u = t, x.setContext(c), x.start(), l.dispatchEvent({
                    type: "sessionstart"
                })
            }

            function s(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
            }
            var l = this,
                c = null,
                u = null,
                d = "local-floor",
                p = null,
                f = [],
                m = [],
                g = new $;
            g.layers.enable(1), g.viewport = new a;
            var v = new $;
            v.layers.enable(2), v.viewport = new a;
            var y = new ke([g, v]);
            y.layers.enable(1), y.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                var e = f[t];
                return void 0 === e && ((e = new Oe).matrixAutoUpdate = !1, e.visible = !1, f[t] = e), e
            }, this.setFramebufferScaleFactor = function() {}, this.setReferenceSpaceType = function(t) {
                d = t
            }, this.getSession = function() {
                return c
            }, this.setSession = function(t) {
                null !== (c = t) && (c.addEventListener("select", n), c.addEventListener("selectstart", n), c.addEventListener("selectend", n), c.addEventListener("end", r), c.updateRenderState({
                    baseLayer: new XRWebGLLayer(c, e)
                }), c.requestReferenceSpace(d).then(o), m = c.inputSources, c.addEventListener("inputsourceschange", function() {
                    m = c.inputSources, console.log(m);
                    for (var t = 0; t < f.length; t++) f[t].userData.inputSource = m[t]
                }))
            }, this.getCamera = function(t) {
                if (i()) {
                    var e = t.parent,
                        n = y.cameras;
                    s(y, e);
                    for (var r = 0; r < n.length; r++) s(n[r], e);
                    for (t.matrixWorld.copy(y.matrixWorld), r = 0, e = (t = t.children).length; r < e; r++) t[r].updateMatrixWorld(!0);
                    return De(y, g, v), y
                }
                return t
            }, this.isPresenting = i;
            var _ = null,
                x = new tt;
            x.setAnimationLoop(function(e, i) {
                if (null !== (p = i.getViewerPose(u))) {
                    var n = p.views,
                        r = c.renderState.baseLayer;
                    t.setFramebuffer(r.framebuffer);
                    for (var o = 0; o < n.length; o++) {
                        var s = n[o],
                            a = r.getViewport(s),
                            l = y.cameras[o];
                        l.matrix.fromArray(s.transform.inverse.matrix).getInverse(l.matrix), l.projectionMatrix.fromArray(s.projectionMatrix), l.viewport.set(a.x, a.y, a.width, a.height), 0 === o && y.matrix.copy(l.matrix)
                    }
                }
                for (o = 0; o < f.length; o++) n = f[o], (r = m[o]) && null !== (r = i.getPose(r.targetRaySpace, u)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
                _ && _(e)
            }), this.setAnimationLoop = function(t) {
                _ = t
            }, this.dispose = function() {}, this.getStandingMatrix = function() {
                return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new h
            }, this.getDevice = function() {
                console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
            }, this.setDevice = function() {
                console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
            }, this.setFrameOfReferenceType = function() {
                console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
            }, this.submitFrame = function() {}
        }

        function ze(t) {
            var e;

            function n() {
                R = new lt(It), !1 === (L = new st(It, R, t)).isWebGL2 && (R.get("WEBGL_depth_texture"), R.get("OES_texture_float"), R.get("OES_texture_half_float"), R.get("OES_texture_half_float_linear"), R.get("OES_standard_derivatives"), R.get("OES_element_index_uint"), R.get("ANGLE_instanced_arrays")), R.get("OES_texture_float_linear"), X = new Ce(It, R, L), (O = new Ae(It, R, X, L)).scissor(wt.copy(At).multiplyScalar(Mt).floor()), O.viewport(xt.copy(Et).multiplyScalar(Mt).floor()), k = new ut(It), D = new fe, I = new Pe(It, R, O, D, L, X, k), N = new et(It), z = new ct(It, N, k), F = new ft(It, z, N, k), j = new pt(It), B = new pe($, R, L), H = new ye, U = new Te, G = new rt($, O, F, S), W = new ot(It, R, k, L), q = new ht(It, R, k, L), k.programs = B.programs, $.capabilities = L, $.extensions = R, $.properties = D, $.renderLists = H, $.state = O, $.info = k
            }

            function o(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), Y = !0
            }

            function s() {
                console.log("THREE.WebGLRenderer: Context Restored."), Y = !1, n()
            }

            function l(t) {
                (t = t.target).removeEventListener("dispose", l), c(t), D.remove(t)
            }

            function c(t) {
                var e = D.get(t).program;
                t.program = void 0, void 0 !== e && B.releaseProgram(e)
            }

            function u(t, e, i, n) {
                for (var r = 0, o = t.length; r < o; r++) {
                    var s = t[r],
                        a = s.object,
                        l = s.geometry,
                        c = void 0 === n ? s.material : n;
                    if (s = s.group, i.isArrayCamera)
                        if (_t = i, Nt.enabled && zt.isAvailable()) d(a, e, i, l, c, s);
                        else
                            for (var h = i.cameras, u = 0, p = h.length; u < p; u++) {
                                var f = h[u];
                                a.layers.test(f.layers) && (O.viewport(xt.copy(f.viewport)), C.setupLights(f), d(a, e, f, l, c, s))
                            } else _t = null, d(a, e, i, l, c, s)
                }
            }

            function d(t, i, n, r, o, s) {
                if (t.onBeforeRender($, i, n, r, o, s), C = U.get(i, _t || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                    O.setMaterial(o);
                    var a = f(n, i.fog, o, t);
                    gt = e = null, vt = !1,
                        function(t, e) {
                            t.render(function(t) {
                                $.renderBufferImmediate(t, e)
                            })
                        }(t, a)
                } else $.renderBufferDirect(n, i.fog, r, o, t, s);
                t.onAfterRender($, i, n, r, o, s), C = U.get(i, _t || n)
            }

            function p(t, e, i) {
                var n = D.get(t),
                    r = C.state.lights,
                    o = r.state.version;
                i = B.getParameters(t, r.state, C.state.shadowsArray, e, Rt.numPlanes, Rt.numIntersection, i);
                var s = B.getProgramCode(t, i),
                    a = n.program,
                    h = !0;
                if (void 0 === a) t.addEventListener("dispose", l);
                else if (a.code !== s) c(t);
                else {
                    if (n.lightsStateVersion !== o) n.lightsStateVersion = o;
                    else if (void 0 !== i.shaderID) return;
                    h = !1
                }
                if (h && (i.shaderID ? (s = wa[i.shaderID], n.shader = {
                        name: t.type,
                        uniforms: V(s.uniforms),
                        vertexShader: s.vertexShader,
                        fragmentShader: s.fragmentShader
                    }) : n.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    }, t.onBeforeCompile(n.shader, $), s = B.getProgramCode(t, i), a = B.acquireProgram(t, n.shader, i, s), n.program = a, t.program = a), i = a.getAttributes(), t.morphTargets)
                    for (s = t.numSupportedMorphTargets = 0; s < $.maxMorphTargets; s++) 0 <= i["morphTarget" + s] && t.numSupportedMorphTargets++;
                if (t.morphNormals)
                    for (s = t.numSupportedMorphNormals = 0; s < $.maxMorphNormals; s++) 0 <= i["morphNormal" + s] && t.numSupportedMorphNormals++;
                i = n.shader.uniforms, (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = Rt.numPlanes, n.numIntersection = Rt.numIntersection, i.clippingPlanes = Rt.uniform), n.fog = e, n.needsLights = t.isMeshLambertMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights, n.lightsStateVersion = o, n.needsLights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), t = n.program.getUniforms(), t = Kt.seqWithValue(t.seq, i), n.uniformsList = t
            }

            function f(t, e, i, n) {
                I.resetTextureUnits();
                var r = D.get(i),
                    o = C.state.lights;
                Lt && (Ot || t !== yt) && Rt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === yt && i.id === mt), !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : r.needsLights && r.lightsStateVersion !== o.state.version ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === Rt.numPlanes && r.numIntersection === Rt.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (p(i, e, n), i.needsUpdate = !1);
                var s = !1,
                    a = !1,
                    l = !1,
                    c = (o = r.program).getUniforms(),
                    h = r.shader.uniforms;
                if (O.useProgram(o.program) && (l = a = s = !0), i.id !== mt && (mt = i.id, a = !0), (s || yt !== t) && (0 < o.numMultiviewViews ? zt.updateCameraProjectionMatricesUniform(t, c) : c.setValue(It, "projectionMatrix", t.projectionMatrix), L.logarithmicDepthBuffer && c.setValue(It, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), yt !== t && (yt = t, l = a = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (void 0 !== (s = c.map.cameraPosition) && s.setValue(It, Dt.setFromMatrixPosition(t.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && (0 < o.numMultiviewViews ? zt.updateCameraViewMatricesUniform(t, c) : c.setValue(It, "viewMatrix", t.matrixWorldInverse))), i.skinning && (c.setOptional(It, n, "bindMatrix"), c.setOptional(It, n, "bindMatrixInverse"), s = n.skeleton)) {
                    var u = s.bones;
                    if (L.floatVertexTextures) {
                        if (void 0 === s.boneTexture) {
                            u = Math.sqrt(4 * u.length), u = Po.ceilPowerOfTwo(u), u = Math.max(u, 4);
                            var d = new Float32Array(u * u * 4);
                            d.set(s.boneMatrices);
                            var f = new J(d, u, u, 1023, 1015);
                            s.boneMatrices = d, s.boneTexture = f, s.boneTextureSize = u
                        }
                        c.setValue(It, "boneTexture", s.boneTexture, I), c.setValue(It, "boneTextureSize", s.boneTextureSize)
                    } else c.setOptional(It, s, "boneMatrices")
                }
                return (a || r.receiveShadow !== n.receiveShadow) && (r.receiveShadow = n.receiveShadow, c.setValue(It, "receiveShadow", n.receiveShadow)), a && (c.setValue(It, "toneMappingExposure", $.toneMappingExposure), c.setValue(It, "toneMappingWhitePoint", $.toneMappingWhitePoint), r.needsLights && (a = l, h.ambientLightColor.needsUpdate = a, h.lightProbe.needsUpdate = a, h.directionalLights.needsUpdate = a, h.pointLights.needsUpdate = a, h.spotLights.needsUpdate = a, h.rectAreaLights.needsUpdate = a, h.hemisphereLights.needsUpdate = a), e && i.fog && (h.fogColor.value.copy(e.color), e.isFog ? (h.fogNear.value = e.near, h.fogFar.value = e.far) : e.isFogExp2 && (h.fogDensity.value = e.density)), i.isMeshBasicMaterial ? m(h, i) : i.isMeshLambertMaterial ? (m(h, i), i.emissiveMap && (h.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (m(h, i), i.isMeshToonMaterial ? (g(h, i), i.gradientMap && (h.gradientMap.value = i.gradientMap)) : g(h, i)) : i.isMeshStandardMaterial ? (m(h, i), i.isMeshPhysicalMaterial ? (v(h, i), h.reflectivity.value = i.reflectivity, h.clearcoat.value = i.clearcoat, h.clearcoatRoughness.value = i.clearcoatRoughness, i.sheen && h.sheen.value.copy(i.sheen), i.clearcoatNormalMap && (h.clearcoatNormalScale.value.copy(i.clearcoatNormalScale), h.clearcoatNormalMap.value = i.clearcoatNormalMap, 1 === i.side && h.clearcoatNormalScale.value.negate()), h.transparency.value = i.transparency) : v(h, i)) : i.isMeshMatcapMaterial ? (m(h, i), i.matcap && (h.matcap.value = i.matcap), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (m(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (m(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias), h.referencePosition.value.copy(i.referencePosition), h.nearDistance.value = i.nearDistance, h.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (m(h, i), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, i.isLineDashedMaterial && (h.dashSize.value = i.dashSize, h.totalSize.value = i.dashSize + i.gapSize, h.scale.value = i.scale)) : i.isPointsMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.size.value = i.size * Mt, h.scale.value = .5 * St, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.rotation.value = i.rotation, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (h.color.value.copy(i.color), h.opacity.value = i.opacity), void 0 !== h.ltc_1 && (h.ltc_1.value = xa.LTC_1), void 0 !== h.ltc_2 && (h.ltc_2.value = xa.LTC_2), Kt.upload(It, r.uniformsList, h, I)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Kt.upload(It, r.uniformsList, h, I), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && c.setValue(It, "center", n.center), 0 < o.numMultiviewViews ? zt.updateObjectMatricesUniforms(n, t, c) : (c.setValue(It, "modelViewMatrix", n.modelViewMatrix), c.setValue(It, "normalMatrix", n.normalMatrix)), c.setValue(It, "modelMatrix", n.matrixWorld), o
            }

            function m(t, e) {
                if (t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = D.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map) var i = e.map;
                else e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap);
                void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
            }

            function g(t, e) {
                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function v(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }
            var y = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                _ = void 0 !== t.context ? t.context : null,
                x = void 0 !== t.alpha && t.alpha,
                w = void 0 === t.depth || t.depth,
                b = void 0 === t.stencil || t.stencil,
                T = void 0 !== t.antialias && t.antialias,
                S = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                M = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                E = void 0 !== t.powerPreference ? t.powerPreference : "default",
                A = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                P = null,
                C = null;
            this.domElement = y, this.debug = {
                checkShaderErrors: !0
            }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var R, L, O, k, D, I, N, z, F, B, H, U, G, j, W, q, X, $ = this,
                Y = !1,
                Z = null,
                Q = 0,
                it = 0,
                nt = null,
                dt = null,
                mt = -1,
                gt = e = null,
                vt = !1,
                yt = null,
                _t = null,
                xt = new a,
                wt = new a,
                bt = null,
                Tt = y.width,
                St = y.height,
                Mt = 1,
                Et = new a(0, 0, Tt, St),
                At = new a(0, 0, Tt, St),
                Pt = !1,
                Ct = new K,
                Rt = new at,
                Lt = !1,
                Ot = !1,
                kt = new h,
                Dt = new r;
            try {
                x = {
                    alpha: x,
                    depth: w,
                    stencil: b,
                    antialias: T,
                    premultipliedAlpha: S,
                    preserveDrawingBuffer: M,
                    powerPreference: E,
                    failIfMajorPerformanceCaveat: A,
                    xrCompatible: !0
                }, y.addEventListener("webglcontextlost", o, !1), y.addEventListener("webglcontextrestored", s, !1);
                var It = _ || y.getContext("webgl", x) || y.getContext("experimental-webgl", x);
                if (null === It) {
                    if (null !== y.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                    throw Error("Error creating WebGL context.")
                }
                void 0 === It.getShaderPrecisionFormat && (It.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }
            n();
            var Nt = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Ne($, It) : new Ie($);
            this.vr = Nt;
            var zt = new Le($, It),
                Ft = new Ee($, F, L.maxTextureSize);
            this.shadowMap = Ft, this.getContext = function() {
                return It
            }, this.getContextAttributes = function() {
                return It.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = R.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function() {
                var t = R.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function() {
                return Mt
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (Mt = t, this.setSize(Tt, St, !1))
            }, this.getSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new i), t.set(Tt, St)
            }, this.setSize = function(t, e, i) {
                Nt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Tt = t, St = e, y.width = Math.floor(t * Mt), y.height = Math.floor(e * Mt), !1 !== i && (y.style.width = t + "px", y.style.height = e + "px"), this.setViewport(0, 0, t, e))
            }, this.getDrawingBufferSize = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new i), t.set(Tt * Mt, St * Mt).floor()
            }, this.setDrawingBufferSize = function(t, e, i) {
                Tt = t, St = e, Mt = i, y.width = Math.floor(t * i), y.height = Math.floor(e * i), this.setViewport(0, 0, t, e)
            }, this.getCurrentViewport = function(t) {
                return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new a), t.copy(xt)
            }, this.getViewport = function(t) {
                return t.copy(Et)
            }, this.setViewport = function(t, e, i, n) {
                t.isVector4 ? Et.set(t.x, t.y, t.z, t.w) : Et.set(t, e, i, n), O.viewport(xt.copy(Et).multiplyScalar(Mt).floor())
            }, this.getScissor = function(t) {
                return t.copy(At)
            }, this.setScissor = function(t, e, i, n) {
                t.isVector4 ? At.set(t.x, t.y, t.z, t.w) : At.set(t, e, i, n), O.scissor(wt.copy(At).multiplyScalar(Mt).floor())
            }, this.getScissorTest = function() {
                return Pt
            }, this.setScissorTest = function(t) {
                O.setScissorTest(Pt = t)
            }, this.getClearColor = function() {
                return G.getClearColor()
            }, this.setClearColor = function() {
                G.setClearColor.apply(G, arguments)
            }, this.getClearAlpha = function() {
                return G.getClearAlpha()
            }, this.setClearAlpha = function() {
                G.setClearAlpha.apply(G, arguments)
            }, this.clear = function(t, e, i) {
                var n = 0;
                (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), It.clear(n)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.dispose = function() {
                y.removeEventListener("webglcontextlost", o, !1), y.removeEventListener("webglcontextrestored", s, !1), H.dispose(), U.dispose(), D.dispose(), F.dispose(), Nt.dispose(), Ht.stop()
            }, this.renderBufferImmediate = function(t, e) {
                O.initAttributes();
                var i = D.get(t);
                t.hasPositions && !i.position && (i.position = It.createBuffer()), t.hasNormals && !i.normal && (i.normal = It.createBuffer()), t.hasUvs && !i.uv && (i.uv = It.createBuffer()), t.hasColors && !i.color && (i.color = It.createBuffer()), e = e.getAttributes(), t.hasPositions && (It.bindBuffer(34962, i.position), It.bufferData(34962, t.positionArray, 35048), O.enableAttribute(e.position), It.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)), t.hasNormals && (It.bindBuffer(34962, i.normal), It.bufferData(34962, t.normalArray, 35048), O.enableAttribute(e.normal), It.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (It.bindBuffer(34962, i.uv), It.bufferData(34962, t.uvArray, 35048), O.enableAttribute(e.uv), It.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)), t.hasColors && (It.bindBuffer(34962, i.color), It.bufferData(34962, t.colorArray, 35048), O.enableAttribute(e.color), It.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)), O.disableUnusedAttributes(), It.drawArrays(4, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function(t, i, n, r, o, s) {
                var a = o.isMesh && 0 > o.matrixWorld.determinant();
                O.setMaterial(r, a);
                var l = f(t, i, r, o),
                    c = !1;
                e === n.id && gt === l.id && vt === (!0 === r.wireframe) || (e = n.id, gt = l.id, vt = !0 === r.wireframe, c = !0), o.morphTargetInfluences && (j.update(o, n, r, l), c = !0), a = n.index;
                var h = n.attributes.position;
                if (i = 1, !0 === r.wireframe && (a = z.getWireframeAttribute(n), i = 2), t = W, null !== a) {
                    var u = N.get(a);
                    (t = q).setIndex(u)
                }
                if (c) {
                    if (!1 !== L.isWebGL2 || !o.isInstancedMesh && !n.isInstancedBufferGeometry || null !== R.get("ANGLE_instanced_arrays")) {
                        O.initAttributes(), c = n.attributes, l = l.getAttributes();
                        var d = r.defaultAttributeValues;
                        for (T in l) {
                            var p = l[T];
                            if (0 <= p) {
                                var m = c[T];
                                if (void 0 !== m) {
                                    var g = m.normalized,
                                        v = m.itemSize,
                                        y = N.get(m);
                                    if (void 0 !== y) {
                                        var _ = y.buffer,
                                            x = y.type;
                                        if (y = y.bytesPerElement, m.isInterleavedBufferAttribute) {
                                            var w = m.data,
                                                b = w.stride;
                                            m = m.offset, w && w.isInstancedInterleavedBuffer ? (O.enableAttributeAndDivisor(p, w.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : O.enableAttribute(p), It.bindBuffer(34962, _), It.vertexAttribPointer(p, v, x, g, b * y, m * y)
                                        } else m.isInstancedBufferAttribute ? (O.enableAttributeAndDivisor(p, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : O.enableAttribute(p), It.bindBuffer(34962, _), It.vertexAttribPointer(p, v, x, g, 0, 0)
                                    }
                                } else if ("instanceMatrix" === T) void 0 !== (y = N.get(o.instanceMatrix)) && (_ = y.buffer, x = y.type, O.enableAttributeAndDivisor(p + 0, 1), O.enableAttributeAndDivisor(p + 1, 1), O.enableAttributeAndDivisor(p + 2, 1), O.enableAttributeAndDivisor(p + 3, 1), It.bindBuffer(34962, _), It.vertexAttribPointer(p + 0, 4, x, !1, 64, 0), It.vertexAttribPointer(p + 1, 4, x, !1, 64, 16), It.vertexAttribPointer(p + 2, 4, x, !1, 64, 32), It.vertexAttribPointer(p + 3, 4, x, !1, 64, 48));
                                else if (void 0 !== d && void 0 !== (g = d[T])) switch (g.length) {
                                    case 2:
                                        It.vertexAttrib2fv(p, g);
                                        break;
                                    case 3:
                                        It.vertexAttrib3fv(p, g);
                                        break;
                                    case 4:
                                        It.vertexAttrib4fv(p, g);
                                        break;
                                    default:
                                        It.vertexAttrib1fv(p, g)
                                }
                            }
                        }
                        O.disableUnusedAttributes()
                    }
                    null !== a && It.bindBuffer(34963, u.buffer)
                }
                u = 1 / 0, null !== a ? u = a.count : void 0 !== h && (u = h.count), a = n.drawRange.start * i, h = null !== s ? s.start * i : 0;
                var T = Math.max(a, h);
                if (0 !== (s = Math.max(0, Math.min(u, a + n.drawRange.count * i, h + (null !== s ? s.count * i : 1 / 0)) - 1 - T + 1))) {
                    if (o.isMesh)
                        if (!0 === r.wireframe) O.setLineWidth(r.wireframeLinewidth * (null === nt ? Mt : 1)), t.setMode(1);
                        else switch (o.drawMode) {
                            case 0:
                                t.setMode(4);
                                break;
                            case 1:
                                t.setMode(5);
                                break;
                            case 2:
                                t.setMode(6)
                        } else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), O.setLineWidth(r * (null === nt ? Mt : 1)), o.isLineSegments ? t.setMode(1) : o.isLineLoop ? t.setMode(2) : t.setMode(3)) : o.isPoints ? t.setMode(0) : o.isSprite && t.setMode(4);
                    o.isInstancedMesh ? t.renderInstances(n, T, s, o.count) : n.isInstancedBufferGeometry ? t.renderInstances(n, T, s, n.maxInstancedCount) : t.render(T, s)
                }
            }, this.compile = function(t, e) {
                (C = U.get(t, e)).init(), t.traverse(function(t) {
                    t.isLight && (C.pushLight(t), t.castShadow && C.pushShadow(t))
                }), C.setupLights(e), t.traverse(function(e) {
                    if (e.material)
                        if (Array.isArray(e.material))
                            for (var i = 0; i < e.material.length; i++) p(e.material[i], t.fog, e);
                        else p(e.material, t.fog, e)
                })
            };
            var Bt = null,
                Ht = new tt;
            Ht.setAnimationLoop(function(t) {
                Nt.isPresenting() || Bt && Bt(t)
            }), "undefined" != typeof window && Ht.setContext(window), this.setAnimationLoop = function(t) {
                Bt = t, Nt.setAnimationLoop(t), Ht.start()
            }, this.render = function(t, i, n, r) {
                if (void 0 !== n) {
                    console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
                    var o = n
                }
                if (void 0 !== r) {
                    console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
                    var s = r
                }
                i && i.isCamera ? Y || (gt = e = null, vt = !1, mt = -1, yt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), Nt.enabled && (i = Nt.getCamera(i)), (C = U.get(t, i)).init(), t.onBeforeRender($, t, i, o || nt), kt.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), Ct.setFromMatrix(kt), Ot = this.localClippingEnabled, Lt = Rt.init(this.clippingPlanes, Ot, i), (P = H.get(t, i)).init(), function t(e, i, n, r) {
                    if (!1 !== e.visible) {
                        if (e.layers.test(i.layers))
                            if (e.isGroup) n = e.renderOrder;
                            else if (e.isLOD) !0 === e.autoUpdate && e.update(i);
                        else if (e.isLight) C.pushLight(e), e.castShadow && C.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || Ct.intersectsSprite(e)) {
                                r && Dt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(kt);
                                var o = F.update(e),
                                    s = e.material;
                                s.visible && P.push(e, o, s, n, Dt.z, null)
                            }
                        } else if (e.isImmediateRenderObject) r && Dt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(kt), P.push(e, null, e.material, n, Dt.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== k.render.frame && (e.skeleton.update(), e.skeleton.frame = k.render.frame), !e.frustumCulled || Ct.intersectsObject(e)))
                            if (r && Dt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(kt), o = F.update(e), s = e.material, Array.isArray(s))
                                for (var a = o.groups, l = 0, c = a.length; l < c; l++) {
                                    var h = a[l],
                                        u = s[h.materialIndex];
                                    u && u.visible && P.push(e, o, u, n, Dt.z, h)
                                } else s.visible && P.push(e, o, s, n, Dt.z, null);
                        for (l = 0, c = (e = e.children).length; l < c; l++) t(e[l], i, n, r)
                    }
                }(t, i, 0, $.sortObjects), !0 === $.sortObjects && P.sort(), Lt && Rt.beginShadows(), Ft.render(C.state.shadowsArray, t, i), C.setupLights(i), Lt && Rt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), Nt.enabled && zt.isAvailable() && zt.attachCamera(i), G.render(P, t, i, s), n = P.opaque, r = P.transparent, t.overrideMaterial ? (o = t.overrideMaterial, n.length && u(n, t, i, o), r.length && u(r, t, i, o)) : (n.length && u(n, t, i), r.length && u(r, t, i)), t.onAfterRender($, t, i), null !== nt && (I.updateRenderTargetMipmap(nt), I.updateMultisampleRenderTarget(nt)), O.buffers.depth.setTest(!0), O.buffers.depth.setMask(!0), O.buffers.color.setMask(!0), O.setPolygonOffset(!1), Nt.enabled && (zt.isAvailable() && zt.detachCamera(i), Nt.submitFrame()), C = P = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
            }, this.setFramebuffer = function(t) {
                Z !== t && It.bindFramebuffer(36160, t), Z = t
            }, this.getActiveCubeFace = function() {
                return Q
            }, this.getActiveMipmapLevel = function() {
                return it
            }, this.getRenderTarget = function() {
                return nt
            }, this.setRenderTarget = function(t, e, i) {
                nt = t, Q = e, it = i, t && void 0 === D.get(t).__webglFramebuffer && I.setupRenderTarget(t);
                var n = Z,
                    r = !1;
                t ? (n = D.get(t).__webglFramebuffer, t.isWebGLRenderTargetCube ? (n = n[e || 0], r = !0) : n = t.isWebGLMultisampleRenderTarget ? D.get(t).__webglMultisampledFramebuffer : n, xt.copy(t.viewport), wt.copy(t.scissor), bt = t.scissorTest) : (xt.copy(Et).multiplyScalar(Mt).floor(), wt.copy(At).multiplyScalar(Mt).floor(), bt = Pt), dt !== n && (It.bindFramebuffer(36160, n), dt = n), O.viewport(xt), O.scissor(wt), O.setScissorTest(bt), r && (t = D.get(t.texture), It.framebufferTexture2D(36160, 36064, 34069 + (e || 0), t.__webglTexture, i || 0))
            }, this.readRenderTargetPixels = function(t, e, i, n, r, o, s) {
                if (t && t.isWebGLRenderTarget) {
                    var a = D.get(t).__webglFramebuffer;
                    if (t.isWebGLRenderTargetCube && void 0 !== s && (a = a[s]), a) {
                        s = !1, a !== dt && (It.bindFramebuffer(36160, a), s = !0);
                        try {
                            var l = t.texture,
                                c = l.format,
                                h = l.type;
                            1023 !== c && X.convert(c) !== It.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || X.convert(h) === It.getParameter(35738) || 1015 === h && (L.isWebGL2 || R.get("OES_texture_float") || R.get("WEBGL_color_buffer_float")) || 1016 === h && (L.isWebGL2 ? R.get("EXT_color_buffer_float") : R.get("EXT_color_buffer_half_float")) ? 36053 === It.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && It.readPixels(e, i, n, r, X.convert(c), X.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            s && It.bindFramebuffer(36160, dt)
                        }
                    }
                } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
            }, this.copyFramebufferToTexture = function(t, e, i) {
                var n = e.image.width,
                    r = e.image.height,
                    o = X.convert(e.format);
                I.setTexture2D(e, 0), It.copyTexImage2D(3553, i || 0, o, t.x, t.y, n, r, 0)
            }, this.copyTextureToTexture = function(t, e, i, n) {
                var r = e.image.width,
                    o = e.image.height,
                    s = X.convert(i.format),
                    a = X.convert(i.type);
                I.setTexture2D(i, 0), e.isDataTexture ? It.texSubImage2D(3553, n || 0, t.x, t.y, r, o, s, a, e.image.data) : It.texSubImage2D(3553, n || 0, t.x, t.y, s, a, e.image)
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }

        function Fe(t, e) {
            this.name = "", this.color = new x(t), this.density = void 0 !== e ? e : 25e-5
        }

        function Be(t, e, i) {
            this.name = "", this.color = new x(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function He(t, e) {
            this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function Ue(t, e, i, n) {
            this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function Ge(t) {
            M.call(this), this.type = "SpriteMaterial", this.color = new x(16777215), this.map = null, this.rotation = 0, this.transparent = this.sizeAttenuation = !0, this.setValues(t)
        }

        function je(t) {
            if (p.call(this), this.type = "Sprite", void 0 === Fa) {
                Fa = new B;
                var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
                e = new He(e, 5), Fa.setIndex([0, 1, 2, 0, 2, 3]), Fa.addAttribute("position", new Ue(e, 3, 0, !1)), Fa.addAttribute("uv", new Ue(e, 2, 3, !1))
            }
            this.geometry = Fa, this.material = void 0 !== t ? t : new Ge, this.center = new i(.5, .5)
        }

        function Ve(t, e, i, n, r, o) {
            Ga.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (ja.x = o * Ga.x - r * Ga.y, ja.y = r * Ga.x + o * Ga.y) : ja.copy(Ga), t.copy(e), t.x += ja.x, t.y += ja.y, t.applyMatrix4(Va)
        }

        function We() {
            p.call(this), this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            }), this.autoUpdate = !0
        }

        function qe(t, e) {
            t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), H.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new h, this.bindMatrixInverse = new h
        }

        function Xe(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else
                for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new h)
        }

        function $e() {
            p.call(this), this.type = "Bone"
        }

        function Ye(t, e, i) {
            H.call(this, t, e), this.instanceMatrix = new A(new Float32Array(16 * i), 16), this.count = i
        }

        function Ze(t) {
            M.call(this), this.type = "LineBasicMaterial", this.color = new x(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.setValues(t)
        }

        function Je(t, e, i) {
            1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), p.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new B, this.material = void 0 !== e ? e : new Ze({
                color: 16777215 * Math.random()
            })
        }

        function Qe(t, e) {
            Je.call(this, t, e), this.type = "LineSegments"
        }

        function Ke(t, e) {
            Je.call(this, t, e), this.type = "LineLoop"
        }

        function ti(t) {
            M.call(this), this.type = "PointsMaterial", this.color = new x(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
        }

        function ei(t, e) {
            p.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new B, this.material = void 0 !== e ? e : new ti({
                color: 16777215 * Math.random()
            }), this.updateMorphTargets()
        }

        function ii(t, e, i, n, o, s, a) {
            var l = cl.distanceSqToPoint(t);
            l < i && (i = new r, cl.closestPointToPoint(t, i), i.applyMatrix4(n), (t = o.ray.origin.distanceTo(i)) < o.near || t > o.far || s.push({
                distance: t,
                distanceToRay: Math.sqrt(l),
                point: i,
                index: e,
                face: null,
                object: a
            }))
        }

        function ni(t, e, i, n, r, o, a, l, c) {
            s.call(this, t, e, i, n, r, o, a, l, c), this.format = void 0 !== a ? a : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
        }

        function ri(t, e, i, n, r, o, a, l, c, h, u, d) {
            s.call(this, null, o, a, l, c, h, n, r, u, d), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1
        }

        function oi(t, e, i, n, r, o, a, l, c) {
            s.call(this, t, e, i, n, r, o, a, l, c), this.needsUpdate = !0
        }

        function si(t, e, i, n, r, o, a, l, c, h) {
            if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), s.call(this, null, n, r, o, a, l, h, i, c), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
        }

        function ai(t) {
            B.call(this), this.type = "WireframeGeometry";
            var e, i, n, o = [],
                s = [0, 0],
                a = {},
                l = ["a", "b", "c"];
            if (t && t.isGeometry) {
                var c = t.faces,
                    h = 0;
                for (i = c.length; h < i; h++) {
                    var u = c[h];
                    for (e = 0; 3 > e; e++) {
                        var d = u[l[e]],
                            p = u[l[(e + 1) % 3]];
                        s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
                            index1: s[0],
                            index2: s[1]
                        })
                    }
                }
                for (d in a) h = a[d], l = t.vertices[h.index1], o.push(l.x, l.y, l.z), l = t.vertices[h.index2], o.push(l.x, l.y, l.z)
            } else if (t && t.isBufferGeometry)
                if (l = new r, null !== t.index) {
                    c = t.attributes.position, u = t.index;
                    var f = t.groups;
                    for (0 === f.length && (f = [{
                            start: 0,
                            count: u.count,
                            materialIndex: 0
                        }]), t = 0, n = f.length; t < n; ++t)
                        for (e = (h = f[t]).start, i = h.count, h = e, i = e + i; h < i; h += 3)
                            for (e = 0; 3 > e; e++) d = u.getX(h + e), p = u.getX(h + (e + 1) % 3), s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
                                index1: s[0],
                                index2: s[1]
                            });
                    for (d in a) h = a[d], l.fromBufferAttribute(c, h.index1), o.push(l.x, l.y, l.z), l.fromBufferAttribute(c, h.index2), o.push(l.x, l.y, l.z)
                } else
                    for (h = 0, i = (c = t.attributes.position).count / 3; h < i; h++)
                        for (e = 0; 3 > e; e++) a = 3 * h + e, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z), a = 3 * h + (e + 1) % 3, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z);
            this.addAttribute("position", new I(o, 3))
        }

        function li(t, e, i) {
            j.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new ci(t, e, i)), this.mergeVertices()
        }

        function ci(t, e, i) {
            B.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            var n, o, s = [],
                a = [],
                l = [],
                c = [],
                h = new r,
                u = new r,
                d = new r,
                p = new r,
                f = new r;
            3 > t.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
            var m = e + 1;
            for (n = 0; n <= i; n++) {
                var g = n / i;
                for (o = 0; o <= e; o++) {
                    var v = o / e;
                    t(v, g, u), a.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (t(v - 1e-5, g, d), p.subVectors(u, d)) : (t(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (t(v, g - 1e-5, d), f.subVectors(u, d)) : (t(v, g + 1e-5, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), l.push(h.x, h.y, h.z), c.push(v, g)
                }
            }
            for (n = 0; n < i; n++)
                for (o = 0; o < e; o++) t = n * m + o + 1, h = (n + 1) * m + o + 1, u = (n + 1) * m + o, s.push(n * m + o, t, u), s.push(t, h, u);
            this.setIndex(s), this.addAttribute("position", new I(a, 3)), this.addAttribute("normal", new I(l, 3)), this.addAttribute("uv", new I(c, 2))
        }

        function hi(t, e, i, n) {
            j.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, this.fromBufferGeometry(new ui(t, e, i, n)), this.mergeVertices()
        }

        function ui(t, e, n, o) {
            function s(t) {
                c.push(t.x, t.y, t.z)
            }

            function a(e, i) {
                e *= 3, i.x = t[e + 0], i.y = t[e + 1], i.z = t[e + 2]
            }

            function l(t, e, i, n) {
                0 > n && 1 === t.x && (h[e] = t.x - 1), 0 === i.x && 0 === i.z && (h[e] = n / 2 / Math.PI + .5)
            }
            B.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: o
            }, n = n || 1;
            var c = [],
                h = [];
            ! function(t) {
                for (var i = new r, n = new r, o = new r, l = 0; l < e.length; l += 3) {
                    a(e[l + 0], i), a(e[l + 1], n), a(e[l + 2], o);
                    var c, h, u = i,
                        d = n,
                        p = o,
                        f = Math.pow(2, t),
                        m = [];
                    for (h = 0; h <= f; h++) {
                        m[h] = [];
                        var g = u.clone().lerp(p, h / f),
                            v = d.clone().lerp(p, h / f),
                            y = f - h;
                        for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y)
                    }
                    for (h = 0; h < f; h++)
                        for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (s(m[h][u + 1]), s(m[h + 1][u]), s(m[h][u])) : (s(m[h][u + 1]), s(m[h + 1][u + 1]), s(m[h + 1][u]))
                }
            }(o = o || 0),
            function(t) {
                for (var e = new r, i = 0; i < c.length; i += 3) e.x = c[i + 0], e.y = c[i + 1], e.z = c[i + 2], e.normalize().multiplyScalar(t), c[i + 0] = e.x, c[i + 1] = e.y, c[i + 2] = e.z
            }(n),
            function() {
                for (var t = new r, e = 0; e < c.length; e += 3) t.x = c[e + 0], t.y = c[e + 1], t.z = c[e + 2], h.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
                t = new r, e = new r;
                for (var n = new r, o = new r, s = new i, a = new i, u = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
                    t.set(c[d + 0], c[d + 1], c[d + 2]), e.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), s.set(h[p + 0], h[p + 1]), a.set(h[p + 2], h[p + 3]), u.set(h[p + 4], h[p + 5]), o.copy(t).add(e).add(n).divideScalar(3);
                    var f = Math.atan2(o.z, -o.x);
                    l(s, p + 0, t, f), l(a, p + 2, e, f), l(u, p + 4, n, f)
                }
                for (t = 0; t < h.length; t += 6) e = h[t + 0], n = h[t + 2], o = h[t + 4], s = Math.min(e, n, o), .9 < Math.max(e, n, o) && .1 > s && (.2 > e && (h[t + 0] += 1), .2 > n && (h[t + 2] += 1), .2 > o && (h[t + 4] += 1))
            }(), this.addAttribute("position", new I(c, 3)), this.addAttribute("normal", new I(c.slice(), 3)), this.addAttribute("uv", new I(h, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals()
        }

        function di(t, e) {
            j.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new pi(t, e)), this.mergeVertices()
        }

        function pi(t, e) {
            ui.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function fi(t, e) {
            j.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new mi(t, e)), this.mergeVertices()
        }

        function mi(t, e) {
            ui.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function gi(t, e) {
            j.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new vi(t, e)), this.mergeVertices()
        }

        function vi(t, e) {
            var i = (1 + Math.sqrt(5)) / 2;
            ui.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function yi(t, e) {
            j.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new _i(t, e)), this.mergeVertices()
        }

        function _i(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = 1 / i;
            ui.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function xi(t, e, i, n, r, o) {
            j.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), t = new wi(t, e, i, n, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices()
        }

        function wi(t, e, n, o, s) {
            function a(i) {
                f = t.getPointAt(i / e, f);
                var r = l.normals[i];
                for (i = l.binormals[i], h = 0; h <= o; h++) {
                    var s = h / o * Math.PI * 2,
                        a = Math.sin(s);
                    s = -Math.cos(s), d.x = s * r.x + a * i.x, d.y = s * r.y + a * i.y, d.z = s * r.z + a * i.z, d.normalize(), g.push(d.x, d.y, d.z), u.x = f.x + n * d.x, u.y = f.y + n * d.y, u.z = f.z + n * d.z, m.push(u.x, u.y, u.z)
                }
            }
            B.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: o,
                closed: s
            }, e = e || 64, n = n || 1, o = o || 8, s = s || !1;
            var l = t.computeFrenetFrames(e, s);
            this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
            var c, h, u = new r,
                d = new r,
                p = new i,
                f = new r,
                m = [],
                g = [],
                v = [],
                y = [];
            for (c = 0; c < e; c++) a(c);
            for (a(!1 === s ? e : 0), c = 0; c <= e; c++)
                for (h = 0; h <= o; h++) p.x = c / e, p.y = h / o, v.push(p.x, p.y);
            ! function() {
                for (h = 1; h <= e; h++)
                    for (c = 1; c <= o; c++) {
                        var t = (o + 1) * h + (c - 1),
                            i = (o + 1) * h + c,
                            n = (o + 1) * (h - 1) + c;
                        y.push((o + 1) * (h - 1) + (c - 1), t, n), y.push(t, i, n)
                    }
            }(), this.setIndex(y), this.addAttribute("position", new I(m, 3)), this.addAttribute("normal", new I(g, 3)), this.addAttribute("uv", new I(v, 2))
        }

        function bi(t, e, i, n, r, o, s) {
            j.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: o
            }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Ti(t, e, i, n, r, o)), this.mergeVertices()
        }

        function Ti(t, e, i, n, o, s) {
            function a(t, e, i, n, r) {
                var o = Math.sin(t);
                e = i / e * t, i = Math.cos(e), r.x = n * (2 + i) * .5 * Math.cos(t), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(e) * .5
            }
            B.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: o,
                q: s
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, s = s || 3;
            var l, c = [],
                h = [],
                u = [],
                d = [],
                p = new r,
                f = new r,
                m = new r,
                g = new r,
                v = new r,
                y = new r,
                _ = new r;
            for (l = 0; l <= i; ++l) {
                var x = l / i * o * Math.PI * 2;
                for (a(x, o, s, t, m), a(x + .01, o, s, t, g), y.subVectors(g, m), _.addVectors(g, m), v.crossVectors(y, _), _.crossVectors(v, y), v.normalize(), _.normalize(), x = 0; x <= n; ++x) {
                    var w = x / n * Math.PI * 2,
                        b = -e * Math.cos(w);
                    w = e * Math.sin(w), p.x = m.x + (b * _.x + w * v.x), p.y = m.y + (b * _.y + w * v.y), p.z = m.z + (b * _.z + w * v.z), h.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(l / i), d.push(x / n)
                }
            }
            for (x = 1; x <= i; x++)
                for (l = 1; l <= n; l++) t = (n + 1) * x + (l - 1), e = (n + 1) * x + l, o = (n + 1) * (x - 1) + l, c.push((n + 1) * (x - 1) + (l - 1), t, o), c.push(t, e, o);
            this.setIndex(c), this.addAttribute("position", new I(h, 3)), this.addAttribute("normal", new I(u, 3)), this.addAttribute("uv", new I(d, 2))
        }

        function Si(t, e, i, n, r) {
            j.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, this.fromBufferGeometry(new Mi(t, e, i, n, r)), this.mergeVertices()
        }

        function Mi(t, e, i, n, o) {
            B.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: o
            }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
            var s, a, l = [],
                c = [],
                h = [],
                u = [],
                d = new r,
                p = new r,
                f = new r;
            for (s = 0; s <= i; s++)
                for (a = 0; a <= n; a++) {
                    var m = a / n * o,
                        g = s / i * Math.PI * 2;
                    p.x = (t + e * Math.cos(g)) * Math.cos(m), p.y = (t + e * Math.cos(g)) * Math.sin(m), p.z = e * Math.sin(g), c.push(p.x, p.y, p.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), f.subVectors(p, d).normalize(), h.push(f.x, f.y, f.z), u.push(a / n), u.push(s / i)
                }
            for (s = 1; s <= i; s++)
                for (a = 1; a <= n; a++) t = (n + 1) * (s - 1) + a - 1, e = (n + 1) * (s - 1) + a, o = (n + 1) * s + a, l.push((n + 1) * s + a - 1, t, o), l.push(t, e, o);
            this.setIndex(l), this.addAttribute("position", new I(c, 3)), this.addAttribute("normal", new I(h, 3)), this.addAttribute("uv", new I(u, 2))
        }

        function Ei(t, e, i, n, r) {
            for (var o, s = 0, a = e, l = i - n; a < i; a += n) s += (t[l] - t[a]) * (t[a + 1] + t[l + 1]), l = a;
            if (r === 0 < s)
                for (r = e; r < i; r += n) o = Bi(r, t[r], t[r + 1], o);
            else
                for (r = i - n; r >= e; r -= n) o = Bi(r, t[r], t[r + 1], o);
            return o && Ii(o, o.next) && (Hi(o), o = o.next), o
        }

        function Ai(t, e) {
            if (!t) return t;
            e || (e = t);
            do {
                var i = !1;
                if (t.steiner || !Ii(t, t.next) && 0 !== Di(t.prev, t, t.next)) t = t.next;
                else {
                    if (Hi(t), (t = e = t.prev) === t.next) break;
                    i = !0
                }
            } while (i || t !== e);
            return e
        }

        function Pi(t, e, i, n) {
            var r = t.prev,
                o = t.next;
            if (0 <= Di(r, t, o)) return !1;
            var s = r.x > t.x ? r.x > o.x ? r.x : o.x : t.x > o.x ? t.x : o.x,
                a = r.y > t.y ? r.y > o.y ? r.y : o.y : t.y > o.y ? t.y : o.y,
                l = Li(r.x < t.x ? r.x < o.x ? r.x : o.x : t.x < o.x ? t.x : o.x, r.y < t.y ? r.y < o.y ? r.y : o.y : t.y < o.y ? t.y : o.y, e, i, n);
            for (e = Li(s, a, e, i, n), i = t.prevZ, n = t.nextZ; i && i.z >= l && n && n.z <= e;) {
                if (i !== t.prev && i !== t.next && ki(r.x, r.y, t.x, t.y, o.x, o.y, i.x, i.y) && 0 <= Di(i.prev, i, i.next)) return !1;
                if (i = i.prevZ, n !== t.prev && n !== t.next && ki(r.x, r.y, t.x, t.y, o.x, o.y, n.x, n.y) && 0 <= Di(n.prev, n, n.next)) return !1;
                n = n.nextZ
            }
            for (; i && i.z >= l;) {
                if (i !== t.prev && i !== t.next && ki(r.x, r.y, t.x, t.y, o.x, o.y, i.x, i.y) && 0 <= Di(i.prev, i, i.next)) return !1;
                i = i.prevZ
            }
            for (; n && n.z <= e;) {
                if (n !== t.prev && n !== t.next && ki(r.x, r.y, t.x, t.y, o.x, o.y, n.x, n.y) && 0 <= Di(n.prev, n, n.next)) return !1;
                n = n.nextZ
            }
            return !0
        }

        function Ci(t, e) {
            return t.x - e.x
        }

        function Ri(t, e) {
            var i = e,
                n = t.x,
                r = t.y,
                o = -1 / 0;
            do {
                if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                    var s = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                    if (s <= n && s > o) {
                        if (o = s, s === n) {
                            if (r === i.y) return i;
                            if (r === i.next.y) return i.next
                        }
                        var a = i.x < i.next.x ? i : i.next
                    }
                }
                i = i.next
            } while (i !== e);
            if (!a) return null;
            if (n === o) return a.prev;
            e = a, s = a.x;
            var l = a.y,
                c = 1 / 0;
            for (i = a.next; i !== e;) {
                if (n >= i.x && i.x >= s && n !== i.x && ki(r < l ? n : o, r, s, l, r < l ? o : n, r, i.x, i.y)) {
                    var h = Math.abs(r - i.y) / (n - i.x);
                    (h < c || h === c && i.x > a.x) && zi(i, t) && (a = i, c = h)
                }
                i = i.next
            }
            return a
        }

        function Li(t, e, i, n, r) {
            return 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1) | (1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
        }

        function Oi(t) {
            var e = t,
                i = t;
            do {
                (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
            } while (e !== t);
            return i
        }

        function ki(t, e, i, n, r, o, s, a) {
            return 0 <= (r - s) * (e - a) - (t - s) * (o - a) && 0 <= (t - s) * (n - a) - (i - s) * (e - a) && 0 <= (i - s) * (o - a) - (r - s) * (n - a)
        }

        function Di(t, e, i) {
            return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
        }

        function Ii(t, e) {
            return t.x === e.x && t.y === e.y
        }

        function Ni(t, e, i, n) {
            return !!(Ii(t, i) && Ii(e, n) || Ii(t, n) && Ii(i, e)) || 0 < Di(t, e, i) != 0 < Di(t, e, n) && 0 < Di(i, n, t) != 0 < Di(i, n, e)
        }

        function zi(t, e) {
            return 0 > Di(t.prev, t, t.next) ? 0 <= Di(t, e, t.next) && 0 <= Di(t, t.prev, e) : 0 > Di(t, e, t.prev) || 0 > Di(t, t.next, e)
        }

        function Fi(t, e) {
            var i = new Ui(t.i, t.x, t.y),
                n = new Ui(e.i, e.x, e.y),
                r = t.next,
                o = e.prev;
            return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
        }

        function Bi(t, e, i, n) {
            return t = new Ui(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t
        }

        function Hi(t) {
            t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
        }

        function Ui(t, e, i) {
            this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
        }

        function Gi(t) {
            var e = t.length;
            2 < e && t[e - 1].equals(t[0]) && t.pop()
        }

        function ji(t, e) {
            for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
        }

        function Vi(t, e) {
            j.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new Wi(t, e)), this.mergeVertices()
        }

        function Wi(t, e) {
            function n(t) {
                function n(t, e, i) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
                }

                function l(t, e, n) {
                    var r = t.x - e.x,
                        o = t.y - e.y,
                        s = n.x - t.x,
                        a = n.y - t.y,
                        l = r * r + o * o;
                    if (Math.abs(r * a - o * s) > Number.EPSILON) {
                        var c = Math.sqrt(l),
                            h = Math.sqrt(s * s + a * a);
                        if (l = e.x - o / c, e = e.y + r / c, 2 >= (o = (s = l + r * (a = ((n.x - a / h - l) * a - (n.y + s / h - e) * s) / (r * a - o * s)) - t.x) * s + (r = e + o * a - t.y) * r)) return new i(s, r);
                        o = Math.sqrt(o / 2)
                    } else t = !1, r > Number.EPSILON ? s > Number.EPSILON && (t = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(a) && (t = !0), t ? (s = -o, o = Math.sqrt(l)) : (s = r, r = o, o = Math.sqrt(l / 2));
                    return new i(s / o, r / o)
                }

                function c(t, e) {
                    for (U = t.length; 0 <= --U;) {
                        var i = U,
                            n = U - 1;
                        0 > n && (n = t.length - 1);
                        var r, a = g + 2 * b;
                        for (r = 0; r < a; r++) {
                            var l = B * r,
                                c = B * (r + 1),
                                h = e + n + l,
                                u = e + n + c;
                            c = e + i + c, d(e + i + l), d(h), d(c), d(h), d(u), d(c), l = s.length / 3, p((l = S.generateSideWallUV(o, s, l - 6, l - 3, l - 2, l - 1))[0]), p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3])
                        }
                    }
                }

                function h(t, e, i) {
                    f.push(t), f.push(e), f.push(i)
                }

                function u(t, e, i) {
                    d(t), d(e), d(i), t = s.length / 3, p((t = S.generateTopUV(o, s, t - 3, t - 2, t - 1))[0]), p(t[1]), p(t[2])
                }

                function d(t) {
                    s.push(f[3 * t]), s.push(f[3 * t + 1]), s.push(f[3 * t + 2])
                }

                function p(t) {
                    a.push(t.x), a.push(t.y)
                }
                var f = [],
                    m = void 0 !== e.curveSegments ? e.curveSegments : 12,
                    g = void 0 !== e.steps ? e.steps : 1,
                    v = void 0 !== e.depth ? e.depth : 100,
                    y = void 0 === e.bevelEnabled || e.bevelEnabled,
                    _ = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                    x = void 0 !== e.bevelSize ? e.bevelSize : _ - 2,
                    w = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                    b = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                    T = e.extrudePath,
                    S = void 0 !== e.UVGenerator ? e.UVGenerator : fl;
                void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = e.amount);
                var M, E = !1;
                if (T) {
                    var A = T.getSpacedPoints(g);
                    E = !0, y = !1;
                    var P = T.computeFrenetFrames(g, !1),
                        C = new r,
                        R = new r,
                        L = new r
                }
                y || (w = x = _ = b = 0), m = t.extractPoints(m), t = m.shape;
                var O = m.holes;
                if (!pl.isClockWise(t)) {
                    t = t.reverse();
                    var k = 0;
                    for (M = O.length; k < M; k++) {
                        var D = O[k];
                        pl.isClockWise(D) && (O[k] = D.reverse())
                    }
                }
                var I = pl.triangulateShape(t, O),
                    N = t;
                for (k = 0, M = O.length; k < M; k++) D = O[k], t = t.concat(D);
                var z, F, B = t.length,
                    H = I.length;
                m = [];
                var U = 0,
                    G = N.length,
                    j = G - 1;
                for (z = U + 1; U < G; U++, j++, z++) j === G && (j = 0), z === G && (z = 0), m[U] = l(N[U], N[j], N[z]);
                T = [];
                var V = m.concat();
                for (k = 0, M = O.length; k < M; k++) {
                    D = O[k];
                    var W = [];
                    for (U = 0, j = (G = D.length) - 1, z = U + 1; U < G; U++, j++, z++) j === G && (j = 0), z === G && (z = 0), W[U] = l(D[U], D[j], D[z]);
                    T.push(W), V = V.concat(W)
                }
                for (j = 0; j < b; j++) {
                    G = j / b;
                    var q = _ * Math.cos(G * Math.PI / 2);
                    for (z = x * Math.sin(G * Math.PI / 2) + w, U = 0, G = N.length; U < G; U++) {
                        var X = n(N[U], m[U], z);
                        h(X.x, X.y, -q)
                    }
                    for (k = 0, M = O.length; k < M; k++)
                        for (D = O[k], W = T[k], U = 0, G = D.length; U < G; U++) h((X = n(D[U], W[U], z)).x, X.y, -q)
                }
                for (z = x + w, U = 0; U < B; U++) X = y ? n(t[U], V[U], z) : t[U], E ? (R.copy(P.normals[0]).multiplyScalar(X.x), C.copy(P.binormals[0]).multiplyScalar(X.y), L.copy(A[0]).add(R).add(C), h(L.x, L.y, L.z)) : h(X.x, X.y, 0);
                for (G = 1; G <= g; G++)
                    for (U = 0; U < B; U++) X = y ? n(t[U], V[U], z) : t[U], E ? (R.copy(P.normals[G]).multiplyScalar(X.x), C.copy(P.binormals[G]).multiplyScalar(X.y), L.copy(A[G]).add(R).add(C), h(L.x, L.y, L.z)) : h(X.x, X.y, v / g * G);
                for (j = b - 1; 0 <= j; j--) {
                    for (G = j / b, q = _ * Math.cos(G * Math.PI / 2), z = x * Math.sin(G * Math.PI / 2) + w, U = 0, G = N.length; U < G; U++) h((X = n(N[U], m[U], z)).x, X.y, v + q);
                    for (k = 0, M = O.length; k < M; k++)
                        for (D = O[k], W = T[k], U = 0, G = D.length; U < G; U++) X = n(D[U], W[U], z), E ? h(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : h(X.x, X.y, v + q)
                }! function() {
                    var t = s.length / 3;
                    if (y) {
                        var e = 0 * B;
                        for (U = 0; U < H; U++) u((F = I[U])[2] + e, F[1] + e, F[0] + e);
                        for (e = B * (g + 2 * b), U = 0; U < H; U++) u((F = I[U])[0] + e, F[1] + e, F[2] + e)
                    } else {
                        for (U = 0; U < H; U++) u((F = I[U])[2], F[1], F[0]);
                        for (U = 0; U < H; U++) u((F = I[U])[0] + B * g, F[1] + B * g, F[2] + B * g)
                    }
                    o.addGroup(t, s.length / 3 - t, 0)
                }(),
                function() {
                    var t = s.length / 3,
                        e = 0;
                    for (c(N, e), e += N.length, k = 0, M = O.length; k < M; k++) c(D = O[k], e), e += D.length;
                    o.addGroup(t, s.length / 3 - t, 1)
                }()
            }
            B.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                shapes: t,
                options: e
            }, t = Array.isArray(t) ? t : [t];
            for (var o = this, s = [], a = [], l = 0, c = t.length; l < c; l++) n(t[l]);
            this.addAttribute("position", new I(s, 3)), this.addAttribute("uv", new I(a, 2)), this.computeVertexNormals()
        }

        function qi(t, e, i) {
            if (i.shapes = [], Array.isArray(t))
                for (var n = 0, r = t.length; n < r; n++) i.shapes.push(t[n].uuid);
            else i.shapes.push(t.uuid);
            return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
        }

        function Xi(t, e) {
            j.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new $i(t, e)), this.mergeVertices()
        }

        function $i(t, e) {
            var i = (e = e || {}).font;
            if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new j;
            t = i.generateShapes(t, e.size), e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Wi.call(this, t, e), this.type = "TextBufferGeometry"
        }

        function Yi(t, e, i, n, r, o, s) {
            j.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: o,
                thetaLength: s
            }, this.fromBufferGeometry(new Zi(t, e, i, n, r, o, s)), this.mergeVertices()
        }

        function Zi(t, e, i, n, o, s, a) {
            B.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: o,
                thetaStart: s,
                thetaLength: a
            }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : Math.PI;
            var l, c, h = Math.min(s + a, Math.PI),
                u = 0,
                d = [],
                p = new r,
                f = new r,
                m = [],
                g = [],
                v = [],
                y = [];
            for (c = 0; c <= i; c++) {
                var _ = [],
                    x = c / i,
                    w = 0;
                for (0 == c && 0 == s ? w = .5 / e : c == i && h == Math.PI && (w = -.5 / e), l = 0; l <= e; l++) {
                    var b = l / e;
                    p.x = -t * Math.cos(n + b * o) * Math.sin(s + x * a), p.y = t * Math.cos(s + x * a), p.z = t * Math.sin(n + b * o) * Math.sin(s + x * a), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(b + w, 1 - x), _.push(u++)
                }
                d.push(_)
            }
            for (c = 0; c < i; c++)
                for (l = 0; l < e; l++) t = d[c][l + 1], n = d[c][l], o = d[c + 1][l], a = d[c + 1][l + 1], (0 !== c || 0 < s) && m.push(t, n, a), (c !== i - 1 || h < Math.PI) && m.push(n, o, a);
            this.setIndex(m), this.addAttribute("position", new I(g, 3)), this.addAttribute("normal", new I(v, 3)), this.addAttribute("uv", new I(y, 2))
        }

        function Ji(t, e, i, n, r, o) {
            j.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: o
            }, this.fromBufferGeometry(new Qi(t, e, i, n, r, o)), this.mergeVertices()
        }

        function Qi(t, e, n, o, s, a) {
            B.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: o,
                thetaStart: s,
                thetaLength: a
            }, t = t || .5, e = e || 1, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
            var l, c, h = [],
                u = [],
                d = [],
                p = [],
                f = t,
                m = (e - t) / (o = void 0 !== o ? Math.max(1, o) : 1),
                g = new r,
                v = new i;
            for (l = 0; l <= o; l++) {
                for (c = 0; c <= n; c++) t = s + c / n * a, g.x = f * Math.cos(t), g.y = f * Math.sin(t), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / e + 1) / 2, v.y = (g.y / e + 1) / 2, p.push(v.x, v.y);
                f += m
            }
            for (l = 0; l < o; l++)
                for (e = l * (n + 1), c = 0; c < n; c++) s = (t = c + e) + n + 1, a = t + n + 2, f = t + 1, h.push(t, s, f), h.push(s, a, f);
            this.setIndex(h), this.addAttribute("position", new I(u, 3)), this.addAttribute("normal", new I(d, 3)), this.addAttribute("uv", new I(p, 2))
        }

        function Ki(t, e, i, n) {
            j.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, this.fromBufferGeometry(new tn(t, e, i, n)), this.mergeVertices()
        }

        function tn(t, e, n, o) {
            B.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: o
            }, e = Math.floor(e) || 12, n = n || 0, o = o || 2 * Math.PI, o = Po.clamp(o, 0, 2 * Math.PI);
            var s, a = [],
                l = [],
                c = [],
                h = 1 / e,
                u = new r,
                d = new i;
            for (s = 0; s <= e; s++) {
                var p = n + s * h * o,
                    f = Math.sin(p),
                    m = Math.cos(p);
                for (p = 0; p <= t.length - 1; p++) u.x = t[p].x * f, u.y = t[p].y, u.z = t[p].x * m, l.push(u.x, u.y, u.z), d.x = s / e, d.y = p / (t.length - 1), c.push(d.x, d.y)
            }
            for (s = 0; s < e; s++)
                for (p = 0; p < t.length - 1; p++) h = (n = p + s * t.length) + t.length, u = n + t.length + 1, d = n + 1, a.push(n, h, d), a.push(h, u, d);
            if (this.setIndex(a), this.addAttribute("position", new I(l, 3)), this.addAttribute("uv", new I(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI)
                for (o = this.attributes.normal.array, a = new r, l = new r, c = new r, n = e * t.length * 3, p = s = 0; s < t.length; s++, p += 3) a.x = o[p + 0], a.y = o[p + 1], a.z = o[p + 2], l.x = o[n + p + 0], l.y = o[n + p + 1], l.z = o[n + p + 2], c.addVectors(a, l).normalize(), o[p + 0] = o[n + p + 0] = c.x, o[p + 1] = o[n + p + 1] = c.y, o[p + 2] = o[n + p + 2] = c.z
        }

        function en(t, e) {
            j.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new nn(t, e)), this.mergeVertices()
        }

        function nn(t, e) {
            function i(t) {
                var i, a = r.length / 3,
                    c = (t = t.extractPoints(e)).shape,
                    h = t.holes;
                for (!1 === pl.isClockWise(c) && (c = c.reverse()), t = 0, i = h.length; t < i; t++) {
                    var u = h[t];
                    !0 === pl.isClockWise(u) && (h[t] = u.reverse())
                }
                var d = pl.triangulateShape(c, h);
                for (t = 0, i = h.length; t < i; t++) u = h[t], c = c.concat(u);
                for (t = 0, i = c.length; t < i; t++) u = c[t], r.push(u.x, u.y, 0), o.push(0, 0, 1), s.push(u.x, u.y);
                for (t = 0, i = d.length; t < i; t++) c = d[t], n.push(c[0] + a, c[1] + a, c[2] + a), l += 3
            }
            B.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var n = [],
                r = [],
                o = [],
                s = [],
                a = 0,
                l = 0;
            if (!1 === Array.isArray(t)) i(t);
            else
                for (var c = 0; c < t.length; c++) i(t[c]), this.addGroup(a, l, c), a += l, l = 0;
            this.setIndex(n), this.addAttribute("position", new I(r, 3)), this.addAttribute("normal", new I(o, 3)), this.addAttribute("uv", new I(s, 2))
        }

        function rn(t, e) {
            if (e.shapes = [], Array.isArray(t))
                for (var i = 0, n = t.length; i < n; i++) e.shapes.push(t[i].uuid);
            else e.shapes.push(t.uuid);
            return e
        }

        function on(t, e) {
            B.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: e
            };
            var i = [];
            e = Math.cos(Po.DEG2RAD * (void 0 !== e ? e : 1));
            var n = [0, 0],
                r = {},
                o = ["a", "b", "c"];
            if (t.isBufferGeometry) {
                var s = new j;
                s.fromBufferGeometry(t)
            } else s = t.clone();
            s.mergeVertices(), s.computeFaceNormals(), t = s.vertices;
            for (var a = 0, l = (s = s.faces).length; a < l; a++)
                for (var c = s[a], h = 0; 3 > h; h++) {
                    var u = c[o[h]],
                        d = c[o[(h + 1) % 3]];
                    n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
                        index1: n[0],
                        index2: n[1],
                        face1: a,
                        face2: void 0
                    } : r[u].face2 = a
                }
            for (u in r)(void 0 === (n = r[u]).face2 || s[n.face1].normal.dot(s[n.face2].normal) <= e) && (o = t[n.index1], i.push(o.x, o.y, o.z), o = t[n.index2], i.push(o.x, o.y, o.z));
            this.addAttribute("position", new I(i, 3))
        }

        function sn(t, e, i, n, r, o, s, a) {
            j.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: o,
                thetaStart: s,
                thetaLength: a
            }, this.fromBufferGeometry(new an(t, e, i, n, r, o, s, a)), this.mergeVertices()
        }

        function an(t, e, n, o, s, a, l, c) {
            function h(n) {
                var s, a = new i,
                    h = new r,
                    v = 0,
                    x = !0 === n ? t : e,
                    w = !0 === n ? 1 : -1,
                    b = g;
                for (s = 1; s <= o; s++) p.push(0, y * w, 0), f.push(0, w, 0), m.push(.5, .5), g++;
                var T = g;
                for (s = 0; s <= o; s++) {
                    var S = s / o * c + l,
                        M = Math.cos(S);
                    S = Math.sin(S), h.x = x * S, h.y = y * w, h.z = x * M, p.push(h.x, h.y, h.z), f.push(0, w, 0), a.x = .5 * M + .5, a.y = .5 * S * w + .5, m.push(a.x, a.y), g++
                }
                for (s = 0; s < o; s++) a = b + s, h = T + s, !0 === n ? d.push(h, h + 1, a) : d.push(h + 1, h, a), v += 3;
                u.addGroup(_, v, !0 === n ? 1 : 2), _ += v
            }
            B.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: o,
                heightSegments: s,
                openEnded: a,
                thetaStart: l,
                thetaLength: c
            };
            var u = this;
            t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, o = Math.floor(o) || 8, s = Math.floor(s) || 1, a = void 0 !== a && a, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
            var d = [],
                p = [],
                f = [],
                m = [],
                g = 0,
                v = [],
                y = n / 2,
                _ = 0;
            ! function() {
                var i, a, h = new r,
                    x = new r,
                    w = 0,
                    b = (e - t) / n;
                for (a = 0; a <= s; a++) {
                    var T = [],
                        S = a / s,
                        M = S * (e - t) + t;
                    for (i = 0; i <= o; i++) {
                        var E = i / o,
                            A = E * c + l,
                            P = Math.sin(A);
                        A = Math.cos(A), x.x = M * P, x.y = -S * n + y, x.z = M * A, p.push(x.x, x.y, x.z), h.set(P, b, A).normalize(), f.push(h.x, h.y, h.z), m.push(E, 1 - S), T.push(g++)
                    }
                    v.push(T)
                }
                for (i = 0; i < o; i++)
                    for (a = 0; a < s; a++) h = v[a + 1][i], x = v[a + 1][i + 1], b = v[a][i + 1], d.push(v[a][i], h, b), d.push(h, x, b), w += 6;
                u.addGroup(_, w, 0), _ += w
            }(), !1 === a && (0 < t && h(!0), 0 < e && h(!1)), this.setIndex(d), this.addAttribute("position", new I(p, 3)), this.addAttribute("normal", new I(f, 3)), this.addAttribute("uv", new I(m, 2))
        }

        function ln(t, e, i, n, r, o, s) {
            sn.call(this, 0, t, e, i, n, r, o, s), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: s
            }
        }

        function cn(t, e, i, n, r, o, s) {
            an.call(this, 0, t, e, i, n, r, o, s), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: s
            }
        }

        function hn(t, e, i, n) {
            j.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, this.fromBufferGeometry(new un(t, e, i, n)), this.mergeVertices()
        }

        function un(t, e, n, o) {
            B.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: o
            }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI;
            var s, a = [],
                l = [],
                c = [],
                h = [],
                u = new r,
                d = new i;
            l.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5);
            var p = 0;
            for (s = 3; p <= e; p++, s += 3) {
                var f = n + p / e * o;
                u.x = t * Math.cos(f), u.y = t * Math.sin(f), l.push(u.x, u.y, u.z), c.push(0, 0, 1), d.x = (l[s] / t + 1) / 2, d.y = (l[s + 1] / t + 1) / 2, h.push(d.x, d.y)
            }
            for (s = 1; s <= e; s++) a.push(s, s + 1, 0);
            this.setIndex(a), this.addAttribute("position", new I(l, 3)), this.addAttribute("normal", new I(c, 3)), this.addAttribute("uv", new I(h, 2))
        }

        function dn(t) {
            M.call(this), this.type = "ShadowMaterial", this.color = new x(0), this.transparent = !0, this.setValues(t)
        }

        function pn(t) {
            q.call(this, t), this.type = "RawShaderMaterial"
        }

        function fn(t) {
            M.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new x(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function mn(t) {
            fn.call(this), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearcoatRoughness = this.clearcoat = 0, this.sheen = null, this.clearcoatNormalScale = new i(1, 1), this.clearcoatNormalMap = null, this.transparency = 0, this.setValues(t)
        }

        function gn(t) {
            M.call(this), this.type = "MeshPhongMaterial", this.color = new x(16777215), this.specular = new x(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function vn(t) {
            gn.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function yn(t) {
            M.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.fog = !1, this.setValues(t)
        }

        function _n(t) {
            M.call(this), this.type = "MeshLambertMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function xn(t) {
            M.call(this), this.defines = {
                MATCAP: ""
            }, this.type = "MeshMatcapMaterial", this.color = new x(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function wn(t) {
            Ze.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
        }

        function bn(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function Tn(t, e, i, n) {
            bn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
        }

        function Sn(t, e, i, n) {
            bn.call(this, t, e, i, n)
        }

        function Mn(t, e, i, n) {
            bn.call(this, t, e, i, n)
        }

        function En(t, e, i, n) {
            if (void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = vl.convertArray(e, this.TimeBufferType), this.values = vl.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
        }

        function An(t, e, i) {
            En.call(this, t, e, i)
        }

        function Pn(t, e, i, n) {
            En.call(this, t, e, i, n)
        }

        function Cn(t, e, i, n) {
            En.call(this, t, e, i, n)
        }

        function Rn(t, e, i, n) {
            bn.call(this, t, e, i, n)
        }

        function Ln(t, e, i, n) {
            En.call(this, t, e, i, n)
        }

        function On(t, e, i, n) {
            En.call(this, t, e, i, n)
        }

        function kn(t, e, i, n) {
            En.call(this, t, e, i, n)
        }

        function Dn(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Po.generateUUID(), 0 > this.duration && this.resetDuration()
        }

        function In(t) {
            if (void 0 === t.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e = function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Cn;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return kn;
                    case "color":
                        return Pn;
                    case "quaternion":
                        return Ln;
                    case "bool":
                    case "boolean":
                        return An;
                    case "string":
                        return On
                }
                throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
            }(t.type);
            if (void 0 === t.times) {
                var i = [],
                    n = [];
                vl.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        }

        function Nn(t, e, i) {
            var n = this,
                r = !1,
                o = 0,
                s = 0,
                a = void 0,
                l = [];
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                s++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, s), r = !0
            }, this.itemEnd = function(t) {
                o++, void 0 !== n.onProgress && n.onProgress(t, o, s), o === s && (r = !1, void 0 !== n.onLoad) && n.onLoad()
            }, this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }, this.resolveURL = function(t) {
                return a ? a(t) : t
            }, this.setURLModifier = function(t) {
                return a = t, this
            }, this.addHandler = function(t, e) {
                return l.push(t, e), this
            }, this.removeHandler = function(t) {
                return -1 !== (t = l.indexOf(t)) && l.splice(t, 2), this
            }, this.getHandler = function(t) {
                for (var e = 0, i = l.length; e < i; e += 2) {
                    var n = l[e + 1];
                    if (l[e].test(t)) return n
                }
                return null
            }
        }

        function zn(t) {
            this.manager = void 0 !== t ? t : _l, this.crossOrigin = "anonymous", this.resourcePath = this.path = ""
        }

        function Fn(t) {
            zn.call(this, t)
        }

        function Bn(t) {
            zn.call(this, t)
        }

        function Hn(t) {
            zn.call(this, t)
        }

        function Un(t) {
            zn.call(this, t)
        }

        function Gn(t) {
            zn.call(this, t)
        }

        function jn(t) {
            zn.call(this, t)
        }

        function Vn(t) {
            zn.call(this, t)
        }

        function Wn() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }

        function qn(t, e, i, n, r, o, s, a) {
            Wn.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0
        }

        function Xn(t, e, i, n, r, o) {
            qn.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve"
        }

        function $n() {
            var t = 0,
                e = 0,
                i = 0,
                n = 0;
            return {
                initCatmullRom: function(r, o, s, a, l) {
                    t = o, e = r = l * (s - r), i = -3 * o + 3 * s - 2 * r - (a = l * (a - o)), n = 2 * o - 2 * s + r + a
                },
                initNonuniformCatmullRom: function(r, o, s, a, l, c, h) {
                    t = o, e = r = ((o - r) / l - (s - r) / (l + c) + (s - o) / c) * c, i = -3 * o + 3 * s - 2 * r - (a = ((s - o) / c - (a - o) / (c + h) + (a - s) / h) * c), n = 2 * o - 2 * s + r + a
                },
                calc: function(r) {
                    var o = r * r;
                    return t + e * r + i * o + n * o * r
                }
            }
        }

        function Yn(t, e, i, n) {
            Wn.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
        }

        function Zn(t, e, i, n, r) {
            var o = t * t;
            return (2 * i - 2 * n + (e = .5 * (n - e)) + (r = .5 * (r - i))) * t * o + (-3 * i + 3 * n - 2 * e - r) * o + e * t + i
        }

        function Jn(t, e, i, n) {
            var r = 1 - t;
            return r * r * e + 2 * (1 - t) * t * i + t * t * n
        }

        function Qn(t, e, i, n, r) {
            var o = 1 - t,
                s = 1 - t;
            return o * o * o * e + 3 * s * s * t * i + 3 * (1 - t) * t * t * n + t * t * t * r
        }

        function Kn(t, e, n, r) {
            Wn.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i, this.v3 = r || new i
        }

        function tr(t, e, i, n) {
            Wn.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new r, this.v1 = e || new r, this.v2 = i || new r, this.v3 = n || new r
        }

        function er(t, e) {
            Wn.call(this), this.type = "LineCurve", this.v1 = t || new i, this.v2 = e || new i
        }

        function ir(t, e) {
            Wn.call(this), this.type = "LineCurve3", this.v1 = t || new r, this.v2 = e || new r
        }

        function nr(t, e, n) {
            Wn.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i
        }

        function rr(t, e, i) {
            Wn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new r, this.v1 = e || new r, this.v2 = i || new r
        }

        function or(t) {
            Wn.call(this), this.type = "SplineCurve", this.points = t || []
        }

        function sr() {
            Wn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
        }

        function ar(t) {
            sr.call(this), this.type = "Path", this.currentPoint = new i, t && this.setFromPoints(t)
        }

        function lr(t) {
            ar.call(this, t), this.uuid = Po.generateUUID(), this.type = "Shape", this.holes = []
        }

        function cr(t, e) {
            p.call(this), this.type = "Light", this.color = new x(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function hr(t, e, i) {
            cr.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(p.DefaultUp), this.updateMatrix(), this.groundColor = new x(e)
        }

        function ur(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.mapPass = this.map = null, this.matrix = new h, this._frustum = new K, this._frameExtents = new i(1, 1), this._viewportCount = 1, this._viewports = [new a(0, 0, 1, 1)]
        }

        function dr() {
            ur.call(this, new $(50, 1, .5, 500))
        }

        function pr(t, e, i, n, r, o) {
            cr.call(this, t, e), this.type = "SpotLight", this.position.copy(p.DefaultUp), this.updateMatrix(), this.target = new p, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new dr
        }

        function fr() {
            ur.call(this, new $(90, 1, .5, 500)), this._frameExtents = new i(4, 2), this._viewportCount = 6, this._viewports = [new a(2, 1, 1, 1), new a(0, 1, 1, 1), new a(3, 1, 1, 1), new a(1, 1, 1, 1), new a(3, 0, 1, 1), new a(1, 0, 1, 1)], this._cubeDirections = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)], this._cubeUps = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)]
        }

        function mr(t, e, i, n) {
            cr.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new fr
        }

        function gr(t, e, i, n, r, o) {
            X.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
        }

        function vr() {
            ur.call(this, new gr(-5, 5, 5, -5, .5, 500))
        }

        function yr(t, e) {
            cr.call(this, t, e), this.type = "DirectionalLight", this.position.copy(p.DefaultUp), this.updateMatrix(), this.target = new p, this.shadow = new vr
        }

        function _r(t, e) {
            cr.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function xr(t, e, i, n) {
            cr.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }

        function wr(t) {
            zn.call(this, t), this.textures = {}
        }

        function br() {
            B.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function Tr(t, e, i, n) {
            "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, t, e, i), this.meshPerAttribute = n || 1
        }

        function Sr(t) {
            zn.call(this, t)
        }

        function Mr(t) {
            zn.call(this, t)
        }

        function Er(t) {
            "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), zn.call(this, t), this.options = void 0
        }

        function Ar() {
            this.type = "ShapePath", this.color = new x, this.subPaths = [], this.currentPath = null
        }

        function Pr(t) {
            this.type = "Font", this.data = t
        }

        function Cr(t) {
            zn.call(this, t)
        }

        function Rr(t) {
            zn.call(this, t)
        }

        function Lr() {
            this.coefficients = [];
            for (var t = 0; 9 > t; t++) this.coefficients.push(new r)
        }

        function Or(t, e) {
            cr.call(this, void 0, e), this.sh = void 0 !== t ? t : new Lr
        }

        function kr(t, e, i) {
            Or.call(this, void 0, i), t = (new x).set(t), i = (new x).set(e), e = new r(t.r, t.g, t.b), t = new r(i.r, i.g, i.b);
            var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75);
            this.sh.coefficients[0].copy(e).add(t).multiplyScalar(i), this.sh.coefficients[1].copy(e).sub(t).multiplyScalar(n)
        }

        function Dr(t, e) {
            Or.call(this, void 0, e), t = (new x).set(t), this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }

        function Ir() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new $, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new $, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }

        function Nr(t) {
            this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
        }

        function zr() {
            p.call(this), this.type = "AudioListener", this.context = Ol.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Nr
        }

        function Fr(t) {
            p.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function Br(t) {
            Fr.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
        }

        function Hr(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function Ur(t, e, i) {
            switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
                case "quaternion":
                    e = this._slerp;
                    break;
                case "string":
                case "bool":
                    t = Array, e = this._select;
                    break;
                default:
                    e = this._lerp
            }
            this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0
        }

        function Gr(t, e, i) {
            i = i || jr.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }

        function jr(t, e, i) {
            this.path = e, this.parsedPath = i || jr.parseTrackName(e), this.node = jr.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Vr() {
            this.uuid = Po.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var t = {};
            this._indicesByUUID = t;
            for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var n = this;
            this.stats = {
                objects: {
                    get total() {
                        return n._objects.length
                    },
                    get inUse() {
                        return this.total - n.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return n._bindings.length
                }
            }
        }

        function Wr(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null, e = (t = e.tracks).length, i = Array(e);
            for (var n = {
                    endingStart: 2400,
                    endingEnd: 2400
                }, r = 0; r !== e; ++r) {
                var o = t[r].createInterpolant(null);
                i[r] = o, o.settings = n
            }
            this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
        }

        function qr(t) {
            this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
        }

        function Xr(t, e) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t
        }

        function $r(t, e, i) {
            He.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function Yr(t, e, i, n) {
            this.ray = new y(t, e), this.near = i || 0, this.far = n || 1 / 0, this.camera = null, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function Zr(t, e) {
            return t.distance - e.distance
        }

        function Jr(t, e, i, n) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) {
                n = 0;
                for (var r = (t = t.children).length; n < r; n++) Jr(t[n], e, i, !0)
            }
        }

        function Qr(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }

        function Kr(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }

        function to(t, e) {
            this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0)
        }

        function eo(t, e) {
            this.start = void 0 !== t ? t : new r, this.end = void 0 !== e ? e : new r
        }

        function io(t) {
            p.call(this), this.material = t, this.render = function() {}
        }

        function no(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new B, e = new I(6 * e, 3), i.addAttribute("position", e), Qe.call(this, i, new Ze({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function ro(t, e) {
            p.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new B, e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
            for (var i = 0, n = 1; 32 > i; i++, n++) {
                var r = i / 32 * Math.PI * 2,
                    o = n / 32 * Math.PI * 2;
                e.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
            }
            t.addAttribute("position", new I(e, 3)), e = new Ze({
                fog: !1
            }), this.cone = new Qe(t, e), this.add(this.cone), this.update()
        }

        function oo(t) {
            for (var e = function t(e) {
                    var i = [];
                    e && e.isBone && i.push(e);
                    for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                    return i
                }(t), i = new B, n = [], r = [], o = new x(0, 0, 1), s = new x(0, 1, 0), a = 0; a < e.length; a++) {
                var l = e[a];
                l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
            }
            i.addAttribute("position", new I(n, 3)), i.addAttribute("color", new I(r, 3)), n = new Ze({
                vertexColors: 2,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), Qe.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
        }

        function so(t, e, i) {
            this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new Zi(e, 4, 2), e = new E({
                wireframe: !0,
                fog: !1
            }), H.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function ao(t, e) {
            this.type = "RectAreaLightHelper", this.light = t, this.color = e, (t = new B).addAttribute("position", new I([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), t.computeBoundingSphere(), e = new Ze({
                fog: !1
            }), Je.call(this, t, e), (t = new B).addAttribute("position", new I([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), t.computeBoundingSphere(), this.add(new H(t, new E({
                side: 1,
                fog: !1
            }))), this.update()
        }

        function lo(t, e, i) {
            p.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (t = new mi(e)).rotateY(.5 * Math.PI), this.material = new E({
                wireframe: !0,
                fog: !1
            }), void 0 === this.color && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new A(e, 3)), this.add(new H(t, this.material)), this.update()
        }

        function co(t, e) {
            this.lightProbe = t, this.size = e, t = new q({
                defines: {
                    GAMMA_OUTPUT: ""
                },
                uniforms: {
                    sh: {
                        value: this.lightProbe.sh.coefficients
                    },
                    intensity: {
                        value: this.lightProbe.intensity
                    }
                },
                vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
            }), e = new Zi(1, 32, 16), H.call(this, e, t), this.onBeforeRender()
        }

        function ho(t, e, i, n) {
            t = t || 10, e = e || 10, i = new x(void 0 !== i ? i : 4473924), n = new x(void 0 !== n ? n : 8947848);
            var r = e / 2,
                o = t / e,
                s = t / 2;
            t = [];
            for (var a = [], l = 0, c = 0, h = -s; l <= e; l++, h += o) {
                t.push(-s, 0, h, s, 0, h), t.push(h, 0, -s, h, 0, s);
                var u = l === r ? i : n;
                u.toArray(a, c), c += 3, u.toArray(a, c), c += 3, u.toArray(a, c), c += 3, u.toArray(a, c), c += 3
            }(e = new B).addAttribute("position", new I(t, 3)), e.addAttribute("color", new I(a, 3)), i = new Ze({
                vertexColors: 2
            }), Qe.call(this, e, i)
        }

        function uo(t, e, i, n, r, o) {
            t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new x(void 0 !== r ? r : 4473924), o = new x(void 0 !== o ? o : 8947848);
            var s, a = [],
                l = [];
            for (s = 0; s <= e; s++) {
                var c = s / e * 2 * Math.PI,
                    h = Math.sin(c) * t;
                c = Math.cos(c) * t, a.push(0, 0, 0), a.push(h, 0, c);
                var u = 1 & s ? r : o;
                l.push(u.r, u.g, u.b), l.push(u.r, u.g, u.b)
            }
            for (s = 0; s <= i; s++) {
                u = 1 & s ? r : o;
                var d = t - t / i * s;
                for (e = 0; e < n; e++) c = e / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, a.push(h, 0, c), l.push(u.r, u.g, u.b), c = (e + 1) / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, a.push(h, 0, c), l.push(u.r, u.g, u.b)
            }(t = new B).addAttribute("position", new I(a, 3)), t.addAttribute("color", new I(l, 3)), a = new Ze({
                vertexColors: 2
            }), Qe.call(this, t, a)
        }

        function po(t, e, i, n) {
            this.audio = t, this.range = e || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, t = new B, e = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), t.addAttribute("position", new A(e, 3)), e = new Ze({
                color: 65280
            }), i = new Ze({
                color: 16776960
            }), Je.call(this, t, [i, e]), this.update()
        }

        function fo(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new B, e = new I(6 * e, 3), i.addAttribute("position", e), Qe.call(this, i, new Ze({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function mo(t, e, i) {
            p.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1), (t = new B).addAttribute("position", new I([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)), e = new Ze({
                fog: !1
            }), this.lightPlane = new Je(t, e), this.add(this.lightPlane), (t = new B).addAttribute("position", new I([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Je(t, e), this.add(this.targetLine), this.update()
        }

        function go(t) {
            function e(t, e, n) {
                i(t, n), i(e, n)
            }

            function i(t, e) {
                o.push(0, 0, 0), s.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(o.length / 3 - 1)
            }
            var n = new B,
                r = new Ze({
                    color: 16777215,
                    vertexColors: 1
                }),
                o = [],
                s = [],
                a = {},
                l = new x(16755200),
                c = new x(16711680),
                h = new x(43775),
                u = new x(16777215),
                d = new x(3355443);
            e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", c), e("p", "n2", c), e("p", "n3", c), e("p", "n4", c), e("u1", "u2", h), e("u2", "u3", h), e("u3", "u1", h), e("c", "t", u), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), n.addAttribute("position", new I(o, 3)), n.addAttribute("color", new I(s, 3)), Qe.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
        }

        function vo(t, e, i, n, r, o, s) {
            if (vc.set(r, o, s).unproject(n), void 0 !== (t = e[t]))
                for (i = i.getAttribute("position"), e = 0, n = t.length; e < n; e++) i.setXYZ(t[e], vc.x, vc.y, vc.z)
        }

        function yo(t, e) {
            this.object = t, void 0 === e && (e = 16776960), t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var i = new Float32Array(24),
                n = new B;
            n.setIndex(new A(t, 1)), n.addAttribute("position", new A(i, 3)), Qe.call(this, n, new Ze({
                color: e
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function _o(t, e) {
            this.type = "Box3Helper", this.box = t, e = e || 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
            var i = new B;
            i.setIndex(new A(t, 1)), i.addAttribute("position", new I([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Qe.call(this, i, new Ze({
                color: e
            })), this.geometry.computeBoundingSphere()
        }

        function xo(t, e, i) {
            this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e, t = void 0 !== i ? i : 16776960, (e = new B).addAttribute("position", new I([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), e.computeBoundingSphere(), Je.call(this, e, new Ze({
                color: t
            })), (e = new B).addAttribute("position", new I([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), e.computeBoundingSphere(), this.add(new H(e, new E({
                color: t,
                opacity: .2,
                transparent: !0,
                depthWrite: !1
            })))
        }

        function wo(t, e, i, n, o, s) {
            p.call(this), void 0 === t && (t = new r(0, 0, 1)), void 0 === e && (e = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === s && (s = .2 * o), void 0 === xc && ((xc = new B).addAttribute("position", new I([0, 0, 0, 0, 1, 0], 3)), (wc = new an(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Je(xc, new Ze({
                color: n
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new H(wc, new E({
                color: n
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, o, s)
        }

        function bo(t) {
            var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
            (t = new B).addAttribute("position", new I(e, 3)), t.addAttribute("color", new I([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), e = new Ze({
                vertexColors: 2
            }), Qe.call(this, t, e)
        }

        function To(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Yn.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function So(t) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Yn.call(this, t), this.type = "catmullrom"
        }

        function Mo(t) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Yn.call(this, t), this.type = "catmullrom"
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function(t) {
            return 0 > t ? -1 : 0 < t ? 1 : +t
        }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && (Object.assign = function(t) {
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (null != n)
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }), Object.assign(e.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                void 0 !== this._listeners && (void 0 !== (t = this._listeners[t]) && (-1 !== (e = t.indexOf(e)) && t.splice(e, 1)))
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, n = (e = e.slice(0)).length; i < n; i++) e[i].call(this, t)
                    }
                }
            }
        });
        for (var Eo = [], Ao = 0; 256 > Ao; Ao++) Eo[Ao] = (16 > Ao ? "0" : "") + Ao.toString(16);
        var Po = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0;
                return (Eo[255 & t] + Eo[t >> 8 & 255] + Eo[t >> 16 & 255] + Eo[t >> 24 & 255] + "-" + Eo[255 & e] + Eo[e >> 8 & 255] + "-" + Eo[e >> 16 & 15 | 64] + Eo[e >> 24 & 255] + "-" + Eo[63 & i | 128] + Eo[i >> 8 & 255] + "-" + Eo[i >> 16 & 255] + Eo[i >> 24 & 255] + Eo[255 & n] + Eo[n >> 8 & 255] + Eo[n >> 16 & 255] + Eo[n >> 24 & 255]).toUpperCase()
            },
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * Po.DEG2RAD
            },
            radToDeg: function(t) {
                return t * Po.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            ceilPowerOfTwo: function(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
            },
            floorPowerOfTwo: function(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
        };
        Object.defineProperties(i.prototype, {
            width: {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            },
            height: {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }
        }), Object.assign(i.prototype, {
            isVector2: !0,
            set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function(t) {
                return this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function(t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y;
                return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
            },
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            cross: function(t) {
                return this.x * t.y - this.y * t.x
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            angle: function() {
                var t = Math.atan2(this.y, this.x);
                return 0 > t && (t += 2 * Math.PI), t
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x;
                return e * e + (t = this.y - t.y) * t
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function(t, e) {
                var i = Math.cos(e);
                e = Math.sin(e);
                var n = this.x - t.x,
                    r = this.y - t.y;
                return this.x = n * i - r * e + t.x, this.y = n * e + r * i + t.y, this
            }
        }), Object.assign(n, {
            slerp: function(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            },
            slerpFlat: function(t, e, i, n, r, o, s) {
                var a = i[n + 0],
                    l = i[n + 1],
                    c = i[n + 2];
                i = i[n + 3], n = r[o + 0];
                var h = r[o + 1],
                    u = r[o + 2];
                if (i !== (r = r[o + 3]) || a !== n || l !== h || c !== u) {
                    o = 1 - s;
                    var d = a * n + l * h + c * u + i * r,
                        p = 0 <= d ? 1 : -1,
                        f = 1 - d * d;
                    f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, s = Math.sin(s * d) / f), a = a * o + n * (p *= s), l = l * o + h * p, c = c * o + u * p, i = i * o + r * p, o === 1 - s && (a *= s = 1 / Math.sqrt(a * a + l * l + c * c + i * i), l *= s, c *= s, i *= s)
                }
                t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = i
            }
        }), Object.defineProperties(n.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this._onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this._onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this._onChangeCallback()
                }
            },
            w: {
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this._onChangeCallback()
                }
            }
        }), Object.assign(n.prototype, {
            isQuaternion: !0,
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
            },
            setFromEuler: function(t, e) {
                if (!t || !t.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    n = t._y,
                    r = t._z;
                t = t.order;
                var o = Math.cos,
                    s = Math.sin,
                    a = o(i / 2),
                    l = o(n / 2);
                return o = o(r / 2), i = s(i / 2), n = s(n / 2), r = s(r / 2), "XYZ" === t ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "YXZ" === t ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "ZXY" === t ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "ZYX" === t ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "YZX" === t ? (this._x = i * l * o + a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o - i * n * r) : "XZY" === t && (this._x = i * l * o - a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o + i * n * r), !1 !== e && this._onChangeCallback(), this
            },
            setFromAxisAngle: function(t, e) {
                e /= 2;
                var i = Math.sin(e);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this._onChangeCallback(), this
            },
            setFromRotationMatrix: function(t) {
                var e = t.elements,
                    i = e[0];
                t = e[4];
                var n = e[8],
                    r = e[1],
                    o = e[5],
                    s = e[9],
                    a = e[2],
                    l = e[6],
                    c = i + o + (e = e[10]);
                return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - s) * i, this._y = (n - a) * i, this._z = (r - t) * i) : i > o && i > e ? (i = 2 * Math.sqrt(1 + i - o - e), this._w = (l - s) / i, this._x = .25 * i, this._y = (t + r) / i, this._z = (n + a) / i) : o > e ? (i = 2 * Math.sqrt(1 + o - i - e), this._w = (n - a) / i, this._x = (t + r) / i, this._y = .25 * i, this._z = (s + l) / i) : (i = 2 * Math.sqrt(1 + e - i - o), this._w = (r - t) / i, this._x = (n + a) / i, this._y = (s + l) / i, this._z = .25 * i), this._onChangeCallback(), this
            },
            setFromUnitVectors: function(t, e) {
                var i = t.dot(e) + 1;
                return 1e-6 > i ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = i, this.normalize()
            },
            angleTo: function(t) {
                return 2 * Math.acos(Math.abs(Po.clamp(this.dot(t), -1, 1)))
            },
            rotateTowards: function(t, e) {
                var i = this.angleTo(t);
                return 0 === i ? this : (this.slerp(t, Math.min(1, e / i)), this)
            },
            inverse: function() {
                return this.conjugate()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this._onChangeCallback(), this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function(t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function(t, e) {
                var i = t._x,
                    n = t._y,
                    r = t._z;
                t = t._w;
                var o = e._x,
                    s = e._y,
                    a = e._z;
                return e = e._w, this._x = i * e + t * o + n * a - r * s, this._y = n * e + t * s + r * o - i * a, this._z = r * e + t * a + i * s - n * o, this._w = t * e - i * o - n * s - r * a, this._onChangeCallback(), this
            },
            slerp: function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    n = this._y,
                    r = this._z,
                    o = this._w,
                    s = o * t._w + i * t._x + n * t._y + r * t._z;
                if (0 > s ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), 1 <= s) return this._w = o, this._x = i, this._y = n, this._z = r, this;
                if ((t = 1 - s * s) <= Number.EPSILON) return s = 1 - e, this._w = s * o + e * this._w, this._x = s * i + e * this._x, this._y = s * n + e * this._y, this._z = s * r + e * this._z, this.normalize(), this._onChangeCallback(), this;
                t = Math.sqrt(t);
                var a = Math.atan2(t, s);
                return s = Math.sin((1 - e) * a) / t, e = Math.sin(e * a) / t, this._w = o * s + this._w * e, this._x = i * s + this._x * e, this._y = n * s + this._y * e, this._z = r * s + this._z * e, this._onChangeCallback(), this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            _onChange: function(t) {
                return this._onChangeCallback = t, this
            },
            _onChangeCallback: function() {}
        });
        var Co = new r,
            Ro = new n;
        Object.assign(r.prototype, {
            isVector3: !0,
            set: function(t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            },
            setScalar: function(t) {
                return this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: function(t) {
                return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Ro.setFromEuler(t))
            },
            applyAxisAngle: function(t, e) {
                return this.applyQuaternion(Ro.setFromAxisAngle(t, e))
            },
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = 1 / ((t = t.elements)[3] * e + t[7] * i + t[11] * n + t[15]);
                return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * r, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * r, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * r, this
            },
            applyQuaternion: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.x,
                    o = t.y,
                    s = t.z,
                    a = (t = t.w) * e + o * n - s * i,
                    l = t * i + s * e - r * n,
                    c = t * n + r * i - o * e;
                return e = -r * e - o * i - s * n, this.x = a * t + e * -r + l * -s - c * -o, this.y = l * t + e * -o + c * -r - a * -s, this.z = c * t + e * -s + a * -o - l * -r, this
            },
            project: function(t) {
                return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
            },
            unproject: function(t) {
                return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
            },
            transformDirection: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize()
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
            },
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            cross: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
            },
            crossVectors: function(t, e) {
                var i = t.x,
                    n = t.y;
                t = t.z;
                var r = e.x,
                    o = e.y;
                return e = e.z, this.x = n * e - t * o, this.y = t * r - i * e, this.z = i * o - n * r, this
            },
            projectOnVector: function(t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            },
            projectOnPlane: function(t) {
                return Co.copy(this).projectOnVector(t), this.sub(Co)
            },
            reflect: function(t) {
                return this.sub(Co.copy(t).multiplyScalar(2 * this.dot(t)))
            },
            angleTo: function(t) {
                var e = Math.sqrt(this.lengthSq() * t.lengthSq());
                return 0 === e && console.error("THREE.Vector3: angleTo() can't handle zero length vectors."), t = this.dot(t) / e, Math.acos(Po.clamp(t, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return e * e + i * i + (t = this.z - t.z) * t
            },
            manhattanDistanceTo: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function(t) {
                return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
            },
            setFromSphericalCoords: function(t, e, i) {
                var n = Math.sin(e) * t;
                return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
            },
            setFromCylindrical: function(t) {
                return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
            },
            setFromCylindricalCoords: function(t, e, i) {
                return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
            },
            setFromMatrixPosition: function(t) {
                return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this
            },
            setFromMatrixScale: function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length();
                return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this
            },
            setFromMatrixColumn: function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        });
        var Lo = new r;
        Object.assign(o.prototype, {
            isMatrix3: !0,
            set: function(t, e, i, n, r, o, s, a, l) {
                var c = this.elements;
                return c[0] = t, c[1] = n, c[2] = s, c[3] = e, c[4] = r, c[5] = a, c[6] = i, c[7] = o, c[8] = l, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
            },
            setFromMatrix4: function(t) {
                return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            },
            applyToBufferAttribute: function(t) {
                for (var e = 0, i = t.count; e < i; e++) Lo.x = t.getX(e), Lo.y = t.getY(e), Lo.z = t.getZ(e), Lo.applyMatrix3(this), t.setXYZ(e, Lo.x, Lo.y, Lo.z);
                return t
            },
            multiply: function(t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements;
                e = this.elements, t = i[0];
                var r = i[3],
                    o = i[6],
                    s = i[1],
                    a = i[4],
                    l = i[7],
                    c = i[2],
                    h = i[5];
                i = i[8];
                var u = n[0],
                    d = n[3],
                    p = n[6],
                    f = n[1],
                    m = n[4],
                    g = n[7],
                    v = n[2],
                    y = n[5];
                return n = n[8], e[0] = t * u + r * f + o * v, e[3] = t * d + r * m + o * y, e[6] = t * p + r * g + o * n, e[1] = s * u + a * f + l * v, e[4] = s * d + a * m + l * y, e[7] = s * p + a * g + l * n, e[2] = c * u + h * f + i * v, e[5] = c * d + h * m + i * y, e[8] = c * p + h * g + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    o = t[4],
                    s = t[5],
                    a = t[6],
                    l = t[7];
                return e * o * (t = t[8]) - e * s * l - i * r * t + i * s * a + n * r * l - n * o * a
            },
            getInverse: function(t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                var i = t.elements;
                t = this.elements;
                var n = i[0],
                    r = i[1],
                    o = i[2],
                    s = i[3],
                    a = i[4],
                    l = i[5],
                    c = i[6],
                    h = i[7],
                    u = (i = i[8]) * a - l * h,
                    d = l * c - i * s,
                    p = h * s - a * c,
                    f = n * u + r * d + o * p;
                if (0 === f) {
                    if (!0 === e) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
                }
                return e = 1 / f, t[0] = u * e, t[1] = (o * h - i * r) * e, t[2] = (l * r - o * a) * e, t[3] = d * e, t[4] = (i * n - o * c) * e, t[5] = (o * s - l * n) * e, t[6] = p * e, t[7] = (r * c - h * n) * e, t[8] = (a * n - r * s) * e, this
            },
            transpose: function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            },
            getNormalMatrix: function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            setUvTransform: function(t, e, i, n, r, o, s) {
                var a = Math.cos(r);
                r = Math.sin(r), this.set(i * a, i * r, -i * (a * o + r * s) + o + t, -n * r, n * a, -n * (-r * o + a * s) + s + e, 0, 0, 1)
            },
            scale: function(t, e) {
                var i = this.elements;
                return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
            },
            rotate: function(t) {
                var e = Math.cos(t);
                t = Math.sin(t);
                var i = this.elements,
                    n = i[0],
                    r = i[3],
                    o = i[6],
                    s = i[1],
                    a = i[4],
                    l = i[7];
                return i[0] = e * n + t * s, i[3] = e * r + t * a, i[6] = e * o + t * l, i[1] = -t * n + e * s, i[4] = -t * r + e * a, i[7] = -t * o + e * l, this
            },
            translate: function(t, e) {
                var i = this.elements;
                return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; 9 > i; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; 9 > i; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        });
        var Oo, ko = {
                getDataURL: function(t) {
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    if (!(t instanceof HTMLCanvasElement)) {
                        void 0 === Oo && (Oo = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Oo.width = t.width, Oo.height = t.height;
                        var e = Oo.getContext("2d");
                        t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), t = Oo
                    }
                    return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                }
            },
            Do = 0;
        s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = Object.assign(Object.create(e.prototype), {
            constructor: s,
            isTexture: !0,
            updateMatrix: function() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                var e = void 0 === t || "string" == typeof t;
                if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var i = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    type: this.type,
                    encoding: this.encoding,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                if (void 0 !== this.image) {
                    var n = this.image;
                    if (void 0 === n.uuid && (n.uuid = Po.generateUUID()), !e && void 0 === t.images[n.uuid]) {
                        if (Array.isArray(n))
                            for (var r = [], o = 0, s = n.length; o < s; o++) r.push(ko.getDataURL(n[o]));
                        else r = ko.getDataURL(n);
                        t.images[n.uuid] = {
                            uuid: n.uuid,
                            url: r
                        }
                    }
                    i.image = n.uuid
                }
                return e || (t.textures[this.uuid] = i), i
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 !== this.mapping) return t;
                if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x) switch (this.wrapS) {
                    case 1e3:
                        t.x -= Math.floor(t.x);
                        break;
                    case 1001:
                        t.x = 0 > t.x ? 0 : 1;
                        break;
                    case 1002:
                        t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
                }
                if (0 > t.y || 1 < t.y) switch (this.wrapT) {
                    case 1e3:
                        t.y -= Math.floor(t.y);
                        break;
                    case 1001:
                        t.y = 0 > t.y ? 0 : 1;
                        break;
                    case 1002:
                        t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
                }
                return this.flipY && (t.y = 1 - t.y), t
            }
        }), Object.defineProperty(s.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.defineProperties(a.prototype, {
            width: {
                get: function() {
                    return this.z
                },
                set: function(t) {
                    this.z = t
                }
            },
            height: {
                get: function() {
                    return this.w
                },
                set: function(t) {
                    this.w = t
                }
            }
        }), Object.assign(a.prototype, {
            isVector4: !0,
            set: function(t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            },
            setScalar: function(t) {
                return this.w = this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setW: function(t) {
                return this.w = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = this.w;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e = (t = t.elements)[0],
                    i = t[4],
                    n = t[8],
                    r = t[1],
                    o = t[5],
                    s = t[9],
                    a = t[2],
                    l = t[6],
                    c = t[10];
                return .01 > Math.abs(i - r) && .01 > Math.abs(n - a) && .01 > Math.abs(s - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + a) && .1 > Math.abs(s + l) && .1 > Math.abs(e + o + c - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, c = (c + 1) / 2, i = (i + r) / 4, n = (n + a) / 4, s = (s + l) / 4, (e = (e + 1) / 2) > (o = (o + 1) / 2) && e > c ? .01 > e ? (l = 0, i = a = .707106781) : (a = i / (l = Math.sqrt(e)), i = n / l) : o > c ? .01 > o ? (l = .707106781, a = 0, i = .707106781) : (l = i / (a = Math.sqrt(o)), i = s / a) : .01 > c ? (a = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(c)), a = s / i), this.set(l, a, i, t), this) : (t = Math.sqrt((l - s) * (l - s) + (n - a) * (n - a) + (r - i) * (r - i)), .001 > Math.abs(t) && (t = 1), this.x = (l - s) / t, this.y = (n - a) / t, this.z = (r - i) / t, this.w = Math.acos((e + o + c - 1) / 2), this)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function(t, e) {
                return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
            },
            clampLength: function(t, e) {
                var i = this.length();
                return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            manhattanLength: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length() || 1)
            },
            setLength: function(t) {
                return this.normalize().multiplyScalar(t)
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), l.prototype = Object.assign(Object.create(e.prototype), {
            constructor: l,
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), c.prototype = Object.assign(Object.create(l.prototype), {
            constructor: c,
            isWebGLMultisampleRenderTarget: !0,
            copy: function(t) {
                return l.prototype.copy.call(this, t), this.samples = t.samples, this
            }
        });
        var Io = new r,
            No = new h,
            zo = new r(0, 0, 0),
            Fo = new r(1, 1, 1),
            Bo = new r,
            Ho = new r,
            Uo = new r;
        Object.assign(h.prototype, {
            isMatrix4: !0,
            set: function(t, e, i, n, r, o, s, a, l, c, h, u, d, p, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new h).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
            },
            copyPosition: function(t) {
                var e = this.elements;
                return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this
            },
            extractBasis: function(t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function(t) {
                var e = this.elements,
                    i = t.elements,
                    n = 1 / Io.setFromMatrixColumn(t, 0).length(),
                    r = 1 / Io.setFromMatrixColumn(t, 1).length();
                return t = 1 / Io.setFromMatrixColumn(t, 2).length(), e[0] = i[0] * n, e[1] = i[1] * n, e[2] = i[2] * n, e[3] = 0, e[4] = i[4] * r, e[5] = i[5] * r, e[6] = i[6] * r, e[7] = 0, e[8] = i[8] * t, e[9] = i[9] * t, e[10] = i[10] * t, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromEuler: function(t) {
                t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                    i = t.x,
                    n = t.y,
                    r = t.z,
                    o = Math.cos(i);
                i = Math.sin(i);
                var s = Math.cos(n);
                n = Math.sin(n);
                var a = Math.cos(r);
                if (r = Math.sin(r), "XYZ" === t.order) {
                    t = o * a;
                    var l = o * r,
                        c = i * a,
                        h = i * r;
                    e[0] = s * a, e[4] = -s * r, e[8] = n, e[1] = l + c * n, e[5] = t - h * n, e[9] = -i * s, e[2] = h - t * n, e[6] = c + l * n, e[10] = o * s
                } else "YXZ" === t.order ? (t = s * a, l = s * r, c = n * a, h = n * r, e[0] = t + h * i, e[4] = c * i - l, e[8] = o * n, e[1] = o * r, e[5] = o * a, e[9] = -i, e[2] = l * i - c, e[6] = h + t * i, e[10] = o * s) : "ZXY" === t.order ? (t = s * a, l = s * r, c = n * a, h = n * r, e[0] = t - h * i, e[4] = -o * r, e[8] = c + l * i, e[1] = l + c * i, e[5] = o * a, e[9] = h - t * i, e[2] = -o * n, e[6] = i, e[10] = o * s) : "ZYX" === t.order ? (t = o * a, l = o * r, c = i * a, h = i * r, e[0] = s * a, e[4] = c * n - l, e[8] = t * n + h, e[1] = s * r, e[5] = h * n + t, e[9] = l * n - c, e[2] = -n, e[6] = i * s, e[10] = o * s) : "YZX" === t.order ? (t = o * s, l = o * n, c = i * s, h = i * n, e[0] = s * a, e[4] = h - t * r, e[8] = c * r + l, e[1] = r, e[5] = o * a, e[9] = -i * a, e[2] = -n * a, e[6] = l * r + c, e[10] = t - h * r) : "XZY" === t.order && (t = o * s, l = o * n, c = i * s, h = i * n, e[0] = s * a, e[4] = -r, e[8] = n * a, e[1] = t * r + h, e[5] = o * a, e[9] = l * r - c, e[2] = c * r - l, e[6] = i * a, e[10] = h * r + t);
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function(t) {
                return this.compose(zo, t, Fo)
            },
            lookAt: function(t, e, i) {
                var n = this.elements;
                return Uo.subVectors(t, e), 0 === Uo.lengthSq() && (Uo.z = 1), Uo.normalize(), Bo.crossVectors(i, Uo), 0 === Bo.lengthSq() && (1 === Math.abs(i.z) ? Uo.x += 1e-4 : Uo.z += 1e-4, Uo.normalize(), Bo.crossVectors(i, Uo)), Bo.normalize(), Ho.crossVectors(Uo, Bo), n[0] = Bo.x, n[4] = Ho.x, n[8] = Uo.x, n[1] = Bo.y, n[5] = Ho.y, n[9] = Uo.y, n[2] = Bo.z, n[6] = Ho.z, n[10] = Uo.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements;
                e = this.elements, t = i[0];
                var r = i[4],
                    o = i[8],
                    s = i[12],
                    a = i[1],
                    l = i[5],
                    c = i[9],
                    h = i[13],
                    u = i[2],
                    d = i[6],
                    p = i[10],
                    f = i[14],
                    m = i[3],
                    g = i[7],
                    v = i[11];
                i = i[15];
                var y = n[0],
                    _ = n[4],
                    x = n[8],
                    w = n[12],
                    b = n[1],
                    T = n[5],
                    S = n[9],
                    M = n[13],
                    E = n[2],
                    A = n[6],
                    P = n[10],
                    C = n[14],
                    R = n[3],
                    L = n[7],
                    O = n[11];
                return n = n[15], e[0] = t * y + r * b + o * E + s * R, e[4] = t * _ + r * T + o * A + s * L, e[8] = t * x + r * S + o * P + s * O, e[12] = t * w + r * M + o * C + s * n, e[1] = a * y + l * b + c * E + h * R, e[5] = a * _ + l * T + c * A + h * L, e[9] = a * x + l * S + c * P + h * O, e[13] = a * w + l * M + c * C + h * n, e[2] = u * y + d * b + p * E + f * R, e[6] = u * _ + d * T + p * A + f * L, e[10] = u * x + d * S + p * P + f * O, e[14] = u * w + d * M + p * C + f * n, e[3] = m * y + g * b + v * E + i * R, e[7] = m * _ + g * T + v * A + i * L, e[11] = m * x + g * S + v * P + i * O, e[15] = m * w + g * M + v * C + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToBufferAttribute: function(t) {
                for (var e = 0, i = t.count; e < i; e++) Io.x = t.getX(e), Io.y = t.getY(e), Io.z = t.getZ(e), Io.applyMatrix4(this), t.setXYZ(e, Io.x, Io.y, Io.z);
                return t
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    n = t[8],
                    r = t[12],
                    o = t[1],
                    s = t[5],
                    a = t[9],
                    l = t[13],
                    c = t[2],
                    h = t[6],
                    u = t[10],
                    d = t[14];
                return t[3] * (+r * a * h - n * l * h - r * s * u + i * l * u + n * s * d - i * a * d) + t[7] * (+e * a * d - e * l * u + r * o * u - n * o * d + n * l * c - r * a * c) + t[11] * (+e * l * h - e * s * d - r * o * h + i * o * d + r * s * c - i * l * c) + t[15] * (-n * s * c - e * a * h + e * s * u + n * o * h - i * o * u + i * a * c)
            },
            transpose: function() {
                var t = this.elements,
                    e = t[1];
                return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
            },
            setPosition: function(t, e, i) {
                var n = this.elements;
                return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this
            },
            getInverse: function(t, e) {
                var i = this.elements,
                    n = t.elements;
                t = n[0];
                var r = n[1],
                    o = n[2],
                    s = n[3],
                    a = n[4],
                    l = n[5],
                    c = n[6],
                    h = n[7],
                    u = n[8],
                    d = n[9],
                    p = n[10],
                    f = n[11],
                    m = n[12],
                    g = n[13],
                    v = n[14],
                    y = d * v * h - g * p * h + g * c * f - l * v * f - d * c * (n = n[15]) + l * p * n,
                    _ = m * p * h - u * v * h - m * c * f + a * v * f + u * c * n - a * p * n,
                    x = u * g * h - m * d * h + m * l * f - a * g * f - u * l * n + a * d * n,
                    w = m * d * c - u * g * c - m * l * p + a * g * p + u * l * v - a * d * v,
                    b = t * y + r * _ + o * x + s * w;
                if (0 === b) {
                    if (!0 === e) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
                }
                return e = 1 / b, i[0] = y * e, i[1] = (g * p * s - d * v * s - g * o * f + r * v * f + d * o * n - r * p * n) * e, i[2] = (l * v * s - g * c * s + g * o * h - r * v * h - l * o * n + r * c * n) * e, i[3] = (d * c * s - l * p * s - d * o * h + r * p * h + l * o * f - r * c * f) * e, i[4] = _ * e, i[5] = (u * v * s - m * p * s + m * o * f - t * v * f - u * o * n + t * p * n) * e, i[6] = (m * c * s - a * v * s - m * o * h + t * v * h + a * o * n - t * c * n) * e, i[7] = (a * p * s - u * c * s + u * o * h - t * p * h - a * o * f + t * c * f) * e, i[8] = x * e, i[9] = (m * d * s - u * g * s - m * r * f + t * g * f + u * r * n - t * d * n) * e, i[10] = (a * g * s - m * l * s + m * r * h - t * g * h - a * r * n + t * l * n) * e, i[11] = (u * l * s - a * d * s - u * r * h + t * d * h + a * r * f - t * l * f) * e, i[12] = w * e, i[13] = (u * g * o - m * d * o + m * r * p - t * g * p - u * r * v + t * d * v) * e, i[14] = (m * l * o - a * g * o - m * r * c + t * g * c + a * r * v - t * l * v) * e, i[15] = (a * d * o - u * l * o + u * r * c - t * d * c - a * r * p + t * l * p) * e, this
            },
            scale: function(t) {
                var e = this.elements,
                    i = t.x,
                    n = t.y;
                return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements;
                return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
            },
            makeTranslation: function(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(t, e) {
                var i = Math.cos(e);
                e = Math.sin(e);
                var n = 1 - i,
                    r = t.x,
                    o = t.y;
                t = t.z;
                var s = n * r,
                    a = n * o;
                return this.set(s * r + i, s * o - e * t, s * t + e * o, 0, s * o + e * t, a * o + i, a * t - e * r, 0, s * t - e * o, a * t + e * r, n * t * t + i, 0, 0, 0, 0, 1), this
            },
            makeScale: function(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            },
            makeShear: function(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function(t, e, i) {
                var n = this.elements,
                    r = e._x,
                    o = e._y,
                    s = e._z,
                    a = e._w,
                    l = r + r,
                    c = o + o,
                    h = s + s;
                e = r * l;
                var u = r * c;
                r *= h;
                var d = o * c;
                o *= h, s *= h, l *= a, c *= a, a *= h, h = i.x;
                var p = i.y;
                return i = i.z, n[0] = (1 - (d + s)) * h, n[1] = (u + a) * h, n[2] = (r - c) * h, n[3] = 0, n[4] = (u - a) * p, n[5] = (1 - (e + s)) * p, n[6] = (o + l) * p, n[7] = 0, n[8] = (r + c) * i, n[9] = (o - l) * i, n[10] = (1 - (e + d)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
            },
            decompose: function(t, e, i) {
                var n = this.elements,
                    r = Io.set(n[0], n[1], n[2]).length(),
                    o = Io.set(n[4], n[5], n[6]).length(),
                    s = Io.set(n[8], n[9], n[10]).length();
                0 > this.determinant() && (r = -r), t.x = n[12], t.y = n[13], t.z = n[14], No.copy(this), t = 1 / r, n = 1 / o;
                var a = 1 / s;
                return No.elements[0] *= t, No.elements[1] *= t, No.elements[2] *= t, No.elements[4] *= n, No.elements[5] *= n, No.elements[6] *= n, No.elements[8] *= a, No.elements[9] *= a, No.elements[10] *= a, e.setFromRotationMatrix(No), i.x = r, i.y = o, i.z = s, this
            },
            makePerspective: function(t, e, i, n, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var s = this.elements;
                return s[0] = 2 * r / (e - t), s[4] = 0, s[8] = (e + t) / (e - t), s[12] = 0, s[1] = 0, s[5] = 2 * r / (i - n), s[9] = (i + n) / (i - n), s[13] = 0, s[2] = 0, s[6] = 0, s[10] = -(o + r) / (o - r), s[14] = -2 * o * r / (o - r), s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
            },
            makeOrthographic: function(t, e, i, n, r, o) {
                var s = this.elements,
                    a = 1 / (e - t),
                    l = 1 / (i - n),
                    c = 1 / (o - r);
                return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -(e + t) * a, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -(i + n) * l, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -(o + r) * c, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; 16 > i; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; 16 > i; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        });
        var Go = new h,
            jo = new n;
        u.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), u.DefaultOrder = "XYZ", Object.defineProperties(u.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this._onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this._onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this._onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t, this._onChangeCallback()
                }
            }
        }), Object.assign(u.prototype, {
            isEuler: !0,
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this._onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
            },
            setFromRotationMatrix: function(t, e, i) {
                var n = Po.clamp,
                    r = t.elements;
                t = r[0];
                var o = r[4],
                    s = r[8],
                    a = r[1],
                    l = r[5],
                    c = r[9],
                    h = r[2],
                    u = r[6];
                return r = r[10], "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), .9999999 > Math.abs(s) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, t)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), .9999999 > Math.abs(c) ? (this._y = Math.atan2(s, r), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(u, -1, 1)), .9999999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, t))) : "ZYX" === e ? (this._y = Math.asin(-n(h, -1, 1)), .9999999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(a, t)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(n(a, -1, 1)), .9999999 > Math.abs(a) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, t)) : (this._x = 0, this._y = Math.atan2(s, r))) : "XZY" === e ? (this._z = Math.asin(-n(o, -1, 1)), .9999999 > Math.abs(o) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, t)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this._onChangeCallback(), this
            },
            setFromQuaternion: function(t, e, i) {
                return Go.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Go, e, i)
            },
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function(t) {
                return jo.setFromEuler(this), this.setFromQuaternion(jo, t)
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z)
            },
            _onChange: function(t) {
                return this._onChangeCallback = t, this
            },
            _onChangeCallback: function() {}
        }), Object.assign(d.prototype, {
            set: function(t) {
                this.mask = 1 << t | 0
            },
            enable: function(t) {
                this.mask = this.mask | 1 << t | 0
            },
            enableAll: function() {
                this.mask = -1
            },
            toggle: function(t) {
                this.mask ^= 1 << t | 0
            },
            disable: function(t) {
                this.mask &= ~(1 << t | 0)
            },
            disableAll: function() {
                this.mask = 0
            },
            test: function(t) {
                return 0 != (this.mask & t.mask)
            }
        });
        var Vo = 0,
            Wo = new r,
            qo = new n,
            Xo = new h,
            $o = new r,
            Yo = new r,
            Zo = new r,
            Jo = new n,
            Qo = new r(1, 0, 0),
            Ko = new r(0, 1, 0),
            ts = new r(0, 0, 1),
            es = {
                type: "added"
            },
            is = {
                type: "removed"
            };
        p.DefaultUp = new r(0, 1, 0), p.DefaultMatrixAutoUpdate = !0, p.prototype = Object.assign(Object.create(e.prototype), {
            constructor: p,
            isObject3D: !0,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t), this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function(t, e) {
                return qo.setFromAxisAngle(t, e), this.quaternion.multiply(qo), this
            },
            rotateOnWorldAxis: function(t, e) {
                return qo.setFromAxisAngle(t, e), this.quaternion.premultiply(qo), this
            },
            rotateX: function(t) {
                return this.rotateOnAxis(Qo, t)
            },
            rotateY: function(t) {
                return this.rotateOnAxis(Ko, t)
            },
            rotateZ: function(t) {
                return this.rotateOnAxis(ts, t)
            },
            translateOnAxis: function(t, e) {
                return Wo.copy(t).applyQuaternion(this.quaternion), this.position.add(Wo.multiplyScalar(e)), this
            },
            translateX: function(t) {
                return this.translateOnAxis(Qo, t)
            },
            translateY: function(t) {
                return this.translateOnAxis(Ko, t)
            },
            translateZ: function(t) {
                return this.translateOnAxis(ts, t)
            },
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function(t) {
                return t.applyMatrix4(Xo.getInverse(this.matrixWorld))
            },
            lookAt: function(t, e, i) {
                t.isVector3 ? $o.copy(t) : $o.set(t, e, i), t = this.parent, this.updateWorldMatrix(!0, !1), Yo.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Xo.lookAt(Yo, $o, this.up) : Xo.lookAt($o, Yo, this.up), this.quaternion.setFromRotationMatrix(Xo), t && (Xo.extractRotation(t.matrixWorld), qo.setFromRotationMatrix(Xo), this.quaternion.premultiply(qo.inverse()))
            },
            add: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(es)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                return -1 !== (e = this.children.indexOf(t)) && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(is)), this
            },
            attach: function(t) {
                return this.updateWorldMatrix(!0, !1), Xo.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Xo.multiply(t.parent.matrixWorld)), t.applyMatrix(Xo), t.updateWorldMatrix(!1, !1), this.add(t), this
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new r), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Yo, t, Zo), t
            },
            getWorldScale: function(t) {
                return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Yo, Jo, t), t
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new r), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(e[8], e[9], e[10]).normalize()
            },
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            },
            updateWorldMatrix: function(t, e) {
                var i = this.parent;
                if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                    for (e = 0, i = (t = this.children).length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
            },
            toJSON: function(t) {
                function e(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                }

                function i(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var n = void 0 === t || "string" == typeof t,
                    r = {};
                n && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                }, r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var o = {};
                if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                    o.geometry = e(t.geometries, this.geometry);
                    var s = this.geometry.parameters;
                    if (void 0 !== s && void 0 !== s.shapes)
                        if (s = s.shapes, Array.isArray(s))
                            for (var a = 0, l = s.length; a < l; a++) e(t.shapes, s[a]);
                        else e(t.shapes, s)
                }
                if (void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (s = [], a = 0, l = this.material.length; a < l; a++) s.push(e(t.materials, this.material[a]));
                        o.material = s
                    } else o.material = e(t.materials, this.material);
                if (0 < this.children.length)
                    for (o.children = [], a = 0; a < this.children.length; a++) o.children.push(this.children[a].toJSON(t).object);
                if (n) {
                    n = i(t.geometries), a = i(t.materials), l = i(t.textures);
                    var c = i(t.images);
                    s = i(t.shapes), 0 < n.length && (r.geometries = n), 0 < a.length && (r.materials = a), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < s.length && (r.shapes = s)
                }
                return r.object = o, r
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (e = 0; e < t.children.length; e++) this.add(t.children[e].clone());
                return this
            }
        }), f.prototype = Object.assign(Object.create(p.prototype), {
            constructor: f,
            isScene: !0,
            copy: function(t, e) {
                return p.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function(t) {
                var e = p.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var ns = [new r, new r, new r, new r, new r, new r, new r, new r],
            rs = new r,
            os = new r,
            ss = new r,
            as = new r,
            ls = new r,
            cs = new r,
            hs = new r,
            us = new r,
            ds = new r,
            ps = new r,
            fs = new r;
        Object.assign(m.prototype, {
            isBox3: !0,
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = t.length; a < l; a += 3) {
                    var c = t[a],
                        h = t[a + 1],
                        u = t[a + 2];
                    c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > s && (s = u)
                }
                return this.min.set(e, i, n), this.max.set(r, o, s), this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = t.count; a < l; a++) {
                    var c = t.getX(a),
                        h = t.getY(a),
                        u = t.getZ(a);
                    c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > s && (s = u)
                }
                return this.min.set(e, i, n), this.max.set(r, o, s), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function(t, e) {
                return e = rs.copy(e).multiplyScalar(.5), this.min.copy(t).sub(e), this.max.copy(t).add(e), this
            },
            setFromObject: function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new r), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new r), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: function(t) {
                var e;
                t.updateWorldMatrix(!1, !1);
                var i = t.geometry;
                if (void 0 !== i)
                    if (i.isGeometry) {
                        var n = i.vertices;
                        for (i = 0, e = n.length; i < e; i++) rs.copy(n[i]), rs.applyMatrix4(t.matrixWorld), this.expandByPoint(rs)
                    } else if (i.isBufferGeometry && void 0 !== (n = i.attributes.position))
                    for (i = 0, e = n.count; i < e; i++) rs.fromBufferAttribute(n, i).applyMatrix4(t.matrixWorld), this.expandByPoint(rs);
                for (i = 0, e = (t = t.children).length; i < e; i++) this.expandByObject(t[i]);
                return this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new r), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function(t) {
                return this.clampPoint(t.center, rs), rs.distanceToSquared(t.center) <= t.radius * t.radius
            },
            intersectsPlane: function(t) {
                if (0 < t.normal.x) var e = t.normal.x * this.min.x,
                    i = t.normal.x * this.max.x;
                else e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
                return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
            },
            intersectsTriangle: function(t) {
                return !this.isEmpty() && (this.getCenter(us), ds.subVectors(this.max, us), os.subVectors(t.a, us), ss.subVectors(t.b, us), as.subVectors(t.c, us), ls.subVectors(ss, os), cs.subVectors(as, ss), hs.subVectors(os, as), !!g(t = [0, -ls.z, ls.y, 0, -cs.z, cs.y, 0, -hs.z, hs.y, ls.z, 0, -ls.x, cs.z, 0, -cs.x, hs.z, 0, -hs.x, -ls.y, ls.x, 0, -cs.y, cs.x, 0, -hs.y, hs.x, 0], os, ss, as, ds) && (!!g(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], os, ss, as, ds) && (ps.crossVectors(ls, cs), g(t = [ps.x, ps.y, ps.z], os, ss, as, ds))))
            },
            clampPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new r), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function(t) {
                return rs.copy(t).clamp(this.min, this.max).sub(t).length()
            },
            getBoundingSphere: function(t) {
                return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(rs).length(), t
            },
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: function(t) {
                return this.isEmpty() ? this : (ns[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ns[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ns[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ns[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ns[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ns[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ns[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ns[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ns), this)
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        });
        var ms = new m;
        Object.assign(v.prototype, {
            set: function(t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: function(t, e) {
                var i = this.center;
                void 0 !== e ? i.copy(e) : ms.setFromPoints(t).getCenter(i);
                for (var n = e = 0, r = t.length; n < r; n++) e = Math.max(e, i.distanceToSquared(t[n]));
                return this.radius = Math.sqrt(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            empty: function() {
                return 0 >= this.radius
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(t.distanceToPoint(this.center)) <= this.radius
            },
            clampPoint: function(t, e) {
                var i = this.center.distanceToSquared(t);
                return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new r), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
            },
            getBoundingBox: function(t) {
                return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new m), t.set(this.center, this.center), t.expandByScalar(this.radius), t
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this
            },
            translate: function(t) {
                return this.center.add(t), this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        });
        var gs = new r,
            vs = new r,
            ys = new r,
            _s = new r,
            xs = new r,
            ws = new r,
            bs = new r;
        Object.assign(y.prototype, {
            set: function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new r), e.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: function(t) {
                return this.origin.copy(this.at(t, gs)), this
            },
            closestPointToPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new r), e.subVectors(t, this.origin), 0 > (t = e.dot(this.direction)) ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function(t) {
                var e = gs.subVectors(t, this.origin).dot(this.direction);
                return 0 > e ? this.origin.distanceToSquared(t) : (gs.copy(this.direction).multiplyScalar(e).add(this.origin), gs.distanceToSquared(t))
            },
            distanceSqToSegment: function(t, e, i, n) {
                vs.copy(t).add(e).multiplyScalar(.5), ys.copy(e).sub(t).normalize(), _s.copy(this.origin).sub(vs);
                var r = .5 * t.distanceTo(e),
                    o = -this.direction.dot(ys),
                    s = _s.dot(this.direction),
                    a = -_s.dot(ys),
                    l = _s.lengthSq(),
                    c = Math.abs(1 - o * o);
                if (0 < c) {
                    e = o * s - a;
                    var h = r * c;
                    0 <= (t = o * a - s) ? e >= -h ? e <= h ? o = (t *= r = 1 / c) * (t + o * (e *= r) + 2 * s) + e * (o * t + e + 2 * a) + l : (e = r, o = -(t = Math.max(0, -(o * e + s))) * t + e * (e + 2 * a) + l) : (e = -r, o = -(t = Math.max(0, -(o * e + s))) * t + e * (e + 2 * a) + l) : e <= -h ? o = -(t = Math.max(0, -(-o * r + s))) * t + (e = 0 < t ? -r : Math.min(Math.max(-r, -a), r)) * (e + 2 * a) + l : e <= h ? (t = 0, o = (e = Math.min(Math.max(-r, -a), r)) * (e + 2 * a) + l) : o = -(t = Math.max(0, -(o * r + s))) * t + (e = 0 < t ? r : Math.min(Math.max(-r, -a), r)) * (e + 2 * a) + l
                } else e = 0 < o ? -r : r, o = -(t = Math.max(0, -(o * e + s))) * t + e * (e + 2 * a) + l;
                return i && i.copy(this.direction).multiplyScalar(t).add(this.origin), n && n.copy(ys).multiplyScalar(e).add(vs), o
            },
            intersectSphere: function(t, e) {
                gs.subVectors(t.center, this.origin);
                var i = gs.dot(this.direction),
                    n = gs.dot(gs) - i * i;
                return n > (t = t.radius * t.radius) ? null : (n = i - (t = Math.sqrt(t - n)), i += t, 0 > n && 0 > i ? null : 0 > n ? this.at(i, e) : this.at(n, e))
            },
            intersectsSphere: function(t) {
                return this.distanceSqToPoint(t.center) <= t.radius * t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null
            },
            intersectPlane: function(t, e) {
                return null === (t = this.distanceToPlane(t)) ? null : this.at(t, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || 0 > t.normal.dot(this.direction) * e
            },
            intersectBox: function(t, e) {
                var i = 1 / this.direction.x,
                    n = 1 / this.direction.y,
                    r = 1 / this.direction.z,
                    o = this.origin;
                if (0 <= i) {
                    var s = (t.min.x - o.x) * i;
                    i *= t.max.x - o.x
                } else s = (t.max.x - o.x) * i, i *= t.min.x - o.x;
                if (0 <= n) {
                    var a = (t.min.y - o.y) * n;
                    n *= t.max.y - o.y
                } else a = (t.max.y - o.y) * n, n *= t.min.y - o.y;
                return s > n || a > i ? null : ((a > s || s != s) && (s = a), (n < i || i != i) && (i = n), 0 <= r ? (a = (t.min.z - o.z) * r, t = (t.max.z - o.z) * r) : (a = (t.max.z - o.z) * r, t = (t.min.z - o.z) * r), s > t || a > i ? null : ((a > s || s != s) && (s = a), (t < i || i != i) && (i = t), 0 > i ? null : this.at(0 <= s ? s : i, e)))
            },
            intersectsBox: function(t) {
                return null !== this.intersectBox(t, gs)
            },
            intersectTriangle: function(t, e, i, n, r) {
                if (xs.subVectors(e, t), ws.subVectors(i, t), bs.crossVectors(xs, ws), 0 < (e = this.direction.dot(bs))) {
                    if (n) return null;
                    n = 1
                } else {
                    if (!(0 > e)) return null;
                    n = -1, e = -e
                }
                return _s.subVectors(this.origin, t), 0 > (t = n * this.direction.dot(ws.crossVectors(_s, ws))) ? null : 0 > (i = n * this.direction.dot(xs.cross(_s))) || t + i > e ? null : 0 > (t = -n * _s.dot(bs)) ? null : this.at(t / e, r)
            },
            applyMatrix4: function(t) {
                return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        });
        var Ts = new r,
            Ss = new r,
            Ms = new r,
            Es = new r,
            As = new r,
            Ps = new r,
            Cs = new r,
            Rs = new r,
            Ls = new r,
            Os = new r;
        Object.assign(_, {
            getNormal: function(t, e, i, n) {
                return void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new r), n.subVectors(i, e), Ts.subVectors(t, e), n.cross(Ts), 0 < (t = n.lengthSq()) ? n.multiplyScalar(1 / Math.sqrt(t)) : n.set(0, 0, 0)
            },
            getBarycoord: function(t, e, i, n, o) {
                Ts.subVectors(n, e), Ss.subVectors(i, e), Ms.subVectors(t, e), t = Ts.dot(Ts), e = Ts.dot(Ss), i = Ts.dot(Ms);
                var s = Ss.dot(Ss);
                n = Ss.dot(Ms);
                var a = t * s - e * e;
                return void 0 === o && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), o = new r), 0 === a ? o.set(-2, -1, -1) : (s = (s * i - e * n) * (a = 1 / a), t = (t * n - e * i) * a, o.set(1 - s - t, t, s))
            },
            containsPoint: function(t, e, i, n) {
                return _.getBarycoord(t, e, i, n, Es), 0 <= Es.x && 0 <= Es.y && 1 >= Es.x + Es.y
            },
            getUV: function(t, e, i, n, r, o, s, a) {
                return this.getBarycoord(t, e, i, n, Es), a.set(0, 0), a.addScaledVector(r, Es.x), a.addScaledVector(o, Es.y), a.addScaledVector(s, Es.z), a
            },
            isFrontFacing: function(t, e, i, n) {
                return Ts.subVectors(i, e), Ss.subVectors(t, e), 0 > Ts.cross(Ss).dot(n)
            }
        }), Object.assign(_.prototype, {
            set: function(t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function(t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            getArea: function() {
                return Ts.subVectors(this.c, this.b), Ss.subVectors(this.a, this.b), .5 * Ts.cross(Ss).length()
            },
            getMidpoint: function(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new r), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            getNormal: function(t) {
                return _.getNormal(this.a, this.b, this.c, t)
            },
            getPlane: function(t) {
                return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new r), t.setFromCoplanarPoints(this.a, this.b, this.c)
            },
            getBarycoord: function(t, e) {
                return _.getBarycoord(t, this.a, this.b, this.c, e)
            },
            getUV: function(t, e, i, n, r) {
                return _.getUV(t, this.a, this.b, this.c, e, i, n, r)
            },
            containsPoint: function(t) {
                return _.containsPoint(t, this.a, this.b, this.c)
            },
            isFrontFacing: function(t) {
                return _.isFrontFacing(this.a, this.b, this.c, t)
            },
            intersectsBox: function(t) {
                return t.intersectsTriangle(this)
            },
            closestPointToPoint: function(t, e) {
                void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new r);
                var i = this.a,
                    n = this.b,
                    o = this.c;
                As.subVectors(n, i), Ps.subVectors(o, i), Rs.subVectors(t, i);
                var s = As.dot(Rs),
                    a = Ps.dot(Rs);
                if (0 >= s && 0 >= a) return e.copy(i);
                Ls.subVectors(t, n);
                var l = As.dot(Ls),
                    c = Ps.dot(Ls);
                if (0 <= l && c <= l) return e.copy(n);
                var h = s * c - l * a;
                if (0 >= h && 0 <= s && 0 >= l) return n = s / (s - l), e.copy(i).addScaledVector(As, n);
                Os.subVectors(t, o), t = As.dot(Os);
                var u = Ps.dot(Os);
                return 0 <= u && t <= u ? e.copy(o) : 0 >= (s = t * a - s * u) && 0 <= a && 0 >= u ? (h = a / (a - u), e.copy(i).addScaledVector(Ps, h)) : 0 >= (a = l * u - t * c) && 0 <= c - l && 0 <= t - u ? (Cs.subVectors(o, n), h = (c - l) / (c - l + (t - u)), e.copy(n).addScaledVector(Cs, h)) : (n = s * (o = 1 / (a + s + h)), h *= o, e.copy(i).addScaledVector(As, n).addScaledVector(Ps, h))
            },
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        });
        var ks = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            Ds = {
                h: 0,
                s: 0,
                l: 0
            },
            Is = {
                h: 0,
                s: 0,
                l: 0
            };
        Object.assign(x.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function(t) {
                return this.b = this.g = this.r = t, this
            },
            setHex: function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function(t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            },
            setHSL: function(t, e, i) {
                return t = Po.euclideanModulo(t, 1), e = Po.clamp(e, 0, 1), i = Po.clamp(i, 0, 1), 0 === e ? this.r = this.g = this.b = i : (i = 2 * i - (e = .5 >= i ? i * (1 + e) : i + e - i * e), this.r = w(i, e, t + 1 / 3), this.g = w(i, e, t), this.b = w(i, e, t - 1 / 3)), this
            },
            setStyle: function(t) {
                function e(e) {
                    void 0 !== e && 1 > parseFloat(e) && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n = i[2];
                    switch (i[1]) {
                        case "rgb":
                        case "rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                            if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                                n = parseFloat(i[1]) / 360;
                                var r = parseInt(i[2], 10) / 100,
                                    o = parseInt(i[3], 10) / 100;
                                return e(i[5]), this.setHSL(n, r, o)
                            }
                    }
                } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
                    if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                    if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
                }
                return t && 0 < t.length && (void 0 !== (i = ks[t]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function(t, e) {
                return void 0 === e && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            convertGammaToLinear: function(t) {
                return this.copyGammaToLinear(this, t), this
            },
            convertLinearToGamma: function(t) {
                return this.copyLinearToGamma(this, t), this
            },
            copySRGBToLinear: function(t) {
                return this.r = b(t.r), this.g = b(t.g), this.b = b(t.b), this
            },
            copyLinearToSRGB: function(t) {
                return this.r = T(t.r), this.g = T(t.g), this.b = T(t.b), this
            },
            convertSRGBToLinear: function() {
                return this.copySRGBToLinear(this), this
            },
            convertLinearToSRGB: function() {
                return this.copyLinearToSRGB(this), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                    h: 0,
                    s: 0,
                    l: 0
                });
                var e, i = this.r,
                    n = this.g,
                    r = this.b,
                    o = Math.max(i, n, r),
                    s = Math.min(i, n, r),
                    a = (s + o) / 2;
                if (s === o) s = e = 0;
                else {
                    var l = o - s;
                    switch (s = .5 >= a ? l / (o + s) : l / (2 - o - s), o) {
                        case i:
                            e = (n - r) / l + (n < r ? 6 : 0);
                            break;
                        case n:
                            e = (r - i) / l + 2;
                            break;
                        case r:
                            e = (i - n) / l + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = s, t.l = a, t
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, i) {
                return this.getHSL(Ds), Ds.h += t, Ds.s += e, Ds.l += i, this.setHSL(Ds.h, Ds.s, Ds.l), this
            },
            add: function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function(t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            lerpHSL: function(t, e) {
                this.getHSL(Ds), t.getHSL(Is), t = Po.lerp(Ds.h, Is.h, e);
                var i = Po.lerp(Ds.s, Is.s, e);
                return e = Po.lerp(Ds.l, Is.l, e), this.setHSL(t, i, e), this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function() {
                return this.getHex()
            }
        }), Object.assign(S.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        });
        var Ns = 0;
        M.prototype = Object.assign(Object.create(e.prototype), {
            constructor: M,
            isMaterial: !0,
            onBeforeCompile: function() {},
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i = t[e];
                        if (void 0 === i) console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        else if ("shading" === e) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                        else {
                            var n = this[e];
                            void 0 === n ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i
                        }
                    }
            },
            toJSON: function(t) {
                function e(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var i = void 0 === t || "string" == typeof t;
                i && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWrite = t.stencilWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes,
                    i = null;
                if (null !== e) {
                    var n = e.length;
                    i = Array(n);
                    for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
                }
                return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), E.prototype = Object.create(M.prototype), E.prototype.constructor = E, E.prototype.isMeshBasicMaterial = !0, E.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, Object.defineProperty(A.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(A.prototype, {
            isBufferAttribute: !0,
            onUploadCallback: function() {},
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new x), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, n = 0, r = 0, o = t.length; r < o; r++) {
                    var s = t[r];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), s = new i), e[n++] = s.x, e[n++] = s.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
                    var s = t[n];
                    void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new r), e[i++] = s.x, e[i++] = s.y, e[i++] = s.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new a), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
                }
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            },
            toJSON: function() {
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.prototype.slice.call(this.array),
                    normalized: this.normalized
                }
            }
        }), P.prototype = Object.create(A.prototype), P.prototype.constructor = P, C.prototype = Object.create(A.prototype), C.prototype.constructor = C, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, L.prototype = Object.create(A.prototype), L.prototype.constructor = L, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, k.prototype = Object.create(A.prototype), k.prototype.constructor = k, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, N.prototype = Object.create(A.prototype), N.prototype.constructor = N, Object.assign(z.prototype, {
            computeGroups: function(t) {
                var e = [],
                    i = void 0;
                t = t.faces;
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    if (r.materialIndex !== i) {
                        i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, e.push(o));
                        var o = {
                            start: 3 * n,
                            materialIndex: i
                        }
                    }
                }
                void 0 !== o && (o.count = 3 * n - o.start, e.push(o)), this.groups = e
            },
            fromGeometry: function(t) {
                var e = t.faces,
                    n = t.vertices,
                    r = t.faceVertexUvs,
                    o = r[0] && 0 < r[0].length,
                    s = r[1] && 0 < r[1].length,
                    a = t.morphTargets,
                    l = a.length;
                if (0 < l) {
                    for (var c = [], h = 0; h < l; h++) c[h] = {
                        name: a[h].name,
                        data: []
                    };
                    this.morphTargets.position = c
                }
                var u = t.morphNormals,
                    d = u.length;
                if (0 < d) {
                    var p = [];
                    for (h = 0; h < d; h++) p[h] = {
                        name: u[h].name,
                        data: []
                    };
                    this.morphTargets.normal = p
                }
                var f = t.skinIndices,
                    m = t.skinWeights,
                    g = f.length === n.length,
                    v = m.length === n.length;
                for (0 < n.length && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < e.length; h++) {
                    var y = e[h];
                    this.vertices.push(n[y.a], n[y.b], n[y.c]);
                    var _ = y.vertexNormals;
                    for (3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (_ = y.normal, this.normals.push(_, _, _)), 3 === (_ = y.vertexColors).length ? this.colors.push(_[0], _[1], _[2]) : (_ = y.color, this.colors.push(_, _, _)), !0 === o && (void 0 !== (_ = r[0][h]) ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === s && (void 0 !== (_ = r[1][h]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), _ = 0; _ < l; _++) {
                        var x = a[_].vertices;
                        c[_].data.push(x[y.a], x[y.b], x[y.c])
                    }
                    for (_ = 0; _ < d; _++) x = u[_].vertexNormals[h], p[_].data.push(x.a, x.b, x.c);
                    g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            }
        });
        var zs = 1,
            Fs = new h,
            Bs = new p,
            Hs = new r,
            Us = new m,
            Gs = new m,
            js = new r;
        B.prototype = Object.assign(Object.create(e.prototype), {
            constructor: B,
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(65535 < F(t) ? D : O)(t, 1) : this.index = t
            },
            addAttribute: function(t, e, i) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new A(e, i)))
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            setAttribute: function(t, e) {
                return this.attributes[t] = e, this
            },
            removeAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                var i = this.attributes.normal;
                return void 0 !== i && ((e = (new o).getNormalMatrix(t)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((e = (new o).getNormalMatrix(t)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function(t) {
                return Fs.makeRotationX(t), this.applyMatrix(Fs), this
            },
            rotateY: function(t) {
                return Fs.makeRotationY(t), this.applyMatrix(Fs), this
            },
            rotateZ: function(t) {
                return Fs.makeRotationZ(t), this.applyMatrix(Fs), this
            },
            translate: function(t, e, i) {
                return Fs.makeTranslation(t, e, i), this.applyMatrix(Fs), this
            },
            scale: function(t, e, i) {
                return Fs.makeScale(t, e, i), this.applyMatrix(Fs), this
            },
            lookAt: function(t) {
                return Bs.lookAt(t), Bs.updateMatrix(), this.applyMatrix(Bs.matrix), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(Hs).negate(), this.translate(Hs.x, Hs.y, Hs.z), this
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    t = new I(3 * e.vertices.length, 3);
                    var i = new I(3 * e.colors.length, 3);
                    this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new I(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            setFromPoints: function(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.push(r.x, r.y, r.z || 0)
                }
                return this.addAttribute("position", new I(e, 3)), this
            },
            updateFromObject: function(t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var i = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                    i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
                }
                return !0 === e.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new z).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                for (var i in this.addAttribute("position", new A(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new A(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new A(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new A(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new A(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) {
                    e = [];
                    for (var n = t.morphTargets[i], r = 0, o = n.length; r < o; r++) {
                        var s = n[r],
                            a = new I(3 * s.data.length, 3);
                        a.name = s.name, e.push(a.copyVector3sArray(s.data))
                    }
                    this.morphAttributes[i] = e
                }
                return 0 < t.skinIndices.length && (i = new I(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new I(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new m);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (void 0 !== t) {
                    if (this.boundingBox.setFromBufferAttribute(t), e) {
                        t = 0;
                        for (var i = e.length; t < i; t++) Us.setFromBufferAttribute(e[t]), this.boundingBox.expandByPoint(Us.min), this.boundingBox.expandByPoint(Us.max)
                    }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new v);
                var t = this.attributes.position,
                    e = this.morphAttributes.position;
                if (t) {
                    var i = this.boundingSphere.center;
                    if (Us.setFromBufferAttribute(t), e)
                        for (var n = 0, r = e.length; n < r; n++) {
                            var o = e[n];
                            Gs.setFromBufferAttribute(o), Us.expandByPoint(Gs.min), Us.expandByPoint(Gs.max)
                        }
                    Us.getCenter(i);
                    var s = 0;
                    for (n = 0, r = t.count; n < r; n++) js.fromBufferAttribute(t, n), s = Math.max(s, i.distanceToSquared(js));
                    if (e)
                        for (n = 0, r = e.length; n < r; n++) {
                            t = 0;
                            for (var a = (o = e[n]).count; t < a; t++) js.fromBufferAttribute(o, t), s = Math.max(s, i.distanceToSquared(js))
                        }
                    this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            },
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.attributes;
                if (e.position) {
                    var i = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3));
                    else
                        for (var n = e.normal.array, o = 0, s = n.length; o < s; o++) n[o] = 0;
                    n = e.normal.array;
                    var a = new r,
                        l = new r,
                        c = new r,
                        h = new r,
                        u = new r;
                    if (t) {
                        var d = t.array;
                        for (o = 0, s = t.count; o < s; o += 3) {
                            t = 3 * d[o + 0];
                            var p = 3 * d[o + 1],
                                f = 3 * d[o + 2];
                            a.fromArray(i, t), l.fromArray(i, p), c.fromArray(i, f), h.subVectors(c, l), u.subVectors(a, l), h.cross(u), n[t] += h.x, n[t + 1] += h.y, n[t + 2] += h.z, n[p] += h.x, n[p + 1] += h.y, n[p + 2] += h.z, n[f] += h.x, n[f + 1] += h.y, n[f + 2] += h.z
                        }
                    } else
                        for (o = 0, s = i.length; o < s; o += 9) a.fromArray(i, o), l.fromArray(i, o + 3), c.fromArray(i, o + 6), h.subVectors(c, l), u.subVectors(a, l), h.cross(u), n[o] = h.x, n[o + 1] = h.y, n[o + 2] = h.z, n[o + 3] = h.x, n[o + 4] = h.y, n[o + 5] = h.z, n[o + 6] = h.x, n[o + 7] = h.y, n[o + 8] = h.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (t && t.isBufferGeometry) {
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var i, n = this.attributes;
                    for (i in n)
                        if (void 0 !== t.attributes[i]) {
                            var r = n[i].array,
                                o = t.attributes[i],
                                s = o.array,
                                a = o.itemSize * e;
                            o = Math.min(s.length, r.length - a);
                            for (var l = 0; l < o; l++, a++) r[a] = s[l]
                        } return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            },
            normalizeNormals: function() {
                for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) js.x = t.getX(e), js.y = t.getY(e), js.z = t.getZ(e), js.normalize(), t.setXYZ(e, js.x, js.y, js.z)
            },
            toNonIndexed: function() {
                function t(t, e) {
                    var i = t.array;
                    t = t.itemSize;
                    for (var n, r = new i.constructor(e.length * t), o = 0, s = 0, a = e.length; s < a; s++) {
                        n = e[s] * t;
                        for (var l = 0; l < t; l++) r[o++] = i[n++]
                    }
                    return new A(r, t)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var e, i = new B,
                    n = this.index.array,
                    r = this.attributes;
                for (e in r) {
                    var o = r[e];
                    o = t(o, n), i.addAttribute(e, o)
                }
                var s = this.morphAttributes;
                for (e in s) {
                    var a = [],
                        l = s[e];
                    r = 0;
                    for (var c = l.length; r < c; r++) o = t(o = l[r], n), a.push(o);
                    i.morphAttributes[e] = a
                }
                for (r = 0, e = (n = this.groups).length; r < e; r++) o = n[r], i.addGroup(o.start, o.count, o.materialIndex);
                return i
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (c in e) void 0 !== e[c] && (t[c] = e[c]);
                    return t
                }
                t.data = {
                    attributes: {}
                }, null !== (e = this.index) && (t.data.index = {
                    type: e.array.constructor.name,
                    array: Array.prototype.slice.call(e.array)
                });
                var i = this.attributes;
                for (c in i) {
                    var n = (e = i[c]).toJSON();
                    "" !== e.name && (n.name = e.name), t.data.attributes[c] = n
                }
                i = {};
                var r = !1;
                for (c in this.morphAttributes) {
                    for (var o = this.morphAttributes[c], s = [], a = 0, l = o.length; a < l; a++) n = (e = o[a]).toJSON(), "" !== e.name && (n.name = e.name), s.push(n);
                    0 < s.length && (i[c] = s, r = !0)
                }
                r && (t.data.morphAttributes = i);
                var c = this.groups;
                return 0 < c.length && (t.data.groups = JSON.parse(JSON.stringify(c))), null !== (c = this.boundingSphere) && (t.data.boundingSphere = {
                    center: c.center.toArray(),
                    radius: c.radius
                }), t
            },
            clone: function() {
                return (new B).copy(this)
            },
            copy: function(t) {
                var e;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
                var i = t.index;
                for (s in null !== i && this.setIndex(i.clone()), i = t.attributes) this.addAttribute(s, i[s].clone());
                var n = t.morphAttributes;
                for (s in n) {
                    var r = [],
                        o = n[s];
                    for (i = 0, e = o.length; i < e; i++) r.push(o[i].clone());
                    this.morphAttributes[s] = r
                }
                var s = t.groups;
                for (i = 0, e = s.length; i < e; i++) n = s[i], this.addGroup(n.start, n.count, n.materialIndex);
                return null !== (s = t.boundingBox) && (this.boundingBox = s.clone()), null !== (s = t.boundingSphere) && (this.boundingSphere = s.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Vs = new h,
            Ws = new y,
            qs = new v,
            Xs = new r,
            $s = new r,
            Ys = new r,
            Zs = new r,
            Js = new r,
            Qs = new r,
            Ks = new r,
            ta = new r,
            ea = new r,
            ia = new i,
            na = new i,
            ra = new i,
            oa = new r,
            sa = new r;
        H.prototype = Object.assign(Object.create(p.prototype), {
            constructor: H,
            isMesh: !0,
            setDrawMode: function(t) {
                this.drawMode = t
            },
            copy: function(t) {
                return p.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    t = t.morphAttributes;
                    var e = Object.keys(t);
                    if (0 < e.length) {
                        var i = t[e[0]];
                        if (void 0 !== i)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
                                var n = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                            }
                    }
                } else void 0 !== (t = t.morphTargets) && 0 < t.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            raycast: function(t, e) {
                var n = this.geometry,
                    r = this.material,
                    o = this.matrixWorld;
                if (void 0 !== r && (null === n.boundingSphere && n.computeBoundingSphere(), qs.copy(n.boundingSphere), qs.applyMatrix4(o), !1 !== t.ray.intersectsSphere(qs) && (Vs.getInverse(o), Ws.copy(t.ray).applyMatrix4(Vs), null === n.boundingBox || !1 !== Ws.intersectsBox(n.boundingBox))))
                    if (n.isBufferGeometry) {
                        var s = n.index;
                        o = n.attributes.position;
                        var a, l, c = n.morphAttributes.position,
                            h = n.attributes.uv,
                            u = n.attributes.uv2,
                            d = n.groups,
                            p = n.drawRange;
                        if (null !== s)
                            if (Array.isArray(r)) {
                                var f = 0;
                                for (a = d.length; f < a; f++) {
                                    var m = d[f],
                                        g = r[m.materialIndex],
                                        v = Math.max(m.start, p.start);
                                    for (l = n = Math.min(m.start + m.count, p.start + p.count); v < l; v += 3) {
                                        n = s.getX(v);
                                        var y = s.getX(v + 1),
                                            x = s.getX(v + 2);
                                        (n = G(this, g, t, Ws, o, c, h, u, n, y, x)) && (n.faceIndex = Math.floor(v / 3), n.face.materialIndex = m.materialIndex, e.push(n))
                                    }
                                }
                            } else
                                for (f = v = Math.max(0, p.start), a = n = Math.min(s.count, p.start + p.count); f < a; f += 3) n = s.getX(f), y = s.getX(f + 1), x = s.getX(f + 2), (n = G(this, r, t, Ws, o, c, h, u, n, y, x)) && (n.faceIndex = Math.floor(f / 3), e.push(n));
                        else if (void 0 !== o)
                            if (Array.isArray(r))
                                for (f = 0, a = d.length; f < a; f++)
                                    for (g = r[(m = d[f]).materialIndex], v = Math.max(m.start, p.start), l = n = Math.min(m.start + m.count, p.start + p.count); v < l; v += 3)(n = G(this, g, t, Ws, o, c, h, u, n = v, y = v + 1, x = v + 2)) && (n.faceIndex = Math.floor(v / 3), n.face.materialIndex = m.materialIndex, e.push(n));
                            else
                                for (f = v = Math.max(0, p.start), a = n = Math.min(o.count, p.start + p.count); f < a; f += 3)(n = G(this, r, t, Ws, o, c, h, u, n = f, y = f + 1, x = f + 2)) && (n.faceIndex = Math.floor(f / 3), e.push(n))
                    } else if (n.isGeometry)
                    for (o = Array.isArray(r), c = n.vertices, h = n.faces, 0 < (n = n.faceVertexUvs[0]).length && (s = n), f = 0, a = h.length; f < a; f++) m = h[f], void 0 !== (n = o ? r[m.materialIndex] : r) && (u = c[m.a], d = c[m.b], p = c[m.c], n = U(this, n, t, Ws, u, d, p, oa)) && (s && s[f] && (g = s[f], ia.copy(g[0]), na.copy(g[1]), ra.copy(g[2]), n.uv = _.getUV(oa, u, d, p, ia, na, ra, new i)), n.face = m, n.faceIndex = f, e.push(n))
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var aa = 0,
            la = new h,
            ca = new p,
            ha = new r;
        j.prototype = Object.assign(Object.create(e.prototype), {
            constructor: j,
            isGeometry: !0,
            applyMatrix: function(t) {
                for (var e = (new o).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
                for (i = 0, n = this.faces.length; i < n; i++) {
                    (t = this.faces[i]).normal.applyMatrix3(e).normalize();
                    for (var r = 0, s = t.vertexNormals.length; r < s; r++) t.vertexNormals[r].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
            },
            rotateX: function(t) {
                return la.makeRotationX(t), this.applyMatrix(la), this
            },
            rotateY: function(t) {
                return la.makeRotationY(t), this.applyMatrix(la), this
            },
            rotateZ: function(t) {
                return la.makeRotationZ(t), this.applyMatrix(la), this
            },
            translate: function(t, e, i) {
                return la.makeTranslation(t, e, i), this.applyMatrix(la), this
            },
            scale: function(t, e, i) {
                return la.makeScale(t, e, i), this.applyMatrix(la), this
            },
            lookAt: function(t) {
                return ca.lookAt(t), ca.updateMatrix(), this.applyMatrix(ca.matrix), this
            },
            fromBufferGeometry: function(t) {
                function e(t, e, o, s) {
                    var a = void 0 === c ? [] : [n.colors[t].clone(), n.colors[e].clone(), n.colors[o].clone()];
                    s = new S(t, e, o, void 0 === l ? [] : [(new r).fromArray(l, 3 * t), (new r).fromArray(l, 3 * e), (new r).fromArray(l, 3 * o)], a, s), n.faces.push(s), void 0 !== h && n.faceVertexUvs[0].push([(new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * o)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * o)])
                }
                var n = this,
                    o = null !== t.index ? t.index.array : void 0,
                    s = t.attributes;
                if (void 0 === s.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                var a = s.position.array,
                    l = void 0 !== s.normal ? s.normal.array : void 0,
                    c = void 0 !== s.color ? s.color.array : void 0,
                    h = void 0 !== s.uv ? s.uv.array : void 0,
                    u = void 0 !== s.uv2 ? s.uv2.array : void 0;
                for (void 0 !== u && (this.faceVertexUvs[1] = []), s = 0; s < a.length; s += 3) n.vertices.push((new r).fromArray(a, s)), void 0 !== c && n.colors.push((new x).fromArray(c, s));
                var d = t.groups;
                if (0 < d.length)
                    for (s = 0; s < d.length; s++) {
                        var p = (a = d[s]).start,
                            f = p;
                        for (p += a.count; f < p; f += 3) void 0 !== o ? e(o[f], o[f + 1], o[f + 2], a.materialIndex) : e(f, f + 1, f + 2, a.materialIndex)
                    } else if (void 0 !== o)
                        for (s = 0; s < o.length; s += 3) e(o[s], o[s + 1], o[s + 2]);
                    else
                        for (s = 0; s < a.length / 3; s += 3) e(s, s + 1, s + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(ha).negate(), this.translate(ha.x, ha.y, ha.z), this
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius;
                e = 0 === e ? 1 : 1 / e;
                var i = new h;
                return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
            },
            computeFaceNormals: function() {
                for (var t = new r, e = new r, i = 0, n = this.faces.length; i < n; i++) {
                    var o = this.faces[i],
                        s = this.vertices[o.a],
                        a = this.vertices[o.b];
                    t.subVectors(this.vertices[o.c], a), e.subVectors(s, a), t.cross(e), t.normalize(), o.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                var e;
                void 0 === t && (t = !0);
                var i = Array(this.vertices.length),
                    n = 0;
                for (e = this.vertices.length; n < e; n++) i[n] = new r;
                if (t) {
                    var o = new r,
                        s = new r;
                    for (t = 0, n = this.faces.length; t < n; t++) {
                        e = this.faces[t];
                        var a = this.vertices[e.a],
                            l = this.vertices[e.b],
                            c = this.vertices[e.c];
                        o.subVectors(c, l), s.subVectors(a, l), o.cross(s), i[e.a].add(o), i[e.b].add(o), i[e.c].add(o)
                    }
                } else
                    for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++) i[(e = this.faces[t]).a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
                for (n = 0, e = this.vertices.length; n < e; n++) i[n].normalize();
                for (t = 0, n = this.faces.length; t < n; t++) 3 === (a = (e = this.faces[t]).vertexNormals).length ? (a[0].copy(i[e.a]), a[1].copy(i[e.b]), a[2].copy(i[e.c])) : (a[0] = i[e.a].clone(), a[1] = i[e.b].clone(), a[2] = i[e.c].clone());
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                var t;
                this.computeFaceNormals();
                var e = 0;
                for (t = this.faces.length; e < t; e++) {
                    var i = this.faces[e],
                        n = i.vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t, e, i = 0;
                for (e = this.faces.length; i < e; i++) {
                    var n = this.faces[i];
                    n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                    var o = 0;
                    for (t = n.vertexNormals.length; o < t; o++) n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone()
                }
                var s = new j;
                for (s.faces = this.faces, o = 0, t = this.morphTargets.length; o < t; o++) {
                    if (!this.morphNormals[o]) {
                        this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
                        var a = this.morphNormals[o].vertexNormals;
                        for (i = 0, e = this.faces.length; i < e; i++) {
                            var l = new r,
                                c = {
                                    a: new r,
                                    b: new r,
                                    c: new r
                                };
                            n.push(l), a.push(c)
                        }
                    }
                    for (a = this.morphNormals[o], s.vertices = this.morphTargets[o].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++) n = this.faces[i], l = a.faceNormals[i], c = a.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
                }
                for (i = 0, e = this.faces.length; i < e; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new m), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new v), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, i) {
                if (t && t.isGeometry) {
                    var n, r = this.vertices.length,
                        s = this.vertices,
                        a = t.vertices,
                        l = this.faces,
                        c = t.faces,
                        h = this.colors,
                        u = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new o).getNormalMatrix(e));
                    for (var d = 0, p = a.length; d < p; d++) {
                        var f = a[d].clone();
                        void 0 !== e && f.applyMatrix4(e), s.push(f)
                    }
                    for (d = 0, p = u.length; d < p; d++) h.push(u[d].clone());
                    for (d = 0, p = c.length; d < p; d++) {
                        var m = (a = c[d]).vertexNormals;
                        for (u = a.vertexColors, (h = new S(a.a + r, a.b + r, a.c + r)).normal.copy(a.normal), void 0 !== n && h.normal.applyMatrix3(n).normalize(), e = 0, s = m.length; e < s; e++) f = m[e].clone(), void 0 !== n && f.applyMatrix3(n).normalize(), h.vertexNormals.push(f);
                        for (h.color.copy(a.color), e = 0, s = u.length; e < s; e++) f = u[e], h.vertexColors.push(f.clone());
                        h.materialIndex = a.materialIndex + i, l.push(h)
                    }
                    for (d = 0, p = t.faceVertexUvs.length; d < p; d++)
                        for (i = t.faceVertexUvs[d], void 0 === this.faceVertexUvs[d] && (this.faceVertexUvs[d] = []), e = 0, s = i.length; e < s; e++) {
                            for (r = [], l = 0, c = (n = i[e]).length; l < c; l++) r.push(n[l].clone());
                            this.faceVertexUvs[d].push(r)
                        }
                } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
            },
            mergeMesh: function(t) {
                t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
            },
            mergeVertices: function() {
                var t, e = {},
                    i = [],
                    n = [],
                    r = Math.pow(10, 4),
                    o = 0;
                for (t = this.vertices.length; o < t; o++) {
                    var s = this.vertices[o];
                    void 0 === e[s = Math.round(s.x * r) + "_" + Math.round(s.y * r) + "_" + Math.round(s.z * r)] ? (e[s] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[e[s]]
                }
                for (e = [], o = 0, t = this.faces.length; o < t; o++)
                    for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], s = 0; 3 > s; s++)
                        if (r[s] === r[(s + 1) % 3]) {
                            e.push(o);
                            break
                        } for (o = e.length - 1; 0 <= o; o--)
                    for (r = e[o], this.faces.splice(r, 1), n = 0, t = this.faceVertexUvs.length; n < t; n++) this.faceVertexUvs[n].splice(r, 1);
                return o = this.vertices.length - i.length, this.vertices = i, o
            },
            setFromPoints: function(t) {
                this.vertices = [];
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.vertices.push(new r(n.x, n.y, n.z || 0))
                }
                return this
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort(function(t, e) {
                    return t.materialIndex - e.materialIndex
                });
                var n, r, o = this.faceVertexUvs[0],
                    s = this.faceVertexUvs[1];
                for (o && o.length === e && (n = []), s && s.length === e && (r = []), i = 0; i < e; i++) {
                    var a = t[i]._id;
                    n && n.push(o[a]), r && r.push(s[a])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                function t(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== c[e] ? c[e] : (c[e] = l.length / 3, l.push(t.x, t.y, t.z), c[e])
                }

                function i(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== u[e] ? u[e] : (u[e] = h.length, h.push(t.getHex()), u[e])
                }

                function n(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== p[e] ? p[e] : (p[e] = d.length / 2, d.push(t.x, t.y), p[e])
                }
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                    var o, s = this.parameters;
                    for (o in s) void 0 !== s[o] && (r[o] = s[o]);
                    return r
                }
                for (s = [], o = 0; o < this.vertices.length; o++) {
                    var a = this.vertices[o];
                    s.push(a.x, a.y, a.z)
                }
                a = [];
                var l = [],
                    c = {},
                    h = [],
                    u = {},
                    d = [],
                    p = {};
                for (o = 0; o < this.faces.length; o++) {
                    var f = this.faces[o],
                        m = void 0 !== this.faceVertexUvs[0][o],
                        g = 0 < f.normal.length(),
                        v = 0 < f.vertexNormals.length,
                        y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                        _ = 0 < f.vertexColors.length,
                        x = 0;
                    x = t(x, 0, 0), x = t(x, 1, !0), x = t(x, 2, !1), x = t(x, 3, m), x = t(x, 4, g), x = t(x, 5, v), x = t(x, 6, y), x = t(x, 7, _), a.push(x), a.push(f.a, f.b, f.c), a.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], a.push(n(m[0]), n(m[1]), n(m[2]))), g && a.push(e(f.normal)), v && (g = f.vertexNormals, a.push(e(g[0]), e(g[1]), e(g[2]))), y && a.push(i(f.color)), _ && (f = f.vertexColors, a.push(i(f[0]), i(f[1]), i(f[2])))
                }
                return r.data = {}, r.data.vertices = s, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < d.length && (r.data.uvs = [d]), r.data.faces = a, r
            },
            clone: function() {
                return (new j).copy(this)
            },
            copy: function(t) {
                var e, i, n;
                this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
                var r = t.vertices,
                    o = 0;
                for (e = r.length; o < e; o++) this.vertices.push(r[o].clone());
                for (o = 0, e = (r = t.colors).length; o < e; o++) this.colors.push(r[o].clone());
                for (o = 0, e = (r = t.faces).length; o < e; o++) this.faces.push(r[o].clone());
                for (o = 0, e = t.faceVertexUvs.length; o < e; o++) {
                    var s = t.faceVertexUvs[o];
                    for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = s.length; r < i; r++) {
                        var a = s[r],
                            l = [],
                            c = 0;
                        for (n = a.length; c < n; c++) l.push(a[c].clone());
                        this.faceVertexUvs[o].push(l)
                    }
                }
                for (o = 0, e = (c = t.morphTargets).length; o < e; o++) {
                    if ((n = {}).name = c[o].name, void 0 !== c[o].vertices)
                        for (n.vertices = [], r = 0, i = c[o].vertices.length; r < i; r++) n.vertices.push(c[o].vertices[r].clone());
                    if (void 0 !== c[o].normals)
                        for (n.normals = [], r = 0, i = c[o].normals.length; r < i; r++) n.normals.push(c[o].normals[r].clone());
                    this.morphTargets.push(n)
                }
                for (o = 0, e = (c = t.morphNormals).length; o < e; o++) {
                    if (n = {}, void 0 !== c[o].vertexNormals)
                        for (n.vertexNormals = [], r = 0, i = c[o].vertexNormals.length; r < i; r++) s = c[o].vertexNormals[r], (a = {}).a = s.a.clone(), a.b = s.b.clone(), a.c = s.c.clone(), n.vertexNormals.push(a);
                    if (void 0 !== c[o].faceNormals)
                        for (n.faceNormals = [], r = 0, i = c[o].faceNormals.length; r < i; r++) n.faceNormals.push(c[o].faceNormals[r].clone());
                    this.morphNormals.push(n)
                }
                for (o = 0, e = (r = t.skinWeights).length; o < e; o++) this.skinWeights.push(r[o].clone());
                for (o = 0, e = (r = t.skinIndices).length; o < e; o++) this.skinIndices.push(r[o].clone());
                for (o = 0, e = (r = t.lineDistances).length; o < e; o++) this.lineDistances.push(r[o]);
                return null !== (o = t.boundingBox) && (this.boundingBox = o.clone()), null !== (o = t.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var ua = function(t) {
                function e(e, i, n, r, o, s) {
                    t.call(this), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: i,
                        depth: n,
                        widthSegments: r,
                        heightSegments: o,
                        depthSegments: s
                    }, this.fromBufferGeometry(new da(e, i, n, r, o, s)), this.mergeVertices()
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e
            }(j),
            da = function(t) {
                function e(e, i, n, o, s, a) {
                    function l(t, e, i, n, o, s, a, l, g, v, y) {
                        var _ = s / g,
                            x = a / v,
                            w = s / 2,
                            b = a / 2,
                            T = l / 2;
                        a = g + 1;
                        var S, M, E = v + 1,
                            A = s = 0,
                            P = new r;
                        for (M = 0; M < E; M++) {
                            var C = M * x - b;
                            for (S = 0; S < a; S++) P[t] = (S * _ - w) * n, P[e] = C * o, P[i] = T, u.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[i] = 0 < l ? 1 : -1, d.push(P.x, P.y, P.z), p.push(S / g), p.push(1 - M / v), s += 1
                        }
                        for (M = 0; M < v; M++)
                            for (S = 0; S < g; S++) t = f + S + a * (M + 1), e = f + (S + 1) + a * (M + 1), i = f + (S + 1) + a * M, h.push(f + S + a * M, t, i), h.push(t, e, i), A += 6;
                        c.addGroup(m, A, y), m += A, f += s
                    }
                    t.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                        width: e,
                        height: i,
                        depth: n,
                        widthSegments: o,
                        heightSegments: s,
                        depthSegments: a
                    };
                    var c = this;
                    e = e || 1, i = i || 1, n = n || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1, a = Math.floor(a) || 1;
                    var h = [],
                        u = [],
                        d = [],
                        p = [],
                        f = 0,
                        m = 0;
                    l("z", "y", "x", -1, -1, n, i, e, a, s, 0), l("z", "y", "x", 1, -1, n, i, -e, a, s, 1), l("x", "z", "y", 1, 1, e, n, i, o, a, 2), l("x", "z", "y", 1, -1, e, n, -i, o, a, 3), l("x", "y", "z", 1, -1, e, i, n, o, s, 4), l("x", "y", "z", -1, -1, e, i, -n, o, s, 5), this.setIndex(h), this.addAttribute("position", new I(u, 3)), this.addAttribute("normal", new I(d, 3)), this.addAttribute("uv", new I(p, 2))
                }
                return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e
            }(B),
            pa = {
                clone: V,
                merge: W
            };
        q.prototype = Object.create(M.prototype), q.prototype.constructor = q, q.prototype.isShaderMaterial = !0, q.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = V(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, q.prototype.toJSON = function(t) {
            var e = M.prototype.toJSON.call(this, t);
            for (var i in e.uniforms = {}, this.uniforms) {
                var n = this.uniforms[i].value;
                e.uniforms[i] = n && n.isTexture ? {
                    type: "t",
                    value: n.toJSON(t).uuid
                } : n && n.isColor ? {
                    type: "c",
                    value: n.getHex()
                } : n && n.isVector2 ? {
                    type: "v2",
                    value: n.toArray()
                } : n && n.isVector3 ? {
                    type: "v3",
                    value: n.toArray()
                } : n && n.isVector4 ? {
                    type: "v4",
                    value: n.toArray()
                } : n && n.isMatrix3 ? {
                    type: "m3",
                    value: n.toArray()
                } : n && n.isMatrix4 ? {
                    type: "m4",
                    value: n.toArray()
                } : {
                    value: n
                }
            }
            for (var r in 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, t = {}, this.extensions) !0 === this.extensions[r] && (t[r] = !0);
            return 0 < Object.keys(t).length && (e.extensions = t), e
        }, X.prototype = Object.assign(Object.create(p.prototype), {
            constructor: X,
            isCamera: !0,
            copy: function(t, e) {
                return p.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
            },
            getWorldDirection: function(t) {
                void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new r), this.updateMatrixWorld(!0);
                var e = this.matrixWorld.elements;
                return t.set(-e[8], -e[9], -e[10]).normalize()
            },
            updateMatrixWorld: function(t) {
                p.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), $.prototype = Object.assign(Object.create(X.prototype), {
            constructor: $,
            isPerspectiveCamera: !0,
            copy: function(t, e) {
                return X.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                t = .5 * this.getFilmHeight() / t, this.fov = 2 * Po.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * Po.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * Po.RAD2DEG * Math.atan(Math.tan(.5 * Po.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, o) {
                this.aspect = t / e, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = this.near,
                    e = t * Math.tan(.5 * Po.DEG2RAD * this.fov) / this.zoom,
                    i = 2 * e,
                    n = this.aspect * i,
                    r = -.5 * n,
                    o = this.view;
                if (null !== this.view && this.view.enabled) {
                    var s = o.fullWidth,
                        a = o.fullHeight;
                    r += o.offsetX * n / s, e -= o.offsetY * i / a, n *= o.width / s, i *= o.height / a
                }
                0 !== (o = this.filmOffset) && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                return (t = p.prototype.toJSON.call(this, t)).object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }), Y.prototype = Object.create(p.prototype), Y.prototype.constructor = Y, Z.prototype = Object.create(l.prototype), Z.prototype.constructor = Z, Z.prototype.isWebGLRenderTargetCube = !0, Z.prototype.fromEquirectangularTexture = function(t, e) {
            this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
            var i = new f,
                n = new q({
                    type: "CubemapFromEquirect",
                    uniforms: V({
                        tEquirect: {
                            value: null
                        }
                    }),
                    vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
                    side: 1,
                    blending: 0
                });
            return n.uniforms.tEquirect.value = e, e = new H(new da(5, 5, 5), n), i.add(e), (n = new Y(1, 10, 1)).renderTarget = this, n.renderTarget.texture.name = "CubeCameraTexture", n.update(t, i), e.geometry.dispose(), e.material.dispose(), this
        }, J.prototype = Object.create(s.prototype), J.prototype.constructor = J, J.prototype.isDataTexture = !0;
        var fa = new r,
            ma = new r,
            ga = new o;
        Object.assign(Q.prototype, {
            isPlane: !0,
            set: function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function(t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: function(t, e, i) {
                return e = fa.subVectors(i, e).cross(ma.subVectors(t, e)).normalize(), this.setFromNormalAndCoplanarPoint(e, t), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
            },
            intersectLine: function(t, e) {
                void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new r);
                var i = t.delta(fa),
                    n = this.normal.dot(i);
                if (0 === n) {
                    if (0 === this.distanceToPoint(t.start)) return e.copy(t.start)
                } else if (!(0 > (n = -(t.start.dot(this.normal) + this.constant) / n) || 1 < n)) return e.copy(i).multiplyScalar(n).add(t.start)
            },
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start);
                return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function(t, e) {
                return e = e || ga.getNormalMatrix(t), t = this.coplanarPoint(fa).applyMatrix4(t), e = this.normal.applyMatrix3(e).normalize(), this.constant = -t.dot(e), this
            },
            translate: function(t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        });
        var va = new v,
            ya = new r;
        Object.assign(K.prototype, {
            set: function(t, e, i, n, r, o) {
                var s = this.planes;
                return s[0].copy(t), s[1].copy(e), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(o), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, i = 0; 6 > i; i++) e[i].copy(t.planes[i]);
                return this
            },
            setFromMatrix: function(t) {
                var e = this.planes,
                    i = t.elements;
                t = i[0];
                var n = i[1],
                    r = i[2],
                    o = i[3],
                    s = i[4],
                    a = i[5],
                    l = i[6],
                    c = i[7],
                    h = i[8],
                    u = i[9],
                    d = i[10],
                    p = i[11],
                    f = i[12],
                    m = i[13],
                    g = i[14];
                return i = i[15], e[0].setComponents(o - t, c - s, p - h, i - f).normalize(), e[1].setComponents(o + t, c + s, p + h, i + f).normalize(), e[2].setComponents(o + n, c + a, p + u, i + m).normalize(), e[3].setComponents(o - n, c - a, p - u, i - m).normalize(), e[4].setComponents(o - r, c - l, p - d, i - g).normalize(), e[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
            },
            intersectsObject: function(t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), va.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(va)
            },
            intersectsSprite: function(t) {
                return va.center.set(0, 0, 0), va.radius = .7071067811865476, va.applyMatrix4(t.matrixWorld), this.intersectsSphere(va)
            },
            intersectsSphere: function(t) {
                var e = this.planes,
                    i = t.center;
                t = -t.radius;
                for (var n = 0; 6 > n; n++)
                    if (e[n].distanceToPoint(i) < t) return !1;
                return !0
            },
            intersectsBox: function(t) {
                for (var e = this.planes, i = 0; 6 > i; i++) {
                    var n = e[i];
                    if (ya.x = 0 < n.normal.x ? t.max.x : t.min.x, ya.y = 0 < n.normal.y ? t.max.y : t.min.y, ya.z = 0 < n.normal.z ? t.max.z : t.min.z, 0 > n.distanceToPoint(ya)) return !1
                }
                return !0
            },
            containsPoint: function(t) {
                for (var e = this.planes, i = 0; 6 > i; i++)
                    if (0 > e[i].distanceToPoint(t)) return !1;
                return !0
            }
        });
        var _a = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
                clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            },
            xa = {
                common: {
                    diffuse: {
                        value: new x(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new o
                    },
                    alphaMap: {
                        value: null
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    },
                    maxMipLevel: {
                        value: 0
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new i(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new x(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new x(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new o
                    }
                },
                sprite: {
                    diffuse: {
                        value: new x(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new i(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    uvTransform: {
                        value: new o
                    }
                }
            },
            wa = {
                basic: {
                    uniforms: W([xa.common, xa.specularmap, xa.envmap, xa.aomap, xa.lightmap, xa.fog]),
                    vertexShader: _a.meshbasic_vert,
                    fragmentShader: _a.meshbasic_frag
                },
                lambert: {
                    uniforms: W([xa.common, xa.specularmap, xa.envmap, xa.aomap, xa.lightmap, xa.emissivemap, xa.fog, xa.lights, {
                        emissive: {
                            value: new x(0)
                        }
                    }]),
                    vertexShader: _a.meshlambert_vert,
                    fragmentShader: _a.meshlambert_frag
                },
                phong: {
                    uniforms: W([xa.common, xa.specularmap, xa.envmap, xa.aomap, xa.lightmap, xa.emissivemap, xa.bumpmap, xa.normalmap, xa.displacementmap, xa.gradientmap, xa.fog, xa.lights, {
                        emissive: {
                            value: new x(0)
                        },
                        specular: {
                            value: new x(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: _a.meshphong_vert,
                    fragmentShader: _a.meshphong_frag
                },
                standard: {
                    uniforms: W([xa.common, xa.envmap, xa.aomap, xa.lightmap, xa.emissivemap, xa.bumpmap, xa.normalmap, xa.displacementmap, xa.roughnessmap, xa.metalnessmap, xa.fog, xa.lights, {
                        emissive: {
                            value: new x(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _a.meshphysical_vert,
                    fragmentShader: _a.meshphysical_frag
                },
                matcap: {
                    uniforms: W([xa.common, xa.bumpmap, xa.normalmap, xa.displacementmap, xa.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: _a.meshmatcap_vert,
                    fragmentShader: _a.meshmatcap_frag
                },
                points: {
                    uniforms: W([xa.points, xa.fog]),
                    vertexShader: _a.points_vert,
                    fragmentShader: _a.points_frag
                },
                dashed: {
                    uniforms: W([xa.common, xa.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: _a.linedashed_vert,
                    fragmentShader: _a.linedashed_frag
                },
                depth: {
                    uniforms: W([xa.common, xa.displacementmap]),
                    vertexShader: _a.depth_vert,
                    fragmentShader: _a.depth_frag
                },
                normal: {
                    uniforms: W([xa.common, xa.bumpmap, xa.normalmap, xa.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _a.normal_vert,
                    fragmentShader: _a.normal_frag
                },
                sprite: {
                    uniforms: W([xa.sprite, xa.fog]),
                    vertexShader: _a.sprite_vert,
                    fragmentShader: _a.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new o
                        },
                        t2D: {
                            value: null
                        }
                    },
                    vertexShader: _a.background_vert,
                    fragmentShader: _a.background_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: _a.cube_vert,
                    fragmentShader: _a.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: _a.equirect_vert,
                    fragmentShader: _a.equirect_frag
                },
                distanceRGBA: {
                    uniforms: W([xa.common, xa.displacementmap, {
                        referencePosition: {
                            value: new r
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: _a.distanceRGBA_vert,
                    fragmentShader: _a.distanceRGBA_frag
                },
                shadow: {
                    uniforms: W([xa.lights, xa.fog, {
                        color: {
                            value: new x(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: _a.shadow_vert,
                    fragmentShader: _a.shadow_frag
                }
            };
        wa.physical = {
            uniforms: W([wa.standard.uniforms, {
                transparency: {
                    value: 0
                },
                clearcoat: {
                    value: 0
                },
                clearcoatRoughness: {
                    value: 0
                },
                sheen: {
                    value: new x(0)
                },
                clearcoatNormalScale: {
                    value: new i(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                }
            }]),
            vertexShader: _a.meshphysical_vert,
            fragmentShader: _a.meshphysical_frag
        }, it.prototype = Object.create(j.prototype), it.prototype.constructor = it, nt.prototype = Object.create(B.prototype), nt.prototype.constructor = nt, mt.prototype = Object.create(s.prototype), mt.prototype.constructor = mt, mt.prototype.isCubeTexture = !0, Object.defineProperty(mt.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        }), gt.prototype = Object.create(s.prototype), gt.prototype.constructor = gt, gt.prototype.isDataTexture2DArray = !0, vt.prototype = Object.create(s.prototype), vt.prototype.constructor = vt, vt.prototype.isDataTexture3D = !0;
        var ba = new s,
            Ta = new gt,
            Sa = new vt,
            Ma = new mt,
            Ea = [],
            Aa = [],
            Pa = new Float32Array(16),
            Ca = new Float32Array(9),
            Ra = new Float32Array(4);
        Jt.prototype.updateCache = function(t) {
            var e = this.cache;
            t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), xt(e, t)
        }, Qt.prototype.setValue = function(t, e, i) {
            for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
                var s = n[r];
                s.setValue(t, e[s.id], i)
            }
        };
        var La = /([\w\d_]+)(\])?(\[|\.)?/g;
        Kt.prototype.setValue = function(t, e, i, n) {
            void 0 !== (e = this.map[e]) && e.setValue(t, i, n)
        }, Kt.prototype.setOptional = function(t, e, i) {
            void 0 !== (e = e[i]) && this.setValue(t, i, e)
        }, Kt.upload = function(t, e, i, n) {
            for (var r = 0, o = e.length; r !== o; ++r) {
                var s = e[r],
                    a = i[s.id];
                !1 !== a.needsUpdate && s.setValue(t, a.value, n)
            }
        }, Kt.seqWithValue = function(t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var o = t[n];
                o.id in e && i.push(o)
            }
            return i
        };
        var Oa = 0,
            ka = /^[ \t]*#include +<([\w\d.\/]+)>/gm,
            Da = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
            Ia = 0;
        Se.prototype = Object.create(M.prototype), Se.prototype.constructor = Se, Se.prototype.isMeshDepthMaterial = !0, Se.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, Me.prototype = Object.create(M.prototype), Me.prototype.constructor = Me, Me.prototype.isMeshDistanceMaterial = !0, Me.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }, Re.prototype = Object.assign(Object.create(l.prototype), {
            constructor: Re,
            isWebGLMultiviewRenderTarget: !0,
            copy: function(t) {
                return l.prototype.copy.call(this, t), this.numViews = t.numViews, this
            },
            setNumViews: function(t) {
                return this.numViews !== t && (this.numViews = t, this.dispose()), this
            }
        }), Oe.prototype = Object.assign(Object.create(p.prototype), {
            constructor: Oe,
            isGroup: !0
        }), ke.prototype = Object.assign(Object.create($.prototype), {
            constructor: ke,
            isArrayCamera: !0
        });
        var Na = new r,
            za = new r;
        Object.assign(Ie.prototype, e.prototype), Object.assign(Ne.prototype, e.prototype), Object.assign(Fe.prototype, {
            isFogExp2: !0,
            clone: function() {
                return new Fe(this.color, this.density)
            },
            toJSON: function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }), Object.assign(Be.prototype, {
            isFog: !0,
            clone: function() {
                return new Be(this.color, this.near, this.far)
            },
            toJSON: function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }), Object.defineProperty(He.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(He.prototype, {
            isInterleavedBuffer: !0,
            onUploadCallback: function() {},
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            }
        }), Object.defineProperties(Ue.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(Ue.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), Ge.prototype = Object.create(M.prototype), Ge.prototype.constructor = Ge, Ge.prototype.isSpriteMaterial = !0, Ge.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
        };
        var Fa, Ba = new r,
            Ha = new r,
            Ua = new r,
            Ga = new i,
            ja = new i,
            Va = new h,
            Wa = new r,
            qa = new r,
            Xa = new r,
            $a = new i,
            Ya = new i,
            Za = new i;
        je.prototype = Object.assign(Object.create(p.prototype), {
            constructor: je,
            isSprite: !0,
            raycast: function(t, e) {
                null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ha.setFromMatrixScale(this.matrixWorld), Va.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Ua.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ha.multiplyScalar(-Ua.z);
                var n = this.material.rotation;
                if (0 !== n) var r = Math.cos(n),
                    o = Math.sin(n);
                n = this.center, Ve(Wa.set(-.5, -.5, 0), Ua, n, Ha, o, r), Ve(qa.set(.5, -.5, 0), Ua, n, Ha, o, r), Ve(Xa.set(.5, .5, 0), Ua, n, Ha, o, r), $a.set(0, 0), Ya.set(1, 0), Za.set(1, 1);
                var s = t.ray.intersectTriangle(Wa, qa, Xa, !1, Ba);
                null === s && (Ve(qa.set(-.5, .5, 0), Ua, n, Ha, o, r), Ya.set(0, 1), null === (s = t.ray.intersectTriangle(Wa, Xa, qa, !1, Ba))) || (o = t.ray.origin.distanceTo(Ba)) < t.near || o > t.far || e.push({
                    distance: o,
                    point: Ba.clone(),
                    uv: _.getUV(Ba, Wa, qa, Xa, $a, Ya, Za, new i),
                    face: null,
                    object: this
                })
            },
            clone: function() {
                return new this.constructor(this.material).copy(this)
            },
            copy: function(t) {
                return p.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
            }
        });
        var Ja = new r,
            Qa = new r;
        We.prototype = Object.assign(Object.create(p.prototype), {
            constructor: We,
            isLOD: !0,
            copy: function(t) {
                p.prototype.copy.call(this, t, !1);
                for (var e = 0, i = (t = t.levels).length; e < i; e++) {
                    var n = t[e];
                    this.addLevel(n.object.clone(), n.distance)
                }
                return this
            },
            addLevel: function(t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                return i.splice(n, 0, {
                    distance: e,
                    object: t
                }), this.add(t), this
            },
            getObjectForDistance: function(t) {
                for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                return e[i - 1].object
            },
            raycast: function(t, e) {
                Ja.setFromMatrixPosition(this.matrixWorld);
                var i = t.ray.origin.distanceTo(Ja);
                this.getObjectForDistance(i).raycast(t, e)
            },
            update: function(t) {
                var e = this.levels;
                if (1 < e.length) {
                    Ja.setFromMatrixPosition(t.matrixWorld), Qa.setFromMatrixPosition(this.matrixWorld), t = Ja.distanceTo(Qa), e[0].object.visible = !0;
                    for (var i = 1, n = e.length; i < n && t >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                    for (; i < n; i++) e[i].object.visible = !1
                }
            },
            toJSON: function(t) {
                (t = p.prototype.toJSON.call(this, t)).object.levels = [];
                for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    t.object.levels.push({
                        object: r.object.uuid,
                        distance: r.distance
                    })
                }
                return t
            }
        }), qe.prototype = Object.assign(Object.create(H.prototype), {
            constructor: qe,
            isSkinnedMesh: !0,
            bind: function(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                for (var t = new a, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                    t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                    var r = 1 / t.manhattanLength();
                    1 / 0 !== r ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                }
            },
            updateMatrixWorld: function(t) {
                H.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var Ka = new h,
            tl = new h;
        Object.assign(Xe.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new h;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function() {
                var t, e, i = 0;
                for (e = this.bones.length; i < e; i++)(t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
                for (i = 0, e = this.bones.length; i < e; i++)(t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            },
            update: function() {
                for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, o = t.length; r < o; r++) Ka.multiplyMatrices(t[r] ? t[r].matrixWorld : tl, e[r]), Ka.toArray(i, 16 * r);
                void 0 !== n && (n.needsUpdate = !0)
            },
            clone: function() {
                return new Xe(this.bones, this.boneInverses)
            },
            getBoneByName: function(t) {
                for (var e = 0, i = this.bones.length; e < i; e++) {
                    var n = this.bones[e];
                    if (n.name === t) return n
                }
            }
        }), $e.prototype = Object.assign(Object.create(p.prototype), {
            constructor: $e,
            isBone: !0
        }), Ye.prototype = Object.assign(Object.create(H.prototype), {
            constructor: Ye,
            isInstancedMesh: !0,
            raycast: function() {},
            setMatrixAt: function(t, e) {
                e.toArray(this.instanceMatrix.array, 16 * t)
            },
            updateMorphTargets: function() {}
        }), Ze.prototype = Object.create(M.prototype), Ze.prototype.constructor = Ze, Ze.prototype.isLineBasicMaterial = !0, Ze.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        };
        var el = new r,
            il = new r,
            nl = new h,
            rl = new y,
            ol = new v;
        Je.prototype = Object.assign(Object.create(p.prototype), {
            constructor: Je,
            isLine: !0,
            computeLineDistances: function() {
                var t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++) el.fromBufferAttribute(e, n - 1), il.fromBufferAttribute(e, n), i[n] = i[n - 1], i[n] += el.distanceTo(il);
                        t.addAttribute("lineDistance", new I(i, 1))
                    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (t.isGeometry)
                    for (e = t.vertices, (i = t.lineDistances)[0] = 0, n = 1, r = e.length; n < r; n++) i[n] = i[n - 1], i[n] += e[n - 1].distanceTo(e[n]);
                return this
            },
            raycast: function(t, e) {
                var i = t.linePrecision,
                    n = this.geometry,
                    o = this.matrixWorld;
                if (null === n.boundingSphere && n.computeBoundingSphere(), ol.copy(n.boundingSphere), ol.applyMatrix4(o), ol.radius += i, !1 !== t.ray.intersectsSphere(ol)) {
                    nl.getInverse(o), rl.copy(t.ray).applyMatrix4(nl), i /= (this.scale.x + this.scale.y + this.scale.z) / 3, i *= i;
                    var s = new r,
                        a = new r;
                    o = new r;
                    var l = new r,
                        c = this && this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        var h = n.index,
                            u = n.attributes.position.array;
                        if (null !== h) {
                            n = 0;
                            for (var d = (h = h.array).length - 1; n < d; n += c) {
                                var p = h[n + 1];
                                s.fromArray(u, 3 * h[n]), a.fromArray(u, 3 * p), (p = rl.distanceSqToSegment(s, a, l, o)) > i || (l.applyMatrix4(this.matrixWorld), (p = t.ray.origin.distanceTo(l)) < t.near || p > t.far || e.push({
                                    distance: p,
                                    point: o.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else
                            for (n = 0, d = u.length / 3 - 1; n < d; n += c) s.fromArray(u, 3 * n), a.fromArray(u, 3 * n + 3), (p = rl.distanceSqToSegment(s, a, l, o)) > i || (l.applyMatrix4(this.matrixWorld), (p = t.ray.origin.distanceTo(l)) < t.near || p > t.far || e.push({
                                distance: p,
                                point: o.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    } else if (n.isGeometry)
                        for (a = (s = n.vertices).length, n = 0; n < a - 1; n += c)(p = rl.distanceSqToSegment(s[n], s[n + 1], l, o)) > i || (l.applyMatrix4(this.matrixWorld), (p = t.ray.origin.distanceTo(l)) < t.near || p > t.far || e.push({
                            distance: p,
                            point: o.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                }
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        });
        var sl = new r,
            al = new r;
        Qe.prototype = Object.assign(Object.create(Je.prototype), {
            constructor: Qe,
            isLineSegments: !0,
            computeLineDistances: function() {
                var t = this.geometry;
                if (t.isBufferGeometry)
                    if (null === t.index) {
                        for (var e = t.attributes.position, i = [], n = 0, r = e.count; n < r; n += 2) sl.fromBufferAttribute(e, n), al.fromBufferAttribute(e, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + sl.distanceTo(al);
                        t.addAttribute("lineDistance", new I(i, 1))
                    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (t.isGeometry)
                    for (e = t.vertices, i = t.lineDistances, n = 0, r = e.length; n < r; n += 2) sl.copy(e[n]), al.copy(e[n + 1]), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + sl.distanceTo(al);
                return this
            }
        }), Ke.prototype = Object.assign(Object.create(Je.prototype), {
            constructor: Ke,
            isLineLoop: !0
        }), ti.prototype = Object.create(M.prototype), ti.prototype.constructor = ti, ti.prototype.isPointsMaterial = !0, ti.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
        };
        var ll = new h,
            cl = new y,
            hl = new v,
            ul = new r;
        ei.prototype = Object.assign(Object.create(p.prototype), {
            constructor: ei,
            isPoints: !0,
            raycast: function(t, e) {
                var i = this.geometry,
                    n = this.matrixWorld,
                    r = t.params.Points.threshold;
                if (null === i.boundingSphere && i.computeBoundingSphere(), hl.copy(i.boundingSphere), hl.applyMatrix4(n), hl.radius += r, !1 !== t.ray.intersectsSphere(hl))
                    if (ll.getInverse(n), cl.copy(t.ray).applyMatrix4(ll), r /= (this.scale.x + this.scale.y + this.scale.z) / 3, r *= r, i.isBufferGeometry) {
                        var o = i.index;
                        if (i = i.attributes.position.array, null !== o) {
                            var s = o.array;
                            o = 0;
                            for (var a = s.length; o < a; o++) {
                                var l = s[o];
                                ul.fromArray(i, 3 * l), ii(ul, l, r, n, t, e, this)
                            }
                        } else
                            for (o = 0, s = i.length / 3; o < s; o++) ul.fromArray(i, 3 * o), ii(ul, o, r, n, t, e, this)
                    } else
                        for (o = 0, s = (i = i.vertices).length; o < s; o++) ii(i[o], o, r, n, t, e, this)
            },
            updateMorphTargets: function() {
                var t = this.geometry;
                if (t.isBufferGeometry) {
                    t = t.morphAttributes;
                    var e = Object.keys(t);
                    if (0 < e.length) {
                        var i = t[e[0]];
                        if (void 0 !== i)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
                                var n = i[t].name || String(t);
                                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                            }
                    }
                } else void 0 !== (t = t.morphTargets) && 0 < t.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), ni.prototype = Object.assign(Object.create(s.prototype), {
            constructor: ni,
            isVideoTexture: !0,
            update: function() {
                var t = this.image;
                t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }), ri.prototype = Object.create(s.prototype), ri.prototype.constructor = ri, ri.prototype.isCompressedTexture = !0, oi.prototype = Object.create(s.prototype), oi.prototype.constructor = oi, oi.prototype.isCanvasTexture = !0, si.prototype = Object.create(s.prototype), si.prototype.constructor = si, si.prototype.isDepthTexture = !0, ai.prototype = Object.create(B.prototype), ai.prototype.constructor = ai, li.prototype = Object.create(j.prototype), li.prototype.constructor = li, ci.prototype = Object.create(B.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(j.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(B.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(j.prototype), di.prototype.constructor = di, pi.prototype = Object.create(ui.prototype), pi.prototype.constructor = pi, fi.prototype = Object.create(j.prototype), fi.prototype.constructor = fi, mi.prototype = Object.create(ui.prototype), mi.prototype.constructor = mi, gi.prototype = Object.create(j.prototype), gi.prototype.constructor = gi, vi.prototype = Object.create(ui.prototype), vi.prototype.constructor = vi, yi.prototype = Object.create(j.prototype), yi.prototype.constructor = yi, _i.prototype = Object.create(ui.prototype), _i.prototype.constructor = _i, xi.prototype = Object.create(j.prototype), xi.prototype.constructor = xi, wi.prototype = Object.create(B.prototype), wi.prototype.constructor = wi, wi.prototype.toJSON = function() {
            var t = B.prototype.toJSON.call(this);
            return t.path = this.parameters.path.toJSON(), t
        }, bi.prototype = Object.create(j.prototype), bi.prototype.constructor = bi, Ti.prototype = Object.create(B.prototype), Ti.prototype.constructor = Ti, Si.prototype = Object.create(j.prototype), Si.prototype.constructor = Si, Mi.prototype = Object.create(B.prototype), Mi.prototype.constructor = Mi;
        var dl = function(t, e, i) {
                i = i || 2;
                var n, r = e && e.length,
                    o = r ? e[0] * i : t.length,
                    s = Ei(t, 0, o, i, !0),
                    a = [];
                if (!s || s.next === s.prev) return a;
                if (r) {
                    var l, c = i;
                    r = [];
                    var h = 0;
                    for (l = e.length; h < l; h++) {
                        var u = e[h] * c;
                        (u = Ei(t, u, h < l - 1 ? e[h + 1] * c : t.length, c, !1)) === u.next && (u.steiner = !0), r.push(Oi(u))
                    }
                    for (r.sort(Ci), h = 0; h < r.length; h++)(c = Ri(e = r[h], c = s)) && Ai(e = Fi(c, e), e.next), s = Ai(s, s.next)
                }
                if (t.length > 80 * i) {
                    var d = n = t[0],
                        p = r = t[1];
                    for (c = i; c < o; c += i)(h = t[c]) < d && (d = h), (e = t[c + 1]) < p && (p = e), h > n && (n = h), e > r && (r = e);
                    n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0
                }
                return function t(e, i, n, r, o, s, a) {
                    if (e) {
                        if (!a && s) {
                            var l = e,
                                c = l;
                            do {
                                null === c.z && (c.z = Li(c.x, c.y, r, o, s)), c.prevZ = c.prev, c = c.nextZ = c.next
                            } while (c !== l);
                            c.prevZ.nextZ = null, c.prevZ = null, l = c;
                            var h, u, d, p, f = 1;
                            do {
                                c = l;
                                var m = l = null;
                                for (u = 0; c;) {
                                    u++;
                                    var g = c;
                                    for (h = d = 0; h < f && (d++, g = g.nextZ); h++);
                                    for (p = f; 0 < d || 0 < p && g;) 0 !== d && (0 === p || !g || c.z <= g.z) ? (h = c, c = c.nextZ, d--) : (h = g, g = g.nextZ, p--), m ? m.nextZ = h : l = h, h.prevZ = m, m = h;
                                    c = g
                                }
                                m.nextZ = null, f *= 2
                            } while (1 < u)
                        }
                        for (l = e; e.prev !== e.next;) {
                            if (c = e.prev, g = e.next, s) m = Pi(e, r, o, s);
                            else t: if (m = e, u = m.prev, d = m, f = m.next, 0 <= Di(u, d, f)) m = !1;
                                else {
                                    for (h = m.next.next; h !== m.prev;) {
                                        if (ki(u.x, u.y, d.x, d.y, f.x, f.y, h.x, h.y) && 0 <= Di(h.prev, h, h.next)) {
                                            m = !1;
                                            break t
                                        }
                                        h = h.next
                                    }
                                    m = !0
                                } if (m) i.push(c.i / n), i.push(e.i / n), i.push(g.i / n), Hi(e), l = e = g.next;
                            else if ((e = g) === l) {
                                if (a) {
                                    if (1 === a) {
                                        a = i, l = n, c = e;
                                        do {
                                            !Ii(g = c.prev, m = c.next.next) && Ni(g, c, c.next, m) && zi(g, m) && zi(m, g) && (a.push(g.i / l), a.push(c.i / l), a.push(m.i / l), Hi(c), Hi(c.next), c = e = m), c = c.next
                                        } while (c !== e);
                                        t(e = c, i, n, r, o, s, 2)
                                    } else if (2 === a) t: {
                                        a = e;do {
                                            for (l = a.next.next; l !== a.prev;) {
                                                if (c = a.i !== l.i) {
                                                    if (g = l, m = (c = a).next.i !== g.i && c.prev.i !== g.i) {
                                                        e: {
                                                            m = c;do {
                                                                if (m.i !== c.i && m.next.i !== c.i && m.i !== g.i && m.next.i !== g.i && Ni(m, m.next, c, g)) {
                                                                    m = !0;
                                                                    break e
                                                                }
                                                                m = m.next
                                                            } while (m !== c);m = !1
                                                        }
                                                        m = !m
                                                    }
                                                    if (m = m && zi(c, g) && zi(g, c)) {
                                                        m = c, u = !1, d = (c.x + g.x) / 2, g = (c.y + g.y) / 2;
                                                        do {
                                                            m.y > g != m.next.y > g && m.next.y !== m.y && d < (m.next.x - m.x) * (g - m.y) / (m.next.y - m.y) + m.x && (u = !u), m = m.next
                                                        } while (m !== c);
                                                        m = u
                                                    }
                                                    c = m
                                                }
                                                if (c) {
                                                    e = Fi(a, l), a = Ai(a, a.next), e = Ai(e, e.next), t(a, i, n, r, o, s), t(e, i, n, r, o, s);
                                                    break t
                                                }
                                                l = l.next
                                            }
                                            a = a.next
                                        } while (a !== e)
                                    }
                                } else t(Ai(e), i, n, r, o, s, 1);
                                break
                            }
                        }
                    }
                }(s, a, i, d, p, n), a
            },
            pl = {
                area: function(t) {
                    for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                },
                isClockWise: function(t) {
                    return 0 > pl.area(t)
                },
                triangulateShape: function(t, e) {
                    var i = [],
                        n = [],
                        r = [];
                    Gi(t), ji(i, t);
                    var o = t.length;
                    for (e.forEach(Gi), t = 0; t < e.length; t++) n.push(o), o += e[t].length, ji(i, e[t]);
                    for (e = dl(i, n), t = 0; t < e.length; t += 3) r.push(e.slice(t, t + 3));
                    return r
                }
            };
        Vi.prototype = Object.create(j.prototype), Vi.prototype.constructor = Vi, Vi.prototype.toJSON = function() {
            var t = j.prototype.toJSON.call(this);
            return qi(this.parameters.shapes, this.parameters.options, t)
        }, Wi.prototype = Object.create(B.prototype), Wi.prototype.constructor = Wi, Wi.prototype.toJSON = function() {
            var t = B.prototype.toJSON.call(this);
            return qi(this.parameters.shapes, this.parameters.options, t)
        };
        var fl = {
            generateTopUV: function(t, e, n, r, o) {
                t = e[3 * r], r = e[3 * r + 1];
                var s = e[3 * o];
                return o = e[3 * o + 1], [new i(e[3 * n], e[3 * n + 1]), new i(t, r), new i(s, o)]
            },
            generateSideWallUV: function(t, e, n, r, o, s) {
                t = e[3 * n];
                var a = e[3 * n + 1];
                n = e[3 * n + 2];
                var l = e[3 * r],
                    c = e[3 * r + 1];
                r = e[3 * r + 2];
                var h = e[3 * o],
                    u = e[3 * o + 1];
                o = e[3 * o + 2];
                var d = e[3 * s],
                    p = e[3 * s + 1];
                return e = e[3 * s + 2], .01 > Math.abs(a - c) ? [new i(t, 1 - n), new i(l, 1 - r), new i(h, 1 - o), new i(d, 1 - e)] : [new i(a, 1 - n), new i(c, 1 - r), new i(u, 1 - o), new i(p, 1 - e)]
            }
        };
        Xi.prototype = Object.create(j.prototype), Xi.prototype.constructor = Xi, $i.prototype = Object.create(Wi.prototype), $i.prototype.constructor = $i, Yi.prototype = Object.create(j.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(B.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(j.prototype), Ji.prototype.constructor = Ji, Qi.prototype = Object.create(B.prototype), Qi.prototype.constructor = Qi, Ki.prototype = Object.create(j.prototype), Ki.prototype.constructor = Ki, tn.prototype = Object.create(B.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(j.prototype), en.prototype.constructor = en, en.prototype.toJSON = function() {
            var t = j.prototype.toJSON.call(this);
            return rn(this.parameters.shapes, t)
        }, nn.prototype = Object.create(B.prototype), nn.prototype.constructor = nn, nn.prototype.toJSON = function() {
            var t = B.prototype.toJSON.call(this);
            return rn(this.parameters.shapes, t)
        }, on.prototype = Object.create(B.prototype), on.prototype.constructor = on, sn.prototype = Object.create(j.prototype), sn.prototype.constructor = sn, an.prototype = Object.create(B.prototype), an.prototype.constructor = an, ln.prototype = Object.create(sn.prototype), ln.prototype.constructor = ln, cn.prototype = Object.create(an.prototype), cn.prototype.constructor = cn, hn.prototype = Object.create(j.prototype), hn.prototype.constructor = hn, un.prototype = Object.create(B.prototype), un.prototype.constructor = un;
        var ml = Object.freeze({
            WireframeGeometry: ai,
            ParametricGeometry: li,
            ParametricBufferGeometry: ci,
            TetrahedronGeometry: di,
            TetrahedronBufferGeometry: pi,
            OctahedronGeometry: fi,
            OctahedronBufferGeometry: mi,
            IcosahedronGeometry: gi,
            IcosahedronBufferGeometry: vi,
            DodecahedronGeometry: yi,
            DodecahedronBufferGeometry: _i,
            PolyhedronGeometry: hi,
            PolyhedronBufferGeometry: ui,
            TubeGeometry: xi,
            TubeBufferGeometry: wi,
            TorusKnotGeometry: bi,
            TorusKnotBufferGeometry: Ti,
            TorusGeometry: Si,
            TorusBufferGeometry: Mi,
            TextGeometry: Xi,
            TextBufferGeometry: $i,
            SphereGeometry: Yi,
            SphereBufferGeometry: Zi,
            RingGeometry: Ji,
            RingBufferGeometry: Qi,
            PlaneGeometry: it,
            PlaneBufferGeometry: nt,
            LatheGeometry: Ki,
            LatheBufferGeometry: tn,
            ShapeGeometry: en,
            ShapeBufferGeometry: nn,
            ExtrudeGeometry: Vi,
            ExtrudeBufferGeometry: Wi,
            EdgesGeometry: on,
            ConeGeometry: ln,
            ConeBufferGeometry: cn,
            CylinderGeometry: sn,
            CylinderBufferGeometry: an,
            CircleGeometry: hn,
            CircleBufferGeometry: un,
            BoxGeometry: ua,
            BoxBufferGeometry: da
        });
        dn.prototype = Object.create(M.prototype), dn.prototype.constructor = dn, dn.prototype.isShadowMaterial = !0, dn.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this
        }, pn.prototype = Object.create(q.prototype), pn.prototype.constructor = pn, pn.prototype.isRawShaderMaterial = !0, fn.prototype = Object.create(M.prototype), fn.prototype.constructor = fn, fn.prototype.isMeshStandardMaterial = !0, fn.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, mn.prototype = Object.create(fn.prototype), mn.prototype.constructor = mn, mn.prototype.isMeshPhysicalMaterial = !0, mn.prototype.copy = function(t) {
            return fn.prototype.copy.call(this, t), this.defines = {
                STANDARD: "",
                PHYSICAL: ""
            }, this.reflectivity = t.reflectivity, this.clearcoat = t.clearcoat, this.clearcoatRoughness = t.clearcoatRoughness, this.sheen = t.sheen ? (this.sheen || new x).copy(t.sheen) : null, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.transparency = t.transparency, this
        }, gn.prototype = Object.create(M.prototype), gn.prototype.constructor = gn, gn.prototype.isMeshPhongMaterial = !0, gn.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, vn.prototype = Object.create(gn.prototype), vn.prototype.constructor = vn, vn.prototype.isMeshToonMaterial = !0, vn.prototype.copy = function(t) {
            return gn.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, yn.prototype = Object.create(M.prototype), yn.prototype.constructor = yn, yn.prototype.isMeshNormalMaterial = !0, yn.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, _n.prototype = Object.create(M.prototype), _n.prototype.constructor = _n, _n.prototype.isMeshLambertMaterial = !0, _n.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, xn.prototype = Object.create(M.prototype), xn.prototype.constructor = xn, xn.prototype.isMeshMatcapMaterial = !0, xn.prototype.copy = function(t) {
            return M.prototype.copy.call(this, t), this.defines = {
                MATCAP: ""
            }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, wn.prototype = Object.create(Ze.prototype), wn.prototype.constructor = wn, wn.prototype.isLineDashedMaterial = !0, wn.prototype.copy = function(t) {
            return Ze.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var gl = Object.freeze({
                ShadowMaterial: dn,
                SpriteMaterial: Ge,
                RawShaderMaterial: pn,
                ShaderMaterial: q,
                PointsMaterial: ti,
                MeshPhysicalMaterial: mn,
                MeshStandardMaterial: fn,
                MeshPhongMaterial: gn,
                MeshToonMaterial: vn,
                MeshNormalMaterial: yn,
                MeshLambertMaterial: _n,
                MeshDepthMaterial: Se,
                MeshDistanceMaterial: Me,
                MeshBasicMaterial: E,
                MeshMatcapMaterial: xn,
                LineDashedMaterial: wn,
                LineBasicMaterial: Ze,
                Material: M
            }),
            vl = {
                arraySlice: function(t, e, i) {
                    return vl.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                },
                convertArray: function(t, e, i) {
                    return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    for (var e = t.length, i = Array(e), n = 0; n !== e; ++n) i[n] = n;
                    return i.sort(function(e, i) {
                        return t[e] - t[i]
                    }), i
                },
                sortedArray: function(t, e, i) {
                    for (var n = t.length, r = new t.constructor(n), o = 0, s = 0; s !== n; ++o)
                        for (var a = i[o] * e, l = 0; l !== e; ++l) r[s++] = t[a + l];
                    return r
                },
                flattenJSON: function(t, e, i, n) {
                    for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
                    if (void 0 !== o) {
                        var s = o[n];
                        if (void 0 !== s)
                            if (Array.isArray(s))
                                do {
                                    void 0 !== (s = o[n]) && (e.push(o.time), i.push.apply(i, s)), o = t[r++]
                                } while (void 0 !== o);
                            else if (void 0 !== s.toArray)
                            do {
                                void 0 !== (s = o[n]) && (e.push(o.time), s.toArray(i, i.length)), o = t[r++]
                            } while (void 0 !== o);
                        else
                            do {
                                void 0 !== (s = o[n]) && (e.push(o.time), i.push(s)), o = t[r++]
                            } while (void 0 !== o)
                    }
                }
            };
        Object.assign(bn.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    n = e[i],
                    r = e[i - 1];
                t: {
                    e: {
                        i: {
                            n: if (!(t < n)) {
                                for (var o = i + 2;;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === o) break;
                                    if (r = n, t < (n = e[++i])) break e
                                }
                                n = e.length;
                                break i
                            }if (t >= r) break t;
                            for (t < (o = e[1]) && (i = 2, r = o), o = i - 2;;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (i === o) break;
                                if (n = r, t >= (r = e[--i - 1])) break e
                            }
                            n = i,
                            i = 0
                        }
                        for (; i < n;) t < e[r = i + n >>> 1] ? n = r : i = r + 1;
                        if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0,
                        this.beforeStart_(0, t, n);
                        if (void 0 === n) return this._cachedIndex = i = e.length,
                        this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                var e = this.resultBuffer,
                    i = this.sampleValues,
                    n = this.valueSize;
                t *= n;
                for (var r = 0; r !== n; ++r) e[r] = i[t + r];
                return e
            },
            interpolate_: function() {
                throw Error("call to abstract method")
            },
            intervalChanged_: function() {}
        }), Object.assign(bn.prototype, {
            beforeStart_: bn.prototype.copySampleValue_,
            afterEnd_: bn.prototype.copySampleValue_
        }), Tn.prototype = Object.assign(Object.create(bn.prototype), {
            constructor: Tn,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    o = t + 1,
                    s = n[r],
                    a = n[o];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, s = 2 * e - i;
                        break;
                    case 2402:
                        s = e + n[r = n.length - 2] - n[r + 1];
                        break;
                    default:
                        r = t, s = i
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        o = t, a = 2 * i - e;
                        break;
                    case 2402:
                        o = 1, a = i + n[1] - n[0];
                        break;
                    default:
                        o = t - 1, a = e
                }
                t = .5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - s), this._weightNext = t / (a - i), this._offsetPrev = r * n, this._offsetNext = o * n
            },
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = (t *= s) - s,
                    l = this._offsetPrev,
                    c = this._offsetNext,
                    h = this._weightPrev,
                    u = this._weightNext,
                    d = (i - e) / (n - e);
                for (e = -h * (n = (i = d * d) * d) + 2 * h * i - h * d, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== s; ++i) r[i] = e * o[l + i] + h * o[a + i] + d * o[t + i] + u * o[c + i];
                return r
            }
        }), Sn.prototype = Object.assign(Object.create(bn.prototype), {
            constructor: Sn,
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = (t *= s) - s;
                for (i = 1 - (e = (i - e) / (n - e)), n = 0; n !== s; ++n) r[n] = o[a + n] * i + o[t + n] * e;
                return r
            }
        }), Mn.prototype = Object.assign(Object.create(bn.prototype), {
            constructor: Mn,
            interpolate_: function(t) {
                return this.copySampleValue_(t - 1)
            }
        }), Object.assign(En, {
            toJSON: function(t) {
                var e = t.constructor;
                if (void 0 !== e.toJSON) e = e.toJSON(t);
                else {
                    e = {
                        name: t.name,
                        times: vl.convertArray(t.times, Array),
                        values: vl.convertArray(t.values, Array)
                    };
                    var i = t.getInterpolation();
                    i !== t.DefaultInterpolation && (e.interpolation = i)
                }
                return e.type = t.ValueTypeName, e
            }
        }), Object.assign(En.prototype, {
            constructor: En,
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new Mn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new Sn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new Tn(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                switch (t) {
                    case 2300:
                        var e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", e), this
                }
                return this.createInterpolant = e, this
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function(t, e) {
                for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
                for (; - 1 !== o && i[o] > e;) --o;
                return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), t = this.getValueSize(), this.times = vl.arraySlice(i, r, o), this.values = vl.arraySlice(this.values, r * t, o * t)), this
            },
            validate: function() {
                var t = !0,
                    e = this.getValueSize();
                0 != e - Math.floor(e) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                var i = this.times;
                e = this.values;
                var n = i.length;
                0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                for (var r = null, o = 0; o !== n; o++) {
                    var s = i[o];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1;
                        break
                    }
                    if (null !== r && r > s) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, r), t = !1;
                        break
                    }
                    r = s
                }
                if (void 0 !== e && vl.isTypedArray(e))
                    for (o = 0, i = e.length; o !== i; ++o)
                        if (n = e[o], isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), t = !1;
                            break
                        } return t
            },
            optimize: function() {
                for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, s = 1; s < o; ++s) {
                    var a = !1,
                        l = t[s];
                    if (l !== t[s + 1] && (1 !== s || l !== l[0]))
                        if (n) a = !0;
                        else {
                            var c = s * i,
                                h = c - i,
                                u = c + i;
                            for (l = 0; l !== i; ++l) {
                                var d = e[c + l];
                                if (d !== e[h + l] || d !== e[u + l]) {
                                    a = !0;
                                    break
                                }
                            }
                        } if (a) {
                        if (s !== r)
                            for (t[r] = t[s], a = s * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[a + l];
                        ++r
                    }
                }
                if (0 < o) {
                    for (t[r] = t[o], a = o * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[a + l];
                    ++r
                }
                return r !== t.length && (this.times = vl.arraySlice(t, 0, r), this.values = vl.arraySlice(e, 0, r * i)), this
            },
            clone: function() {
                var t = vl.arraySlice(this.times, 0),
                    e = vl.arraySlice(this.values, 0);
                return (t = new this.constructor(this.name, t, e)).createInterpolant = this.createInterpolant, t
            }
        }), An.prototype = Object.assign(Object.create(En.prototype), {
            constructor: An,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Pn.prototype = Object.assign(Object.create(En.prototype), {
            constructor: Pn,
            ValueTypeName: "color"
        }), Cn.prototype = Object.assign(Object.create(En.prototype), {
            constructor: Cn,
            ValueTypeName: "number"
        }), Rn.prototype = Object.assign(Object.create(bn.prototype), {
            constructor: Rn,
            interpolate_: function(t, e, i, r) {
                var o = this.resultBuffer,
                    s = this.sampleValues,
                    a = this.valueSize;
                for (e = (i - e) / (r - e), i = (t *= a) + a; t !== i; t += 4) n.slerpFlat(o, 0, s, t - a, s, t, e);
                return o
            }
        }), Ln.prototype = Object.assign(Object.create(En.prototype), {
            constructor: Ln,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function(t) {
                return new Rn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), On.prototype = Object.assign(Object.create(En.prototype), {
            constructor: On,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), kn.prototype = Object.assign(Object.create(En.prototype), {
            constructor: kn,
            ValueTypeName: "vector"
        }), Object.assign(Dn, {
            parse: function(t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(In(i[r]).scale(n));
                return new Dn(t.name, t.duration, e)
            },
            toJSON: function(t) {
                var e = [],
                    i = t.tracks;
                t = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e,
                    uuid: t.uuid
                };
                for (var n = 0, r = i.length; n !== r; ++n) e.push(En.toJSON(i[n]));
                return t
            },
            CreateFromMorphTargetSequence: function(t, e, i, n) {
                for (var r = e.length, o = [], s = 0; s < r; s++) {
                    var a = [],
                        l = [];
                    a.push((s + r - 1) % r, s, (s + 1) % r), l.push(0, 1, 0);
                    var c = vl.getKeyframeOrder(a);
                    a = vl.sortedArray(a, 1, c), l = vl.sortedArray(l, 1, c), n || 0 !== a[0] || (a.push(r), l.push(l[0])), o.push(new Cn(".morphTargetInfluences[" + e[s].name + "]", a, l).scale(1 / i))
                }
                return new Dn(t, -1, o)
            },
            findByName: function(t, e) {
                var i = t;
                for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)
                    if (i[t].name === e) return i[t];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, i) {
                for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, s = t.length; o < s; o++) {
                    var a = t[o],
                        l = a.name.match(r);
                    if (l && 1 < l.length) {
                        var c = l[1];
                        (l = n[c]) || (n[c] = l = []), l.push(a)
                    }
                }
                for (c in t = [], n) t.push(Dn.CreateFromMorphTargetSequence(c, n[c], e, i));
                return t
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                var i = function(t, e, i, n, r) {
                        if (0 !== i.length) {
                            var o = [],
                                s = [];
                            vl.flattenJSON(i, o, s, n), 0 !== o.length && r.push(new t(e, o, s))
                        }
                    },
                    n = [],
                    r = t.name || "default",
                    o = t.length || -1,
                    s = t.fps || 30;
                t = t.hierarchy || [];
                for (var a = 0; a < t.length; a++) {
                    var l = t[a].keys;
                    if (l && 0 !== l.length)
                        if (l[0].morphTargets) {
                            o = {};
                            for (var c = 0; c < l.length; c++)
                                if (l[c].morphTargets)
                                    for (var h = 0; h < l[c].morphTargets.length; h++) o[l[c].morphTargets[h]] = -1;
                            for (var u in o) {
                                var d = [],
                                    p = [];
                                for (h = 0; h !== l[c].morphTargets.length; ++h) {
                                    var f = l[c];
                                    d.push(f.time), p.push(f.morphTarget === u ? 1 : 0)
                                }
                                n.push(new Cn(".morphTargetInfluence[" + u + "]", d, p))
                            }
                            o = o.length * (s || 1)
                        } else i(kn, (c = ".bones[" + e[a].name + "]") + ".position", l, "pos", n), i(Ln, c + ".quaternion", l, "rot", n), i(kn, c + ".scale", l, "scl", n)
                }
                return 0 === n.length ? null : new Dn(r, o, n)
            }
        }), Object.assign(Dn.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                    var n = this.tracks[e];
                    t = Math.max(t, n.times[n.times.length - 1])
                }
                return this.duration = t, this
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            validate: function() {
                for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                return t
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            },
            clone: function() {
                for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                return new Dn(this.name, this.duration, t)
            }
        });
        var yl = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            },
            _l = new Nn;
        Object.assign(zn.prototype, {
            load: function() {},
            parse: function() {},
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            },
            setResourcePath: function(t) {
                return this.resourcePath = t, this
            }
        });
        var xl = {};
        Fn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Fn,
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this,
                    o = yl.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o;
                if (void 0 === xl[t]) {
                    var s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    if (s) {
                        i = s[1];
                        var a = !!s[2];
                        s = s[3], s = decodeURIComponent(s), a && (s = atob(s));
                        try {
                            var l = (this.responseType || "").toLowerCase();
                            switch (l) {
                                case "arraybuffer":
                                case "blob":
                                    var c = new Uint8Array(s.length);
                                    for (a = 0; a < s.length; a++) c[a] = s.charCodeAt(a);
                                    var h = "blob" === l ? new Blob([c.buffer], {
                                        type: i
                                    }) : c.buffer;
                                    break;
                                case "document":
                                    h = (new DOMParser).parseFromString(s, i);
                                    break;
                                case "json":
                                    h = JSON.parse(s);
                                    break;
                                default:
                                    h = s
                            }
                            setTimeout(function() {
                                e && e(h), r.manager.itemEnd(t)
                            }, 0)
                        } catch (e) {
                            setTimeout(function() {
                                n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                            }, 0)
                        }
                    } else {
                        xl[t] = [], xl[t].push({
                            onLoad: e,
                            onProgress: i,
                            onError: n
                        });
                        var u = new XMLHttpRequest;
                        for (a in u.open("GET", t, !0), u.addEventListener("load", function(e) {
                                var i = this.response;
                                yl.add(t, i);
                                var n = xl[t];
                                if (delete xl[t], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                    for (var o = 0, s = n.length; o < s; o++) {
                                        var a = n[o];
                                        a.onLoad && a.onLoad(i)
                                    }
                                } else {
                                    for (o = 0, s = n.length; o < s; o++)(a = n[o]).onError && a.onError(e);
                                    r.manager.itemError(t)
                                }
                                r.manager.itemEnd(t)
                            }, !1), u.addEventListener("progress", function(e) {
                                for (var i = xl[t], n = 0, r = i.length; n < r; n++) {
                                    var o = i[n];
                                    o.onProgress && o.onProgress(e)
                                }
                            }, !1), u.addEventListener("error", function(e) {
                                var i = xl[t];
                                delete xl[t];
                                for (var n = 0, o = i.length; n < o; n++) {
                                    var s = i[n];
                                    s.onError && s.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }, !1), u.addEventListener("abort", function(e) {
                                var i = xl[t];
                                delete xl[t];
                                for (var n = 0, o = i.length; n < o; n++) {
                                    var s = i[n];
                                    s.onError && s.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }, !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(a, this.requestHeader[a]);
                        u.send(null)
                    }
                    return r.manager.itemStart(t), u
                }
                xl[t].push({
                    onLoad: e,
                    onProgress: i,
                    onError: n
                })
            },
            setResponseType: function(t) {
                return this.responseType = t, this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t, this
            },
            setMimeType: function(t) {
                return this.mimeType = t, this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t, this
            }
        }), Bn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Bn,
            load: function(t, e, i, n) {
                var r = this,
                    o = new Fn(r.manager);
                o.setPath(r.path), o.load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            parse: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = Dn.parse(t[i]);
                    e.push(n)
                }
                return e
            }
        }), Hn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Hn,
            load: function(t, e, i, n) {
                function r(r) {
                    l.load(t[r], function(t) {
                        t = o.parse(t, !0), s[r] = {
                            width: t.width,
                            height: t.height,
                            format: t.format,
                            mipmaps: t.mipmaps
                        }, 6 === (c += 1) && (1 === t.mipmapCount && (a.minFilter = 1006), a.format = t.format, a.needsUpdate = !0, e && e(a))
                    }, i, n)
                }
                var o = this,
                    s = [],
                    a = new ri;
                a.image = s;
                var l = new Fn(this.manager);
                if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(t))
                    for (var c = 0, h = 0, u = t.length; h < u; ++h) r(h);
                else l.load(t, function(t) {
                    if ((t = o.parse(t, !0)).isCubemap)
                        for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) {
                            s[n] = {
                                mipmaps: []
                            };
                            for (var r = 0; r < t.mipmapCount; r++) s[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), s[n].format = t.format, s[n].width = t.width, s[n].height = t.height
                        } else a.image.width = t.width, a.image.height = t.height, a.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (a.minFilter = 1006), a.format = t.format, a.needsUpdate = !0, e && e(a)
                }, i, n);
                return a
            }
        }), Un.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Un,
            load: function(t, e, i, n) {
                var r = this,
                    o = new J,
                    s = new Fn(this.manager);
                return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(t, function(t) {
                    (t = r.parse(t)) && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, o.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, o.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, o.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps), 1 === t.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, t))
                }, i, n), o
            }
        }), Gn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Gn,
            load: function(t, e, i, n) {
                function r() {
                    l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), yl.add(t, this), e && e(this), s.manager.itemEnd(t)
                }

                function o(e) {
                    l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), n && n(e), s.manager.itemError(t), s.manager.itemEnd(t)
                }
                void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var s = this,
                    a = yl.get(t);
                if (void 0 !== a) return s.manager.itemStart(t), setTimeout(function() {
                    e && e(a), s.manager.itemEnd(t)
                }, 0), a;
                var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                return l.addEventListener("load", r, !1), l.addEventListener("error", o, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), s.manager.itemStart(t), l.src = t, l
            }
        }), jn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: jn,
            load: function(t, e, i, n) {
                function r(i) {
                    s.load(t[i], function(t) {
                        o.images[i] = t, 6 === ++a && (o.needsUpdate = !0, e && e(o))
                    }, void 0, n)
                }
                var o = new mt,
                    s = new Gn(this.manager);
                s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                var a = 0;
                for (i = 0; i < t.length; ++i) r(i);
                return o
            }
        }), Vn.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Vn,
            load: function(t, e, i, n) {
                var r = new s,
                    o = new Gn(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(i) {
                    r.image = i, i = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r)
                }, i, n), r
            }
        }), Object.assign(Wn.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function(t, e) {
                return t = this.getUtoTmapping(t), this.getPoint(t, e)
            },
            getPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i = [],
                    n = this.getPoint(0),
                    r = 0;
                for (i.push(0), e = 1; e <= t; e++) {
                    var o = this.getPoint(e / t);
                    r += o.distanceTo(n), i.push(r), n = o
                }
                return this.cacheArcLengths = i
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var i = this.getLengths(),
                    n = i.length;
                e = e || t * i[n - 1];
                for (var r, o = 0, s = n - 1; o <= s;)
                    if (0 > (r = i[t = Math.floor(o + (s - o) / 2)] - e)) o = t + 1;
                    else {
                        if (!(0 < r)) {
                            s = t;
                            break
                        }
                        s = t - 1
                    } return i[t = s] === e ? t / (n - 1) : (t + (e - (o = i[t])) / (i[t + 1] - o)) / (n - 1)
            },
            getTangent: function(t) {
                var e = t - 1e-4;
                return 0 > e && (e = 0), 1 < (t += 1e-4) && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize()
            },
            getTangentAt: function(t) {
                return t = this.getUtoTmapping(t), this.getTangent(t)
            },
            computeFrenetFrames: function(t, e) {
                var i, n = new r,
                    o = [],
                    s = [],
                    a = [],
                    l = new r,
                    c = new h;
                for (i = 0; i <= t; i++) {
                    var u = i / t;
                    o[i] = this.getTangentAt(u), o[i].normalize()
                }
                s[0] = new r, a[0] = new r, i = Number.MAX_VALUE, u = Math.abs(o[0].x);
                var d = Math.abs(o[0].y),
                    p = Math.abs(o[0].z);
                for (u <= i && (i = u, n.set(1, 0, 0)), d <= i && (i = d, n.set(0, 1, 0)), p <= i && n.set(0, 0, 1), l.crossVectors(o[0], n).normalize(), s[0].crossVectors(o[0], l), a[0].crossVectors(o[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1].clone(), a[i] = a[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(Po.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(l, n))), a[i].crossVectors(o[i], s[i]);
                if (!0 === e)
                    for (n = Math.acos(Po.clamp(s[0].dot(s[t]), -1, 1)), n /= t, 0 < o[0].dot(l.crossVectors(s[0], s[t])) && (n = -n), i = 1; i <= t; i++) s[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), a[i].crossVectors(o[i], s[i]);
                return {
                    tangents: o,
                    normals: s,
                    binormals: a
                }
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
            },
            fromJSON: function(t) {
                return this.arcLengthDivisions = t.arcLengthDivisions, this
            }
        }), qn.prototype = Object.create(Wn.prototype), qn.prototype.constructor = qn, qn.prototype.isEllipseCurve = !0, qn.prototype.getPoint = function(t, e) {
            e = e || new i;
            for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
            for (; r > n;) r -= n;
            r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + t * r, t = this.aX + this.xRadius * Math.cos(n);
            var s = this.aY + this.yRadius * Math.sin(n);
            return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), t = (o = t - this.aX) * n - (s -= this.aY) * r + this.aX, s = o * r + s * n + this.aY), e.set(t, s)
        }, qn.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, qn.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }, qn.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }, Xn.prototype = Object.create(qn.prototype), Xn.prototype.constructor = Xn, Xn.prototype.isArcCurve = !0;
        var wl = new r,
            bl = new $n,
            Tl = new $n,
            Sl = new $n;
        Yn.prototype = Object.create(Wn.prototype), Yn.prototype.constructor = Yn, Yn.prototype.isCatmullRomCurve3 = !0, Yn.prototype.getPoint = function(t, e) {
            e = e || new r;
            var i = this.points,
                n = i.length;
            t *= n - (this.closed ? 0 : 1);
            var o = Math.floor(t);
            if (t -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === t && o === n - 1 && (o = n - 2, t = 1), this.closed || 0 < o) var s = i[(o - 1) % n];
            else wl.subVectors(i[0], i[1]).add(i[0]), s = wl;
            var a = i[o % n],
                l = i[(o + 1) % n];
            if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (wl.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = wl), "centripetal" === this.curveType || "chordal" === this.curveType) {
                var c = "chordal" === this.curveType ? .5 : .25;
                n = Math.pow(s.distanceToSquared(a), c), 1e-4 > (o = Math.pow(a.distanceToSquared(l), c)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (c = Math.pow(l.distanceToSquared(i), c)) && (c = o), bl.initNonuniformCatmullRom(s.x, a.x, l.x, i.x, n, o, c), Tl.initNonuniformCatmullRom(s.y, a.y, l.y, i.y, n, o, c), Sl.initNonuniformCatmullRom(s.z, a.z, l.z, i.z, n, o, c)
            } else "catmullrom" === this.curveType && (bl.initCatmullRom(s.x, a.x, l.x, i.x, this.tension), Tl.initCatmullRom(s.y, a.y, l.y, i.y, this.tension), Sl.initCatmullRom(s.z, a.z, l.z, i.z, this.tension));
            return e.set(bl.calc(t), Tl.calc(t), Sl.calc(t)), e
        }, Yn.prototype.copy = function(t) {
            Wn.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Yn.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }, Yn.prototype.fromJSON = function(t) {
            Wn.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) {
                var n = t.points[e];
                this.points.push((new r).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }, Kn.prototype = Object.create(Wn.prototype), Kn.prototype.constructor = Kn, Kn.prototype.isCubicBezierCurve = !0, Kn.prototype.getPoint = function(t, e) {
            e = e || new i;
            var n = this.v0,
                r = this.v1,
                o = this.v2,
                s = this.v3;
            return e.set(Qn(t, n.x, r.x, o.x, s.x), Qn(t, n.y, r.y, o.y, s.y)), e
        }, Kn.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, Kn.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, Kn.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, tr.prototype = Object.create(Wn.prototype), tr.prototype.constructor = tr, tr.prototype.isCubicBezierCurve3 = !0, tr.prototype.getPoint = function(t, e) {
            e = e || new r;
            var i = this.v0,
                n = this.v1,
                o = this.v2,
                s = this.v3;
            return e.set(Qn(t, i.x, n.x, o.x, s.x), Qn(t, i.y, n.y, o.y, s.y), Qn(t, i.z, n.z, o.z, s.z)), e
        }, tr.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }, tr.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }, tr.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }, er.prototype = Object.create(Wn.prototype), er.prototype.constructor = er, er.prototype.isLineCurve = !0, er.prototype.getPoint = function(t, e) {
            return e = e || new i, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
        }, er.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, er.prototype.getTangent = function() {
            return this.v2.clone().sub(this.v1).normalize()
        }, er.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, er.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, er.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, ir.prototype = Object.create(Wn.prototype), ir.prototype.constructor = ir, ir.prototype.isLineCurve3 = !0, ir.prototype.getPoint = function(t, e) {
            return e = e || new r, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
        }, ir.prototype.getPointAt = function(t, e) {
            return this.getPoint(t, e)
        }, ir.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, ir.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, ir.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, nr.prototype = Object.create(Wn.prototype), nr.prototype.constructor = nr, nr.prototype.isQuadraticBezierCurve = !0, nr.prototype.getPoint = function(t, e) {
            e = e || new i;
            var n = this.v0,
                r = this.v1,
                o = this.v2;
            return e.set(Jn(t, n.x, r.x, o.x), Jn(t, n.y, r.y, o.y)), e
        }, nr.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, nr.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, nr.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, rr.prototype = Object.create(Wn.prototype), rr.prototype.constructor = rr, rr.prototype.isQuadraticBezierCurve3 = !0, rr.prototype.getPoint = function(t, e) {
            e = e || new r;
            var i = this.v0,
                n = this.v1,
                o = this.v2;
            return e.set(Jn(t, i.x, n.x, o.x), Jn(t, i.y, n.y, o.y), Jn(t, i.z, n.z, o.z)), e
        }, rr.prototype.copy = function(t) {
            return Wn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }, rr.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }, rr.prototype.fromJSON = function(t) {
            return Wn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }, or.prototype = Object.create(Wn.prototype), or.prototype.constructor = or, or.prototype.isSplineCurve = !0, or.prototype.getPoint = function(t, e) {
            e = e || new i;
            var n = this.points,
                r = (n.length - 1) * t;
            r -= t = Math.floor(r);
            var o = n[0 === t ? t : t - 1],
                s = n[t],
                a = n[t > n.length - 2 ? n.length - 1 : t + 1];
            return n = n[t > n.length - 3 ? n.length - 1 : t + 2], e.set(Zn(r, o.x, s.x, a.x, n.x), Zn(r, o.y, s.y, a.y, n.y)), e
        }, or.prototype.copy = function(t) {
            Wn.prototype.copy.call(this, t), this.points = [];
            for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
            return this
        }, or.prototype.toJSON = function() {
            var t = Wn.prototype.toJSON.call(this);
            t.points = [];
            for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
            return t
        }, or.prototype.fromJSON = function(t) {
            Wn.prototype.fromJSON.call(this, t), this.points = [];
            for (var e = 0, n = t.points.length; e < n; e++) {
                var r = t.points[e];
                this.points.push((new i).fromArray(r))
            }
            return this
        };
        var Ml = Object.freeze({
            ArcCurve: Xn,
            CatmullRomCurve3: Yn,
            CubicBezierCurve: Kn,
            CubicBezierCurve3: tr,
            EllipseCurve: qn,
            LineCurve: er,
            LineCurve3: ir,
            QuadraticBezierCurve: nr,
            QuadraticBezierCurve3: rr,
            SplineCurve: or
        });
        sr.prototype = Object.assign(Object.create(Wn.prototype), {
            constructor: sr,
            add: function(t) {
                this.curves.push(t)
            },
            closePath: function() {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new er(e, t))
            },
            getPoint: function(t) {
                var e = t * this.getLength(),
                    i = this.getCurveLengths();
                for (t = 0; t < i.length;) {
                    if (i[t] >= e) return e = i[t] - e, i = (t = this.curves[t]).getLength(), t.getPointAt(0 === i ? 0 : 1 - e / i);
                    t++
                }
                return null
            },
            getLength: function() {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function(t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++) {
                    var o = r[n];
                    o = o.getPoints(o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t);
                    for (var s = 0; s < o.length; s++) {
                        var a = o[s];
                        e && e.equals(a) || (i.push(a), e = a)
                    }
                }
                return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            copy: function(t) {
                Wn.prototype.copy.call(this, t), this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) this.curves.push(t.curves[e].clone());
                return this.autoClose = t.autoClose, this
            },
            toJSON: function() {
                var t = Wn.prototype.toJSON.call(this);
                t.autoClose = this.autoClose, t.curves = [];
                for (var e = 0, i = this.curves.length; e < i; e++) t.curves.push(this.curves[e].toJSON());
                return t
            },
            fromJSON: function(t) {
                Wn.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                for (var e = 0, i = t.curves.length; e < i; e++) {
                    var n = t.curves[e];
                    this.curves.push((new Ml[n.type]).fromJSON(n))
                }
                return this
            }
        }), ar.prototype = Object.assign(Object.create(sr.prototype), {
            constructor: ar,
            setFromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function(t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function(t, e) {
                var n = new er(this.currentPoint.clone(), new i(t, e));
                this.curves.push(n), this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function(t, e, n, r) {
                t = new nr(this.currentPoint.clone(), new i(t, e), new i(n, r)), this.curves.push(t), this.currentPoint.set(n, r)
            },
            bezierCurveTo: function(t, e, n, r, o, s) {
                t = new Kn(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(o, s)), this.curves.push(t), this.currentPoint.set(o, s)
            },
            splineThru: function(t) {
                var e = [this.currentPoint.clone()].concat(t);
                e = new or(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
            },
            arc: function(t, e, i, n, r, o) {
                this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o)
            },
            absarc: function(t, e, i, n, r, o) {
                this.absellipse(t, e, i, i, n, r, o)
            },
            ellipse: function(t, e, i, n, r, o, s, a) {
                this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o, s, a)
            },
            absellipse: function(t, e, i, n, r, o, s, a) {
                t = new qn(t, e, i, n, r, o, s, a), 0 < this.curves.length && ((e = t.getPoint(0)).equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t)
            },
            copy: function(t) {
                return sr.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
            },
            toJSON: function() {
                var t = sr.prototype.toJSON.call(this);
                return t.currentPoint = this.currentPoint.toArray(), t
            },
            fromJSON: function(t) {
                return sr.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
            }
        }), lr.prototype = Object.assign(Object.create(ar.prototype), {
            constructor: lr,
            getPointsHoles: function(t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            copy: function(t) {
                ar.prototype.copy.call(this, t), this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) this.holes.push(t.holes[e].clone());
                return this
            },
            toJSON: function() {
                var t = ar.prototype.toJSON.call(this);
                t.uuid = this.uuid, t.holes = [];
                for (var e = 0, i = this.holes.length; e < i; e++) t.holes.push(this.holes[e].toJSON());
                return t
            },
            fromJSON: function(t) {
                ar.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                for (var e = 0, i = t.holes.length; e < i; e++) {
                    var n = t.holes[e];
                    this.holes.push((new ar).fromJSON(n))
                }
                return this
            }
        }), cr.prototype = Object.assign(Object.create(p.prototype), {
            constructor: cr,
            isLight: !0,
            copy: function(t) {
                return p.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                return (t = p.prototype.toJSON.call(this, t)).object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }), hr.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: hr,
            isHemisphereLight: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(ur.prototype, {
            _projScreenMatrix: new h,
            _lightPositionWorld: new r,
            _lookTarget: new r,
            getViewportCount: function() {
                return this._viewportCount
            },
            getFrustum: function() {
                return this._frustum
            },
            updateMatrices: function(t) {
                var e = this.camera,
                    i = this.matrix,
                    n = this._projScreenMatrix,
                    r = this._lookTarget,
                    o = this._lightPositionWorld;
                o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), n.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromMatrix(n), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse)
            },
            getViewport: function(t) {
                return this._viewports[t]
            },
            getFrameExtents: function() {
                return this._frameExtents
            },
            copy: function(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), dr.prototype = Object.assign(Object.create(ur.prototype), {
            constructor: dr,
            isSpotLightShadow: !0,
            updateMatrices: function(t, e, i) {
                var n = this.camera,
                    r = 2 * Po.RAD2DEG * t.angle,
                    o = this.mapSize.width / this.mapSize.height,
                    s = t.distance || n.far;
                r === n.fov && o === n.aspect && s === n.far || (n.fov = r, n.aspect = o, n.far = s, n.updateProjectionMatrix()), ur.prototype.updateMatrices.call(this, t, e, i)
            }
        }), pr.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: pr,
            isSpotLight: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), fr.prototype = Object.assign(Object.create(ur.prototype), {
            constructor: fr,
            isPointLightShadow: !0,
            updateMatrices: function(t, e, i) {
                e = this.camera;
                var n = this.matrix,
                    r = this._lightPositionWorld,
                    o = this._lookTarget,
                    s = this._projScreenMatrix;
                r.setFromMatrixPosition(t.matrixWorld), e.position.copy(r), o.copy(e.position), o.add(this._cubeDirections[i]), e.up.copy(this._cubeUps[i]), e.lookAt(o), e.updateMatrixWorld(), n.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromMatrix(s)
            }
        }), mr.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: mr,
            isPointLight: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), gr.prototype = Object.assign(Object.create(X.prototype), {
            constructor: gr,
            isOrthographicCamera: !0,
            copy: function(t, e) {
                return X.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, i, n, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2,
                    n = (this.top + this.bottom) / 2,
                    r = i - t;
                if (i += t, t = n + e, e = n - e, null !== this.view && this.view.enabled) {
                    i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
                    var o = (this.right - this.left) / this.view.width;
                    n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, e = (t -= this.view.offsetY / e * n) - this.view.height / e * n
                }
                this.projectionMatrix.makeOrthographic(r, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
            },
            toJSON: function(t) {
                return (t = p.prototype.toJSON.call(this, t)).object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }), vr.prototype = Object.assign(Object.create(ur.prototype), {
            constructor: vr,
            isDirectionalLightShadow: !0,
            updateMatrices: function(t, e, i) {
                ur.prototype.updateMatrices.call(this, t, e, i)
            }
        }), yr.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: yr,
            isDirectionalLight: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), _r.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: _r,
            isAmbientLight: !0
        }), xr.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: xr,
            isRectAreaLight: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function(t) {
                return (t = cr.prototype.toJSON.call(this, t)).object.width = this.width, t.object.height = this.height, t
            }
        }), wr.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: wr,
            load: function(t, e, i, n) {
                var r = this,
                    o = new Fn(r.manager);
                o.setPath(r.path), o.load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            parse: function(t) {
                function e(t) {
                    return void 0 === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), n[t]
                }
                var n = this.textures,
                    s = new gl[t.type];
                if (void 0 !== t.uuid && (s.uuid = t.uuid), void 0 !== t.name && (s.name = t.name), void 0 !== t.color && s.color.setHex(t.color), void 0 !== t.roughness && (s.roughness = t.roughness), void 0 !== t.metalness && (s.metalness = t.metalness), void 0 !== t.sheen && (s.sheen = (new x).setHex(t.sheen)), void 0 !== t.emissive && s.emissive.setHex(t.emissive), void 0 !== t.specular && s.specular.setHex(t.specular), void 0 !== t.shininess && (s.shininess = t.shininess), void 0 !== t.clearcoat && (s.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (s.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.vertexColors && (s.vertexColors = t.vertexColors), void 0 !== t.fog && (s.fog = t.fog), void 0 !== t.flatShading && (s.flatShading = t.flatShading), void 0 !== t.blending && (s.blending = t.blending), void 0 !== t.combine && (s.combine = t.combine), void 0 !== t.side && (s.side = t.side), void 0 !== t.opacity && (s.opacity = t.opacity), void 0 !== t.transparent && (s.transparent = t.transparent), void 0 !== t.alphaTest && (s.alphaTest = t.alphaTest), void 0 !== t.depthTest && (s.depthTest = t.depthTest), void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (s.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (s.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (s.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (s.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (s.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (s.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (s.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (s.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (s.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (s.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (s.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (s.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (s.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (s.rotation = t.rotation), 1 !== t.linewidth && (s.linewidth = t.linewidth), void 0 !== t.dashSize && (s.dashSize = t.dashSize), void 0 !== t.gapSize && (s.gapSize = t.gapSize), void 0 !== t.scale && (s.scale = t.scale), void 0 !== t.polygonOffset && (s.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (s.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (s.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (s.skinning = t.skinning), void 0 !== t.morphTargets && (s.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (s.morphNormals = t.morphNormals), void 0 !== t.dithering && (s.dithering = t.dithering), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.toneMapped && (s.toneMapped = t.toneMapped), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.uniforms)
                    for (var l in t.uniforms) {
                        var c = t.uniforms[l];
                        switch (s.uniforms[l] = {}, c.type) {
                            case "t":
                                s.uniforms[l].value = e(c.value);
                                break;
                            case "c":
                                s.uniforms[l].value = (new x).setHex(c.value);
                                break;
                            case "v2":
                                s.uniforms[l].value = (new i).fromArray(c.value);
                                break;
                            case "v3":
                                s.uniforms[l].value = (new r).fromArray(c.value);
                                break;
                            case "v4":
                                s.uniforms[l].value = (new a).fromArray(c.value);
                                break;
                            case "m3":
                                s.uniforms[l].value = (new o).fromArray(c.value);
                            case "m4":
                                s.uniforms[l].value = (new h).fromArray(c.value);
                                break;
                            default:
                                s.uniforms[l].value = c.value
                        }
                    }
                if (void 0 !== t.defines && (s.defines = t.defines), void 0 !== t.vertexShader && (s.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (s.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                    for (var u in t.extensions) s.extensions[u] = t.extensions[u];
                return void 0 !== t.shading && (s.flatShading = 1 === t.shading), void 0 !== t.size && (s.size = t.size), void 0 !== t.sizeAttenuation && (s.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (s.map = e(t.map)), void 0 !== t.matcap && (s.matcap = e(t.matcap)), void 0 !== t.alphaMap && (s.alphaMap = e(t.alphaMap), s.transparent = !0), void 0 !== t.bumpMap && (s.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (s.bumpScale = t.bumpScale), void 0 !== t.normalMap && (s.normalMap = e(t.normalMap)), void 0 !== t.normalMapType && (s.normalMapType = t.normalMapType), void 0 !== t.normalScale && (l = t.normalScale, !1 === Array.isArray(l) && (l = [l, l]), s.normalScale = (new i).fromArray(l)), void 0 !== t.displacementMap && (s.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (s.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (s.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (s.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (s.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (s.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (s.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (s.specularMap = e(t.specularMap)), void 0 !== t.envMap && (s.envMap = e(t.envMap)), void 0 !== t.envMapIntensity && (s.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (s.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (s.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (s.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (s.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (s.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (s.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (s.gradientMap = e(t.gradientMap)), void 0 !== t.clearcoatNormalMap && (s.clearcoatNormalMap = e(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (s.clearcoatNormalScale = (new i).fromArray(t.clearcoatNormalScale)), s
            },
            setTextures: function(t) {
                return this.textures = t, this
            }
        });
        var El = {
            decodeText: function(t) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                try {
                    return decodeURIComponent(escape(e))
                } catch (t) {
                    return e
                }
            },
            extractUrlBase: function(t) {
                var e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            }
        };
        br.prototype = Object.assign(Object.create(B.prototype), {
            constructor: br,
            isInstancedBufferGeometry: !0,
            copy: function(t) {
                return B.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = B.prototype.toJSON.call(this);
                return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t
            }
        }), Tr.prototype = Object.assign(Object.create(A.prototype), {
            constructor: Tr,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return A.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            },
            toJSON: function() {
                var t = A.prototype.toJSON.call(this);
                return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
            }
        }), Sr.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Sr,
            load: function(t, e, i, n) {
                var r = this,
                    o = new Fn(r.manager);
                o.setPath(r.path), o.load(t, function(t) {
                    e(r.parse(JSON.parse(t)))
                }, i, n)
            },
            parse: function(t) {
                var e = t.isInstancedBufferGeometry ? new br : new B,
                    i = t.data.index;
                if (void 0 !== i) {
                    var n = new Al[i.type](i.array);
                    e.setIndex(new A(n, 1))
                }
                for (var o in i = t.data.attributes) {
                    var s = i[o];
                    n = new Al[s.type](s.array), n = new(s.isInstancedBufferAttribute ? Tr : A)(n, s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), e.addAttribute(o, n)
                }
                var a = t.data.morphAttributes;
                if (a)
                    for (o in a) {
                        var l = a[o],
                            c = [];
                        i = 0;
                        for (var h = l.length; i < h; i++) s = l[i], n = new A(n = new Al[s.type](s.array), s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), c.push(n);
                        e.morphAttributes[o] = c
                    }
                if (void 0 !== (o = t.data.groups || t.data.drawcalls || t.data.offsets))
                    for (i = 0, s = o.length; i !== s; ++i) n = o[i], e.addGroup(n.start, n.count, n.materialIndex);
                return void 0 !== (i = t.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), e.boundingSphere = new v(o, i.radius)), t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
            }
        });
        var Al = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        Mr.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Mr,
            load: function(t, e, i, n) {
                var r = this,
                    o = "" === this.path ? El.extractUrlBase(t) : this.path;
                this.resourcePath = this.resourcePath || o, (o = new Fn(r.manager)).setPath(this.path), o.load(t, function(i) {
                    var o = null;
                    try {
                        o = JSON.parse(i)
                    } catch (e) {
                        return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + t) : r.parse(o, e)
                }, i, n)
            },
            parse: function(t, e) {
                var i = this.parseShape(t.shapes);
                i = this.parseGeometries(t.geometries, i);
                var n = this.parseImages(t.images, function() {
                    void 0 !== e && e(r)
                });
                n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
                var r = this.parseObject(t.object, i, n);
                return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r), r
            },
            parseShape: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = (new lr).fromJSON(t[i]);
                        e[r.uuid] = r
                    }
                return e
            },
            parseGeometries: function(t, e) {
                var i = {};
                if (void 0 !== t)
                    for (var n = new Sr, r = 0, o = t.length; r < o; r++) {
                        var s = t[r];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                var a = new ml[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new ml[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new ml[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new ml[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new ml[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new ml[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "DodecahedronBufferGeometry":
                            case "IcosahedronGeometry":
                            case "IcosahedronBufferGeometry":
                            case "OctahedronGeometry":
                            case "OctahedronBufferGeometry":
                            case "TetrahedronGeometry":
                            case "TetrahedronBufferGeometry":
                                a = new ml[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new ml[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new ml[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new ml[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "TubeGeometry":
                            case "TubeBufferGeometry":
                                a = new ml[s.type]((new Ml[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new ml[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "PolyhedronGeometry":
                            case "PolyhedronBufferGeometry":
                                a = new ml[s.type](s.vertices, s.indices, s.radius, s.details);
                                break;
                            case "ShapeGeometry":
                            case "ShapeBufferGeometry":
                                a = [];
                                for (var l = 0, c = s.shapes.length; l < c; l++) {
                                    var h = e[s.shapes[l]];
                                    a.push(h)
                                }
                                a = new ml[s.type](a, s.curveSegments);
                                break;
                            case "ExtrudeGeometry":
                            case "ExtrudeBufferGeometry":
                                for (a = [], l = 0, c = s.shapes.length; l < c; l++) h = e[s.shapes[l]], a.push(h);
                                void 0 !== (l = s.options.extrudePath) && (s.options.extrudePath = (new Ml[l.type]).fromJSON(l)), a = new ml[s.type](a, s.options);
                                break;
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                a = n.parse(s);
                                break;
                            case "Geometry":
                                "THREE" in window && "LegacyJSONLoader" in THREE ? a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                        }
                        a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
                    }
                return i
            },
            parseMaterials: function(t, e) {
                var i = {},
                    n = {};
                if (void 0 !== t) {
                    var r = new wr;
                    r.setTextures(e), e = 0;
                    for (var o = t.length; e < o; e++) {
                        var s = t[e];
                        if ("MultiMaterial" === s.type) {
                            for (var a = [], l = 0; l < s.materials.length; l++) {
                                var c = s.materials[l];
                                void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), a.push(i[c.uuid])
                            }
                            n[s.uuid] = a
                        } else void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] = i[s.uuid]
                    }
                }
                return n
            },
            parseAnimations: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = t[i],
                        r = Dn.parse(n);
                    void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                }
                return e
            },
            parseImages: function(t, e) {
                function i(t) {
                    return n.manager.itemStart(t), o.load(t, function() {
                        n.manager.itemEnd(t)
                    }, void 0, function() {
                        n.manager.itemError(t), n.manager.itemEnd(t)
                    })
                }
                var n = this,
                    r = {};
                if (void 0 !== t && 0 < t.length) {
                    var o = new Gn(e = new Nn(e));
                    o.setCrossOrigin(this.crossOrigin), e = 0;
                    for (var s = t.length; e < s; e++) {
                        var a = t[e],
                            l = a.url;
                        if (Array.isArray(l)) {
                            r[a.uuid] = [];
                            for (var c = 0, h = l.length; c < h; c++) {
                                var u = l[c];
                                u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[a.uuid].push(i(u))
                            }
                        } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url : n.resourcePath + a.url, r[a.uuid] = i(u)
                    }
                }
                return r
            },
            parseTextures: function(t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }
                var n = {};
                if (void 0 !== t)
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r];
                        void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                        var l = Array.isArray(e[a.image]) ? new mt(e[a.image]) : new s(e[a.image]);
                        l.needsUpdate = !0, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = i(a.mapping, Pl)), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = i(a.wrap[0], Cl), l.wrapT = i(a.wrap[1], Cl)), void 0 !== a.format && (l.format = a.format), void 0 !== a.type && (l.type = a.type), void 0 !== a.encoding && (l.encoding = a.encoding), void 0 !== a.minFilter && (l.minFilter = i(a.minFilter, Rl)), void 0 !== a.magFilter && (l.magFilter = i(a.magFilter, Rl)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (l.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (l.unpackAlignment = a.unpackAlignment), n[a.uuid] = l
                    }
                return n
            },
            parseObject: function(t, e, i) {
                function n(t) {
                    return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                }

                function r(t) {
                    if (void 0 !== t) {
                        if (Array.isArray(t)) {
                            for (var e = [], n = 0, r = t.length; n < r; n++) {
                                var o = t[n];
                                void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(i[o])
                            }
                            return e
                        }
                        return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                    }
                }
                switch (t.type) {
                    case "Scene":
                        var o = new f;
                        void 0 !== t.background && Number.isInteger(t.background) && (o.background = new x(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new Be(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new Fe(t.fog.color, t.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        o = new $(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                        break;
                    case "OrthographicCamera":
                        o = new gr(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.view && (o.view = Object.assign({}, t.view));
                        break;
                    case "AmbientLight":
                        o = new _r(t.color, t.intensity);
                        break;
                    case "DirectionalLight":
                        o = new yr(t.color, t.intensity);
                        break;
                    case "PointLight":
                        o = new mr(t.color, t.intensity, t.distance, t.decay);
                        break;
                    case "RectAreaLight":
                        o = new xr(t.color, t.intensity, t.width, t.height);
                        break;
                    case "SpotLight":
                        o = new pr(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                        break;
                    case "HemisphereLight":
                        o = new hr(t.color, t.groundColor, t.intensity);
                        break;
                    case "SkinnedMesh":
                        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                    case "Mesh":
                        o = n(t.geometry);
                        var s = r(t.material);
                        o = o.bones && 0 < o.bones.length ? new qe(o, s) : new H(o, s), void 0 !== t.drawMode && o.setDrawMode(t.drawMode);
                        break;
                    case "LOD":
                        o = new We;
                        break;
                    case "Line":
                        o = new Je(n(t.geometry), r(t.material), t.mode);
                        break;
                    case "LineLoop":
                        o = new Ke(n(t.geometry), r(t.material));
                        break;
                    case "LineSegments":
                        o = new Qe(n(t.geometry), r(t.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        o = new ei(n(t.geometry), r(t.material));
                        break;
                    case "Sprite":
                        o = new je(r(t.material));
                        break;
                    case "Group":
                        o = new Oe;
                        break;
                    default:
                        o = new p
                }
                if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (o.matrixAutoUpdate = t.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.layers && (o.layers.mask = t.layers), void 0 !== t.children) {
                    s = t.children;
                    for (var a = 0; a < s.length; a++) o.add(this.parseObject(s[a], e, i))
                }
                if ("LOD" === t.type)
                    for (t = t.levels, s = 0; s < t.length; s++) {
                        a = t[s];
                        var l = o.getObjectByProperty("uuid", a.object);
                        void 0 !== l && o.addLevel(l, a.distance)
                    }
                return o
            }
        });
        var Pl = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            },
            Cl = {
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002
            },
            Rl = {
                NearestFilter: 1003,
                NearestMipmapNearestFilter: 1004,
                NearestMipmapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipmapNearestFilter: 1007,
                LinearMipmapLinearFilter: 1008
            };
        Er.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Er,
            setOptions: function(t) {
                return this.options = t, this
            },
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                var r = this,
                    o = yl.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o;
                fetch(t).then(function(t) {
                    return t.blob()
                }).then(function(t) {
                    return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options)
                }).then(function(i) {
                    yl.add(t, i), e && e(i), r.manager.itemEnd(t)
                }).catch(function(e) {
                    n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                }), r.manager.itemStart(t)
            }
        }), Object.assign(Ar.prototype, {
            moveTo: function(t, e) {
                this.currentPath = new ar, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            },
            lineTo: function(t, e) {
                this.currentPath.lineTo(t, e)
            },
            quadraticCurveTo: function(t, e, i, n) {
                this.currentPath.quadraticCurveTo(t, e, i, n)
            },
            bezierCurveTo: function(t, e, i, n, r, o) {
                this.currentPath.bezierCurveTo(t, e, i, n, r, o)
            },
            splineThru: function(t) {
                this.currentPath.splineThru(t)
            },
            toShapes: function(t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i],
                            o = new lr;
                        o.curves = r.curves, e.push(o)
                    }
                    return e
                }

                function n(t, e) {
                    for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                        var s = e[r],
                            a = e[o],
                            l = a.x - s.x,
                            c = a.y - s.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (0 > c && (s = e[o], l = -l, a = e[r], c = -c), !(t.y < s.y || t.y > a.y))
                                if (t.y === s.y) {
                                    if (t.x === s.x) return !0
                                } else {
                                    if (0 === (r = c * (t.x - s.x) - l * (t.y - s.y))) return !0;
                                    0 > r || (n = !n)
                                }
                        } else if (t.y === s.y && (a.x <= t.x && t.x <= s.x || s.x <= t.x && t.x <= a.x)) return !0
                    }
                    return n
                }
                var r = pl.isClockWise,
                    o = this.subPaths;
                if (0 === o.length) return [];
                if (!0 === e) return i(o);
                if (e = [], 1 === o.length) {
                    var s = o[0],
                        a = new lr;
                    return a.curves = s.curves, e.push(a), e
                }
                var l = !r(o[0].getPoints());
                l = t ? !l : l, a = [];
                var c = [],
                    h = [],
                    u = 0;
                c[u] = void 0, h[u] = [];
                for (var d = 0, p = o.length; d < p; d++) {
                    var f = (s = o[d]).getPoints(),
                        m = r(f);
                    (m = t ? !m : m) ? (!l && c[u] && u++, c[u] = {
                        s: new lr,
                        p: f
                    }, c[u].s.curves = s.curves, l && u++, h[u] = []) : h[u].push({
                        h: s,
                        p: f[0]
                    })
                }
                if (!c[0]) return i(o);
                if (1 < c.length) {
                    for (d = !1, t = [], r = 0, o = c.length; r < o; r++) a[r] = [];
                    for (r = 0, o = c.length; r < o; r++)
                        for (s = h[r], m = 0; m < s.length; m++) {
                            for (l = s[m], u = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && t.push({
                                froms: r,
                                tos: f,
                                hole: m
                            }), u ? (u = !1, a[f].push(l)) : d = !0);
                            u && a[r].push(l)
                        }
                    0 < t.length && (d || (h = a))
                }
                for (d = 0, r = c.length; d < r; d++)
                    for (a = c[d].s, e.push(a), o = 0, s = (t = h[d]).length; o < s; o++) a.holes.push(t[o].h);
                return e
            }
        }), Object.assign(Pr.prototype, {
            isFont: !0,
            generateShapes: function(t, e) {
                void 0 === e && (e = 100);
                var i = [],
                    n = e;
                e = this.data;
                var r = Array.from ? Array.from(t) : String(t).split("");
                n /= e.resolution;
                var o = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
                t = [];
                for (var s = 0, a = 0, l = 0; l < r.length; l++) {
                    var c = r[l];
                    if ("\n" === c) s = 0, a -= o;
                    else {
                        var h = c;
                        c = n;
                        var u = s,
                            d = a,
                            p = e,
                            f = p.glyphs[h] || p.glyphs["?"];
                        if (f) {
                            if (h = new Ar, f.o)
                                for (var m = 0, g = (p = f._cachedOutline || (f._cachedOutline = f.o.split(" "))).length; m < g;) switch (p[m++]) {
                                    case "m":
                                        var v = p[m++] * c + u,
                                            y = p[m++] * c + d;
                                        h.moveTo(v, y);
                                        break;
                                    case "l":
                                        v = p[m++] * c + u, y = p[m++] * c + d, h.lineTo(v, y);
                                        break;
                                    case "q":
                                        var _ = p[m++] * c + u,
                                            x = p[m++] * c + d,
                                            w = p[m++] * c + u,
                                            b = p[m++] * c + d;
                                        h.quadraticCurveTo(w, b, _, x);
                                        break;
                                    case "b":
                                        _ = p[m++] * c + u, x = p[m++] * c + d, w = p[m++] * c + u, b = p[m++] * c + d, v = p[m++] * c + u, y = p[m++] * c + d, h.bezierCurveTo(w, b, v, y, _, x)
                                }
                            c = {
                                offsetX: f.ha * c,
                                path: h
                            }
                        } else console.error('THREE.Font: character "' + h + '" does not exists in font family ' + p.familyName + "."), c = void 0;
                        s += c.offsetX, t.push(c.path)
                    }
                }
                for (e = 0, r = t.length; e < r; e++) Array.prototype.push.apply(i, t[e].toShapes());
                return i
            }
        }), Cr.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Cr,
            load: function(t, e, i, n) {
                var r = this,
                    o = new Fn(this.manager);
                o.setPath(this.path), o.load(t, function(t) {
                    try {
                        var i = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                    }
                    t = r.parse(i), e && e(t)
                }, i, n)
            },
            parse: function(t) {
                return new Pr(t)
            }
        });
        var Ll, Ol = {
            getContext: function() {
                return void 0 === Ll && (Ll = new(window.AudioContext || window.webkitAudioContext)), Ll
            },
            setContext: function(t) {
                Ll = t
            }
        };
        Rr.prototype = Object.assign(Object.create(zn.prototype), {
            constructor: Rr,
            load: function(t, e, i, n) {
                var r = new Fn(this.manager);
                r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function(t) {
                    t = t.slice(0), Ol.getContext().decodeAudioData(t, function(t) {
                        e(t)
                    })
                }, i, n)
            }
        }), Object.assign(Lr.prototype, {
            isSphericalHarmonics3: !0,
            set: function(t) {
                for (var e = 0; 9 > e; e++) this.coefficients[e].copy(t[e]);
                return this
            },
            zero: function() {
                for (var t = 0; 9 > t; t++) this.coefficients[t].set(0, 0, 0);
                return this
            },
            getAt: function(t, e) {
                var i = t.x,
                    n = t.y;
                t = t.z;
                var r = this.coefficients;
                return e.copy(r[0]).multiplyScalar(.282095), e.addScale(r[1], .488603 * n), e.addScale(r[2], .488603 * t), e.addScale(r[3], .488603 * i), e.addScale(r[4], 1.092548 * i * n), e.addScale(r[5], 1.092548 * n * t), e.addScale(r[6], .315392 * (3 * t * t - 1)), e.addScale(r[7], 1.092548 * i * t), e.addScale(r[8], .546274 * (i * i - n * n)), e
            },
            getIrradianceAt: function(t, e) {
                var i = t.x,
                    n = t.y;
                t = t.z;
                var r = this.coefficients;
                return e.copy(r[0]).multiplyScalar(.886227), e.addScale(r[1], 1.023328 * n), e.addScale(r[2], 1.023328 * t), e.addScale(r[3], 1.023328 * i), e.addScale(r[4], .858086 * i * n), e.addScale(r[5], .858086 * n * t), e.addScale(r[6], .743125 * t * t - .247708), e.addScale(r[7], .858086 * i * t), e.addScale(r[8], .429043 * (i * i - n * n)), e
            },
            add: function(t) {
                for (var e = 0; 9 > e; e++) this.coefficients[e].add(t.coefficients[e]);
                return this
            },
            scale: function(t) {
                for (var e = 0; 9 > e; e++) this.coefficients[e].multiplyScalar(t);
                return this
            },
            lerp: function(t, e) {
                for (var i = 0; 9 > i; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                return this
            },
            equals: function(t) {
                for (var e = 0; 9 > e; e++)
                    if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                return !0
            },
            copy: function(t) {
                return this.set(t.coefficients)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = this.coefficients, n = 0; 9 > n; n++) i[n].fromArray(t, e + 3 * n);
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                for (var i = this.coefficients, n = 0; 9 > n; n++) i[n].toArray(t, e + 3 * n);
                return t
            }
        }), Object.assign(Lr, {
            getBasisAt: function(t, e) {
                var i = t.x,
                    n = t.y;
                t = t.z, e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * t, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * t, e[6] = .315392 * (3 * t * t - 1), e[7] = 1.092548 * i * t, e[8] = .546274 * (i * i - n * n)
            }
        }), Or.prototype = Object.assign(Object.create(cr.prototype), {
            constructor: Or,
            isLightProbe: !0,
            copy: function(t) {
                return cr.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                return cr.prototype.toJSON.call(this, t)
            }
        }), kr.prototype = Object.assign(Object.create(Or.prototype), {
            constructor: kr,
            isHemisphereLightProbe: !0,
            copy: function(t) {
                return Or.prototype.copy.call(this, t), this
            },
            toJSON: function(t) {
                return Or.prototype.toJSON.call(this, t)
            }
        }), Dr.prototype = Object.assign(Object.create(Or.prototype), {
            constructor: Dr,
            isAmbientLightProbe: !0,
            copy: function(t) {
                return Or.prototype.copy.call(this, t), this
            },
            toJSON: function(t) {
                return Or.prototype.toJSON.call(this, t)
            }
        });
        var kl = new h,
            Dl = new h;
        Object.assign(Ir.prototype, {
            update: function(t) {
                var e = this._cache;
                if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                    e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                    var i = t.projectionMatrix.clone(),
                        n = e.eyeSep / 2,
                        r = n * e.near / e.focus,
                        o = e.near * Math.tan(Po.DEG2RAD * e.fov * .5) / e.zoom;
                    Dl.elements[12] = -n, kl.elements[12] = n, n = -o * e.aspect + r;
                    var s = o * e.aspect + r;
                    i.elements[0] = 2 * e.near / (s - n), i.elements[8] = (s + n) / (s - n), this.cameraL.projectionMatrix.copy(i), n = -o * e.aspect - r, s = o * e.aspect - r, i.elements[0] = 2 * e.near / (s - n), i.elements[8] = (s + n) / (s - n), this.cameraR.projectionMatrix.copy(i)
                }
                this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Dl), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(kl)
            }
        }), Object.assign(Nr.prototype, {
            start: function() {
                this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.autoStart = this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        });
        var Il = new r,
            Nl = new n,
            zl = new r,
            Fl = new r;
        zr.prototype = Object.assign(Object.create(p.prototype), {
            constructor: zr,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(t) {
                return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            },
            updateMatrixWorld: function(t) {
                p.prototype.updateMatrixWorld.call(this, t), t = this.context.listener;
                var e = this.up;
                if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Il, Nl, zl), Fl.set(0, 0, -1).applyQuaternion(Nl), t.positionX) {
                    var i = this.context.currentTime + this.timeDelta;
                    t.positionX.linearRampToValueAtTime(Il.x, i), t.positionY.linearRampToValueAtTime(Il.y, i), t.positionZ.linearRampToValueAtTime(Il.z, i), t.forwardX.linearRampToValueAtTime(Fl.x, i), t.forwardY.linearRampToValueAtTime(Fl.y, i), t.forwardZ.linearRampToValueAtTime(Fl.z, i), t.upX.linearRampToValueAtTime(e.x, i), t.upY.linearRampToValueAtTime(e.y, i), t.upZ.linearRampToValueAtTime(e.z, i)
                } else t.setPosition(Il.x, Il.y, Il.z), t.setOrientation(Fl.x, Fl.y, Fl.z, e.x, e.y, e.z)
            }
        }), Fr.prototype = Object.assign(Object.create(p.prototype), {
            constructor: Fr,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setMediaElementSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
            },
            setMediaStreamSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
            },
            setBuffer: function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                else {
                    if (!1 !== this.hasPlaybackControl) {
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
            },
            pause: function() {
                if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function() {
                if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            setDetune: function(t) {
                if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
            },
            getDetune: function() {
                return this.detune
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(t) {
                if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
            }
        });
        var Bl = new r,
            Hl = new n,
            Ul = new r,
            Gl = new r;
        Br.prototype = Object.assign(Object.create(Fr.prototype), {
            constructor: Br,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                return this.panner.refDistance = t, this
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                return this.panner.rolloffFactor = t, this
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                return this.panner.distanceModel = t, this
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                return this.panner.maxDistance = t, this
            },
            setDirectionalCone: function(t, e, i) {
                return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
            },
            updateMatrixWorld: function(t) {
                if (p.prototype.updateMatrixWorld.call(this, t), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
                    if (this.matrixWorld.decompose(Bl, Hl, Ul), Gl.set(0, 0, 1).applyQuaternion(Hl), (t = this.panner).positionX) {
                        var e = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(Bl.x, e), t.positionY.linearRampToValueAtTime(Bl.y, e), t.positionZ.linearRampToValueAtTime(Bl.z, e), t.orientationX.linearRampToValueAtTime(Gl.x, e), t.orientationY.linearRampToValueAtTime(Gl.y, e), t.orientationZ.linearRampToValueAtTime(Gl.z, e)
                    } else t.setPosition(Bl.x, Bl.y, Bl.z), t.setOrientation(Gl.x, Gl.y, Gl.z)
            }
        }), Object.assign(Hr.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign(Ur.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize;
                t = t * n + n;
                var r = this.cumulativeWeight;
                if (0 === r) {
                    for (r = 0; r !== n; ++r) i[t + r] = i[r];
                    r = e
                } else r += e, this._mixBufferRegion(i, t, 0, e / r, n);
                this.cumulativeWeight = r
            },
            apply: function(t) {
                var e = this.valueSize,
                    i = this.buffer;
                t = t * e + e;
                var n = this.cumulativeWeight,
                    r = this.binding;
                this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
                for (var o = e + e; n !== o; ++n)
                    if (i[n] !== i[n + e]) {
                        r.setValue(i, t);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.buffer,
                    e = this.valueSize,
                    i = 3 * e;
                this.binding.getValue(t, i);
                for (var n = e; n !== i; ++n) t[n] = t[i + n % e];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                this.binding.setValue(this.buffer, 3 * this.valueSize)
            },
            _select: function(t, e, i, n, r) {
                if (.5 <= n)
                    for (n = 0; n !== r; ++n) t[e + n] = t[i + n]
            },
            _slerp: function(t, e, i, r) {
                n.slerpFlat(t, e, t, e, t, i, r)
            },
            _lerp: function(t, e, i, n, r) {
                for (var o = 1 - n, s = 0; s !== r; ++s) {
                    var a = e + s;
                    t[a] = t[a] * o + t[i + s] * n
                }
            }
        });
        var jl = /[\[\]\.:\/]/g,
            Vl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
            Wl = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            ql = /(WCOD+)?/.source.replace("WCOD", Vl),
            Xl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            $l = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
            Yl = new RegExp("^" + Wl + ql + Xl + $l + "$"),
            Zl = ["material", "materials", "bones"];
        Object.assign(Gr.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._bindings[this._targetGroup.nCachedObjects_];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(jr, {
            Composite: Gr,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new jr.Composite(t, e, i) : new jr(t, e, i)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\s/g, "_").replace(jl, "")
            },
            parseTrackName: function(t) {
                var e = Yl.exec(t);
                if (!e) throw Error("PropertyBinding: Cannot parse trackName: " + t);
                var i = (e = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }).nodeName && e.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = e.nodeName.substring(i + 1); - 1 !== Zl.indexOf(n) && (e.nodeName = e.nodeName.substring(0, i), e.objectName = n)
                }
                if (null === e.propertyName || 0 === e.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return e
            },
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = t.skeleton.getBoneByName(e);
                    if (void 0 !== i) return i
                }
                if (t.children) {
                    var n = function(t) {
                        for (var i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (r.name === e || r.uuid === e || (r = n(r.children))) return r
                        }
                        return null
                    };
                    if (t = n(t.children)) return t
                }
                return null
            }
        }), Object.assign(jr.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (this.node = t = jr.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var o = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                                    if (t[i].name === o) {
                                        o = i;
                                        break
                                    } break;
                            default:
                                if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[i]
                        }
                        if (void 0 !== o) {
                            if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[o]
                        }
                    }
                    if (void 0 === (o = t[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.", t);
                    else {
                        if (e = this.Versioning.None, this.targetObject = t, void 0 !== t.needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (t.geometry.isBufferGeometry) {
                                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                    for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                        if (t.geometry.morphAttributes.position[i].name === r) {
                                            r = i;
                                            break
                                        }
                                } else {
                                    if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                    for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                        if (t.geometry.morphTargets[i].name === r) {
                                            r = i;
                                            break
                                        }
                                }
                            }
                            i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e]
                    }
                } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(jr.prototype, {
            _getValue_unbound: jr.prototype.getValue,
            _setValue_unbound: jr.prototype.setValue
        }), Object.assign(Vr.prototype, {
            isAnimationObjectGroup: !0,
            add: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, s = this._bindings, a = s.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
                    var u = arguments[c],
                        d = u.uuid,
                        p = n[d];
                    if (void 0 === p) {
                        p = e++, n[d] = p, t.push(u), d = 0;
                        for (var f = a; d !== f; ++d) s[d].push(new jr(u, r[d], o[d]))
                    } else if (p < i) {
                        l = t[p];
                        var m = --i;
                        for (n[(f = t[m]).uuid] = p, t[p] = f, n[d] = m, t[m] = u, d = 0, f = a; d !== f; ++d) {
                            var g = s[d],
                                v = g[p];
                            g[p] = g[m], void 0 === v && (v = new jr(u, r[d], o[d])), g[m] = v
                        }
                    } else t[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            },
            remove: function() {
                for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, s = arguments.length; o !== s; ++o) {
                    var a = arguments[o],
                        l = a.uuid,
                        c = i[l];
                    if (void 0 !== c && c >= e) {
                        var h = e++,
                            u = t[h];
                        for (i[u.uuid] = c, t[c] = u, i[l] = h, t[h] = a, a = 0, l = r; a !== l; ++a) {
                            var d = (u = n[a])[c];
                            u[c] = u[h], u[h] = d
                        }
                    }
                }
                this.nCachedObjects_ = e
            },
            uncache: function() {
                for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, s = 0, a = arguments.length; s !== a; ++s) {
                    var l = arguments[s].uuid,
                        c = n[l];
                    if (void 0 !== c)
                        if (delete n[l], c < i) {
                            var h = t[l = --i],
                                u = --e,
                                d = t[u];
                            for (n[h.uuid] = c, t[c] = h, n[d.uuid] = l, t[l] = d, t.pop(), h = 0, d = o; h !== d; ++h) {
                                var p = r[h],
                                    f = p[u];
                                p[c] = p[l], p[l] = f, p.pop()
                            }
                        } else
                            for (n[(d = t[u = --e]).uuid] = c, t[c] = d, t.pop(), h = 0, d = o; h !== d; ++h)(p = r[h])[c] = p[u], p.pop()
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var o = this._paths,
                    s = this._parsedPaths,
                    a = this._objects,
                    l = this.nCachedObjects_,
                    c = Array(a.length);
                for (n = r.length, i[t] = n, o.push(t), s.push(e), r.push(c), i = l, n = a.length; i !== n; ++i) c[i] = new jr(a[i], t, e);
                return c
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                    i = e[t];
                if (void 0 !== i) {
                    var n = this._paths,
                        r = this._parsedPaths,
                        o = this._bindings,
                        s = o.length - 1,
                        a = o[s];
                    e[t[s]] = i, o[i] = a, o.pop(), r[i] = r[s], r.pop(), n[i] = n[s], n.pop()
                }
            }
        }), Object.assign(Wr.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    i = this._clip.duration;
                    var n = t._clip.duration,
                        r = i / n;
                    t.warp(1, n / i, e), this.warp(r, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._timeScaleInterpolant,
                    s = this.timeScale;
                return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = t / s, o[1] = e / s, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, i, n) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        if (0 > (e = (t - r) * i) || 0 === i) return;
                        this._startTime = null, e *= i
                    }
                    if (e *= this._updateTimeScale(t), i = this._updateTime(e), 0 < (t = this._updateWeight(t))) {
                        e = this._interpolants, r = this._propertyBindings;
                        for (var o = 0, s = e.length; o !== s; ++o) e[o].evaluate(i), r[o].accumulate(n, t)
                    }
                } else this._updateWeight(t)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var i = this._weightInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0];
                        e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var i = this._timeScaleInterpolant;
                    if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                }
                return this._effectiveTimeScale = e
            },
            _updateTime: function(t) {
                var e = this.time + t,
                    i = this._clip.duration,
                    n = this.loop,
                    r = this._loopCount,
                    o = 2202 === n;
                if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? i - e : e;
                if (2200 === n) t: {
                    if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i) e = i;
                    else {
                        if (!(0 > e)) {
                            this.time = e;
                            break t
                        }
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = e,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > t ? -1 : 1
                    })
                }
                else {
                    if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || 0 > e) {
                        e -= i * (n = Math.floor(e / i)), r += Math.abs(n);
                        var s = this.repetitions - r;
                        0 >= s ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e = 0 < t ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < t ? 1 : -1
                        })) : (1 === s ? (t = 0 > t, this._setEndings(t, !t, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = e, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: n
                        }))
                    } else this.time = e;
                    if (o && 1 == (1 & r)) return i - e
                }
                return e
            },
            _setEndings: function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            },
            _scheduleFading: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._weightInterpolant;
                return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = e, n[1] = r + t, o[1] = i, this
            }
        }), qr.prototype = Object.assign(Object.create(e.prototype), {
            constructor: qr,
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    o = t._propertyBindings;
                t = t._interpolants;
                var s = i.uuid,
                    a = this._bindingsByRootAndName,
                    l = a[s];
                for (void 0 === l && (l = {}, a[s] = l), a = 0; a !== r; ++a) {
                    var c = n[a],
                        h = c.name,
                        u = l[h];
                    if (void 0 === u) {
                        if (void 0 !== (u = o[a])) {
                            null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, s, h));
                            continue
                        }++(u = new Ur(jr.create(i, h, e && e._propertyBindings[a].binding.parsedPath), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(u, s, h)
                    }
                    o[a] = u, t[a].resultBuffer = u.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            i = t._clip.uuid,
                            n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (i = 0, n = (e = t._propertyBindings).length; i !== n; ++i) {
                        var r = e[i];
                        0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                return null !== (t = t._cacheIndex) && t < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n = this._actions,
                    r = this._actionsByClip,
                    o = r[e];
                void 0 === o ? (o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = o) : (e = o.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    n = t._cacheIndex;
                i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid;
                var r = (n = (i = this._actionsByClip)[e]).knownActions,
                    o = r[r.length - 1],
                    s = t._byClipCacheIndex;
                o._byClipCacheIndex = s, r[s] = o, r.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete i[e], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                for (var e = 0, i = (t = t._propertyBindings).length; e !== i; ++e) {
                    var n = t[e];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = n[e],
                    o = this._bindings;
                void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = t.binding,
                    n = i.rootNode.uuid;
                i = i.path;
                var r = this._bindingsByRootAndName,
                    o = r[n],
                    s = e[e.length - 1];
                t = t._cacheIndex, s._cacheIndex = t, e[t] = s, e.pop(), delete o[i], 0 === Object.keys(o).length && delete r[n]
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && ((i = new Sn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid;
                t = null !== (i = "string" == typeof t ? Dn.findByName(i, t) : t) ? i.uuid : t;
                var r = this._actionsByClip[t],
                    o = null;
                if (void 0 !== r) {
                    if (void 0 !== (o = r.actionByRoot[n])) return o;
                    o = r.knownActions[0], null === i && (i = o._clip)
                }
                return null === i ? null : (e = new Wr(this, i, e), this._bindAction(e, o), this._addInactiveAction(e, t, n), e)
            },
            existingAction: function(t, e) {
                var i = e || this._root;
                return e = i.uuid, i = "string" == typeof t ? Dn.findByName(i, t) : t, void 0 !== (t = this._actionsByClip[i ? i.uuid : t]) && t.actionByRoot[e] || null
            },
            stopAllAction: function() {
                for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r) t[r].reset();
                for (r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, s = 0; s !== i; ++s) e[s]._update(n, t, r, o);
                for (t = this._bindings, e = this._nActiveBindings, s = 0; s !== e; ++s) t[s].apply(o);
                return this
            },
            setTime: function(t) {
                for (var e = this.time = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                return this.update(t)
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions;
                t = t.uuid;
                var i = this._actionsByClip,
                    n = i[t];
                if (void 0 !== n) {
                    for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) {
                        var s = n[r];
                        this._deactivateAction(s);
                        var a = s._cacheIndex,
                            l = e[e.length - 1];
                        s._cacheIndex = null, s._byClipCacheIndex = null, l._cacheIndex = a, e[a] = l, e.pop(), this._removeInactiveBindingsForAction(s)
                    }
                    delete i[t]
                }
            },
            uncacheRoot: function(t) {
                t = t.uuid;
                var e = this._actionsByClip;
                for (n in e) {
                    var i = e[n].actionByRoot[t];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                var n = this._bindingsByRootAndName[t];
                if (void 0 !== n)
                    for (var r in n)(t = n[r]).restoreOriginalState(), this._removeInactiveBinding(t)
            },
            uncacheAction: function(t, e) {
                null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t), this._removeInactiveAction(t))
            }
        }), Xr.prototype.clone = function() {
            return new Xr(void 0 === this.value.clone ? this.value : this.value.clone())
        }, $r.prototype = Object.assign(Object.create(He.prototype), {
            constructor: $r,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return He.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(Yr.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e, i) {
                return Jr(t, this, i = i || [], e), i.sort(Zr), i
            },
            intersectObjects: function(t, e, i) {
                if (i = i || [], !1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var n = 0, r = t.length; n < r; n++) Jr(t[n], this, i, e);
                return i.sort(Zr), i
            }
        }), Object.assign(Qr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            },
            setFromCartesianCoords: function(t, e, i) {
                return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Po.clamp(e / this.radius, -1, 1))), this
            }
        }), Object.assign(Kr.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.setFromCartesianCoords(t.x, t.y, t.z)
            },
            setFromCartesianCoords: function(t, e, i) {
                return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
            }
        });
        var Jl = new i;
        Object.assign(to.prototype, {
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function(t, e) {
                return e = Jl.copy(e).multiplyScalar(.5), this.min.copy(t).sub(e), this.max.copy(t).add(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new i), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new i), e.copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function(t) {
                return Jl.copy(t).clamp(this.min, this.max).sub(t).length()
            },
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        });
        var Ql = new r,
            Kl = new r;
        Object.assign(eo.prototype, {
            set: function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function(t) {
                return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new r), t.addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new r), t.subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new r), this.delta(e).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function(t, e) {
                return Ql.subVectors(t, this.start), Kl.subVectors(this.end, this.start), t = Kl.dot(Kl), t = Kl.dot(Ql) / t, e && (t = Po.clamp(t, 0, 1)), t
            },
            closestPointToPoint: function(t, e, i) {
                return t = this.closestPointToPointParameter(t, e), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(t).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), io.prototype = Object.create(p.prototype), io.prototype.constructor = io, io.prototype.isImmediateRenderObject = !0;
        var tc = new r,
            ec = new r,
            ic = new o,
            nc = ["a", "b", "c"];
        no.prototype = Object.create(Qe.prototype), no.prototype.constructor = no, no.prototype.update = function() {
            this.object.updateMatrixWorld(!0), ic.getNormalMatrix(this.object.matrixWorld);
            var t = this.object.matrixWorld,
                e = this.geometry.attributes.position,
                i = this.object.geometry;
            if (i && i.isGeometry)
                for (var n = i.vertices, r = i.faces, o = i = 0, s = r.length; o < s; o++)
                    for (var a = r[o], l = 0, c = a.vertexNormals.length; l < c; l++) {
                        var h = a.vertexNormals[l];
                        tc.copy(n[a[nc[l]]]).applyMatrix4(t), ec.copy(h).applyMatrix3(ic).normalize().multiplyScalar(this.size).add(tc), e.setXYZ(i, tc.x, tc.y, tc.z), i += 1, e.setXYZ(i, ec.x, ec.y, ec.z), i += 1
                    } else if (i && i.isBufferGeometry)
                        for (n = i.attributes.position, r = i.attributes.normal, l = i = 0, c = n.count; l < c; l++) tc.set(n.getX(l), n.getY(l), n.getZ(l)).applyMatrix4(t), ec.set(r.getX(l), r.getY(l), r.getZ(l)), ec.applyMatrix3(ic).normalize().multiplyScalar(this.size).add(tc), e.setXYZ(i, tc.x, tc.y, tc.z), i += 1, e.setXYZ(i, ec.x, ec.y, ec.z), i += 1;
            e.needsUpdate = !0
        };
        var rc = new r;
        ro.prototype = Object.create(p.prototype), ro.prototype.constructor = ro, ro.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, ro.prototype.update = function() {
            this.light.updateMatrixWorld();
            var t = this.light.distance ? this.light.distance : 1e3,
                e = t * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, t), rc.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(rc), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        };
        var oc = new r,
            sc = new h,
            ac = new h;
        oo.prototype = Object.create(Qe.prototype), oo.prototype.constructor = oo, oo.prototype.updateMatrixWorld = function(t) {
            var e = this.bones,
                i = this.geometry,
                n = i.getAttribute("position");
            ac.getInverse(this.root.matrixWorld);
            for (var r = 0, o = 0; r < e.length; r++) {
                var s = e[r];
                s.parent && s.parent.isBone && (sc.multiplyMatrices(ac, s.matrixWorld), oc.setFromMatrixPosition(sc), n.setXYZ(o, oc.x, oc.y, oc.z), sc.multiplyMatrices(ac, s.parent.matrixWorld), oc.setFromMatrixPosition(sc), n.setXYZ(o + 1, oc.x, oc.y, oc.z), o += 2)
            }
            i.getAttribute("position").needsUpdate = !0, p.prototype.updateMatrixWorld.call(this, t)
        }, so.prototype = Object.create(H.prototype), so.prototype.constructor = so, so.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, so.prototype.update = function() {
            void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }, ao.prototype = Object.create(Je.prototype), ao.prototype.constructor = ao, ao.prototype.update = function() {
            if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
            else {
                this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                var t = this.material.color,
                    e = Math.max(t.r, t.g, t.b);
                1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
            }
        }, ao.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
        };
        var lc = new r,
            cc = new x,
            hc = new x;
        lo.prototype = Object.create(p.prototype), lo.prototype.constructor = lo, lo.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, lo.prototype.update = function() {
            var t = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
                var e = t.geometry.getAttribute("color");
                cc.copy(this.light.color), hc.copy(this.light.groundColor);
                for (var i = 0, n = e.count; i < n; i++) {
                    var r = i < n / 2 ? cc : hc;
                    e.setXYZ(i, r.r, r.g, r.b)
                }
                e.needsUpdate = !0
            }
            t.lookAt(lc.setFromMatrixPosition(this.light.matrixWorld).negate())
        }, co.prototype = Object.create(H.prototype), co.prototype.constructor = co, co.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, co.prototype.onBeforeRender = function() {
            this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
        }, ho.prototype = Object.assign(Object.create(Qe.prototype), {
            constructor: ho,
            copy: function(t) {
                return Qe.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), uo.prototype = Object.create(Qe.prototype), uo.prototype.constructor = uo, po.prototype = Object.create(Je.prototype), po.prototype.constructor = po, po.prototype.update = function() {
            function t(t, n, o, s) {
                for (o = (n - t) / o, p.setXYZ(h, 0, 0, 0), u++, e = t; e < n; e += o) i = h + u, p.setXYZ(i, Math.sin(e) * r, 0, Math.cos(e) * r), p.setXYZ(i + 1, Math.sin(Math.min(e + o, n)) * r, 0, Math.cos(Math.min(e + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), u += 3;
                d.addGroup(h, u, s), h += u, u = 0
            }
            var e, i, n = this.audio,
                r = this.range,
                o = this.divisionsInnerAngle,
                s = this.divisionsOuterAngle,
                a = Po.degToRad(n.panner.coneInnerAngle),
                l = a / 2,
                c = (n = Po.degToRad(n.panner.coneOuterAngle)) / 2,
                h = 0,
                u = 0,
                d = this.geometry,
                p = d.attributes.position;
            d.clearGroups(), t(-c, -l, s, 0), t(-l, l, o, 1), t(l, c, s, 0), p.needsUpdate = !0, a === n && (this.material[0].visible = !1)
        }, po.prototype.dispose = function() {
            this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
        };
        var uc = new r,
            dc = new r,
            pc = new o;
        fo.prototype = Object.create(Qe.prototype), fo.prototype.constructor = fo, fo.prototype.update = function() {
            this.object.updateMatrixWorld(!0), pc.getNormalMatrix(this.object.matrixWorld);
            for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, i = this.object.geometry, n = i.vertices, r = 0, o = 0, s = (i = i.faces).length; o < s; o++) {
                var a = i[o],
                    l = a.normal;
                uc.copy(n[a.a]).add(n[a.b]).add(n[a.c]).divideScalar(3).applyMatrix4(t), dc.copy(l).applyMatrix3(pc).normalize().multiplyScalar(this.size).add(uc), e.setXYZ(r, uc.x, uc.y, uc.z), r += 1, e.setXYZ(r, dc.x, dc.y, dc.z), r += 1
            }
            e.needsUpdate = !0
        };
        var fc = new r,
            mc = new r,
            gc = new r;
        mo.prototype = Object.create(p.prototype), mo.prototype.constructor = mo, mo.prototype.dispose = function() {
            this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
        }, mo.prototype.update = function() {
            fc.setFromMatrixPosition(this.light.matrixWorld), mc.setFromMatrixPosition(this.light.target.matrixWorld), gc.subVectors(mc, fc), this.lightPlane.lookAt(mc), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(mc), this.targetLine.scale.z = gc.length()
        };
        var vc = new r,
            yc = new X;
        go.prototype = Object.create(Qe.prototype), go.prototype.constructor = go, go.prototype.update = function() {
            var t = this.geometry,
                e = this.pointMap;
            yc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), vo("c", e, t, yc, 0, 0, -1), vo("t", e, t, yc, 0, 0, 1), vo("n1", e, t, yc, -1, -1, -1), vo("n2", e, t, yc, 1, -1, -1), vo("n3", e, t, yc, -1, 1, -1), vo("n4", e, t, yc, 1, 1, -1), vo("f1", e, t, yc, -1, -1, 1), vo("f2", e, t, yc, 1, -1, 1), vo("f3", e, t, yc, -1, 1, 1), vo("f4", e, t, yc, 1, 1, 1), vo("u1", e, t, yc, .7, 1.1, -1), vo("u2", e, t, yc, -.7, 1.1, -1), vo("u3", e, t, yc, 0, 2, -1), vo("cf1", e, t, yc, -1, 0, 1), vo("cf2", e, t, yc, 1, 0, 1), vo("cf3", e, t, yc, 0, -1, 1), vo("cf4", e, t, yc, 0, 1, 1), vo("cn1", e, t, yc, -1, 0, -1), vo("cn2", e, t, yc, 1, 0, -1), vo("cn3", e, t, yc, 0, -1, -1), vo("cn4", e, t, yc, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
        };
        var _c = new m;
        yo.prototype = Object.create(Qe.prototype), yo.prototype.constructor = yo, yo.prototype.update = function(t) {
            if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && _c.setFromObject(this.object), !_c.isEmpty()) {
                t = _c.min;
                var e = _c.max,
                    i = this.geometry.attributes.position,
                    n = i.array;
                n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = t.x, n[4] = e.y, n[5] = e.z, n[6] = t.x, n[7] = t.y, n[8] = e.z, n[9] = e.x, n[10] = t.y, n[11] = e.z, n[12] = e.x, n[13] = e.y, n[14] = t.z, n[15] = t.x, n[16] = e.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = e.x, n[22] = t.y, n[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }, yo.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        }, yo.prototype.copy = function(t) {
            return Qe.prototype.copy.call(this, t), this.object = t.object, this
        }, yo.prototype.clone = function() {
            return (new this.constructor).copy(this)
        }, _o.prototype = Object.create(Qe.prototype), _o.prototype.constructor = _o, _o.prototype.updateMatrixWorld = function(t) {
            var e = this.box;
            e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), p.prototype.updateMatrixWorld.call(this, t))
        }, xo.prototype = Object.create(Je.prototype), xo.prototype.constructor = xo, xo.prototype.updateMatrixWorld = function(t) {
            var e = -this.plane.constant;
            1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), p.prototype.updateMatrixWorld.call(this, t)
        };
        var xc, wc, bc = new r;
        wo.prototype = Object.create(p.prototype), wo.prototype.constructor = wo, wo.prototype.setDirection = function(t) {
            .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > t.y ? this.quaternion.set(1, 0, 0, 0) : (bc.set(t.z, 0, -t.x).normalize(), this.quaternion.setFromAxisAngle(bc, Math.acos(t.y)))
        }, wo.prototype.setLength = function(t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, wo.prototype.setColor = function(t) {
            this.line.material.color.set(t), this.cone.material.color.set(t)
        }, wo.prototype.copy = function(t) {
            return p.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
        }, wo.prototype.clone = function() {
            return (new this.constructor).copy(this)
        }, bo.prototype = Object.create(Qe.prototype), bo.prototype.constructor = bo, Wn.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Wn.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, Object.assign(sr.prototype, {
            createPointsGeometry: function(t) {
                return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getPoints(t), this.createGeometry(t)
            },
            createSpacedPointsGeometry: function(t) {
                return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getSpacedPoints(t), this.createGeometry(t)
            },
            createGeometry: function(t) {
                console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                for (var e = new j, i = 0, n = t.length; i < n; i++) {
                    var o = t[i];
                    e.vertices.push(new r(o.x, o.y, o.z || 0))
                }
                return e
            }
        }), Object.assign(ar.prototype, {
            fromPoints: function(t) {
                console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }
        }), To.prototype = Object.create(Yn.prototype), So.prototype = Object.create(Yn.prototype), Mo.prototype = Object.create(Yn.prototype), Object.assign(Mo.prototype, {
            initFromArray: function() {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function() {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function() {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), ho.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, oo.prototype.update = function() {
            console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
        }, Object.assign(zn.prototype, {
            extractUrlBase: function(t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), El.extractUrlBase(t)
            }
        }), zn.Handlers = {
            add: function() {
                console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
            },
            get: function() {
                console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
            }
        }, Object.assign(Mr.prototype, {
            setTexturePath: function(t) {
                return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
            }
        }), Object.assign(to.prototype, {
            center: function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            size: function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign(m.prototype, {
            center: function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            },
            size: function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), eo.prototype.center = function(t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Object.assign(Po, {
            random16: function() {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            nearestPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Po.floorPowerOfTwo(t)
            },
            nextPowerOfTwo: function(t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Po.ceilPowerOfTwo(t)
            }
        }), Object.assign(o.prototype, {
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(h.prototype, {
            extractPosition: function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            },
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            getPosition: function() {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new r).setFromMatrixColumn(this, 3)
            },
            setRotationFromQuaternion: function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector4: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector3Array: function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            },
            rotateAxis: function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            },
            crossVector: function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            translate: function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBuffer: function(t) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function(t, e, i, n, r, o) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
            }
        }), Q.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, n.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(y.prototype, {
            isIntersectionBox: function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionPlane: function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(_.prototype, {
            area: function() {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            },
            barycoordFromPoint: function(t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
            },
            midpoint: function(t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
            },
            normal: function(t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
            },
            plane: function(t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
            }
        }), Object.assign(_, {
            barycoordFromPoint: function(t, e, i, n, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _.getBarycoord(t, e, i, n, r)
            },
            normal: function(t, e, i, n) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _.getNormal(t, e, i, n)
            }
        }), Object.assign(lr.prototype, {
            extractAllPoints: function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            },
            extrude: function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Vi(this, t)
            },
            makeGeometry: function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new en(this, t)
            }
        }), Object.assign(i.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(r.prototype, {
            setEulerFromRotationMatrix: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            },
            applyProjection: function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            },
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            distanceToManhattan: function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(a.prototype, {
            fromAttribute: function(t, e, i) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            },
            lengthManhattan: function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }
        }), Object.assign(j.prototype, {
            computeTangents: function() {
                console.error("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function() {
                console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
            }
        }), Object.assign(p.prototype, {
            getChildByName: function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            },
            renderDepth: function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            },
            getWorldRotation: function() {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }
        }), Object.defineProperties(p.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(We.prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(Xe.prototype, "useVertexTexture", {
            get: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), qe.prototype.initBones = function() {
            console.error("THREE.SkinnedMesh: initBones() has been removed.")
        }, Object.defineProperty(Wn.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function(t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
            }
        }), $.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(cr.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(A.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }
        }), Object.assign(A.prototype, {
            copyIndicesArray: function() {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            },
            setArray: function(t) {
                return console.warn("THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
            }
        }), Object.assign(B.prototype, {
            addIndex: function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            },
            addDrawCall: function(t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            },
            clearDrawCalls: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(B.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.assign(He.prototype, {
            setArray: function(t) {
                return console.warn("THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"), this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
            }
        }), Object.assign(Wi.prototype, {
            getArrays: function() {
                console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
            },
            addShapeList: function() {
                console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
            },
            addShape: function() {
                console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
            }
        }), Object.defineProperties(Xr.prototype, {
            dynamic: {
                set: function() {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(M.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            overdraw: {
                get: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .overdraw has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new x
                }
            },
            shading: {
                get: function() {
                    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                }
            },
            stencilMask: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                },
                set: function(t) {
                    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                }
            }
        }), Object.defineProperties(gn.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function() {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(q.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Object.assign(ze.prototype, {
            clearTarget: function(t, e, i, n) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
            },
            animate: function(t) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
            },
            getCurrentRenderTarget: function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            getMaxAnisotropy: function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            },
            getPrecision: function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            },
            resetGLState: function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            },
            supportsFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            },
            initMaterial: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            },
            setFaceCulling: function() {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            },
            allocTextureUnit: function() {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            },
            setTexture: function() {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            },
            setTexture2D: function() {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            },
            setTextureCube: function() {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            },
            getActiveMipMapLevel: function() {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }
        }), Object.defineProperties(ze.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            context: {
                get: function() {
                    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                }
            }
        }), Object.defineProperties(Ee.prototype, {
            cullFace: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                }
            },
            renderReverseSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                }
            },
            renderSingleSided: {
                get: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                },
                set: function() {
                    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                }
            }
        }), Object.defineProperties(Z.prototype, {
            activeCubeFace: {
                set: function() {
                    console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                }
            },
            activeMipMapLevel: {
                set: function() {
                    console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                }
            }
        }), Object.defineProperties(l.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), Object.defineProperties(Ie.prototype, {
            standing: {
                set: function() {
                    console.warn("THREE.WebVRManager: .standing has been removed.")
                }
            },
            userHeight: {
                set: function() {
                    console.warn("THREE.WebVRManager: .userHeight has been removed.")
                }
            }
        }), Fr.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this;
            return (new Rr).load(t, function(t) {
                e.setBuffer(t)
            }), this
        }, Hr.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, Y.prototype.updateCubeMap = function(t, e) {
            return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
        }, ko.crossOrigin = void 0, ko.loadTexture = function(t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var r = new Vn;
            return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
        }, ko.loadTextureCube = function(t, e, i, n) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var r = new jn;
            return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
        }, ko.loadCompressedTexture = function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        }, ko.loadCompressedTextureCube = function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: "109"
            }
        })), t.ACESFilmicToneMapping = 5, t.AddEquation = 100, t.AddOperation = 2, t.AdditiveBlending = 2, t.AlphaFormat = 1021, t.AlwaysDepth = 1, t.AlwaysStencilFunc = 519, t.AmbientLight = _r, t.AmbientLightProbe = Dr, t.AnimationClip = Dn, t.AnimationLoader = Bn, t.AnimationMixer = qr, t.AnimationObjectGroup = Vr, t.AnimationUtils = vl, t.ArcCurve = Xn, t.ArrayCamera = ke, t.ArrowHelper = wo, t.Audio = Fr, t.AudioAnalyser = Hr, t.AudioContext = Ol, t.AudioListener = zr, t.AudioLoader = Rr, t.AxesHelper = bo, t.AxisHelper = function(t) {
            return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new bo(t)
        }, t.BackSide = 1, t.BasicDepthPacking = 3200, t.BasicShadowMap = 0, t.BinaryTextureLoader = function(t) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Un(t)
        }, t.Bone = $e, t.BooleanKeyframeTrack = An, t.BoundingBoxHelper = function(t, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new yo(t, e)
        }, t.Box2 = to, t.Box3 = m, t.Box3Helper = _o, t.BoxBufferGeometry = da, t.BoxGeometry = ua, t.BoxHelper = yo, t.BufferAttribute = A, t.BufferGeometry = B, t.BufferGeometryLoader = Sr, t.ByteType = 1010, t.Cache = yl, t.Camera = X, t.CameraHelper = go, t.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been removed")
        }, t.CanvasTexture = oi, t.CatmullRomCurve3 = Yn, t.CineonToneMapping = 4, t.CircleBufferGeometry = un, t.CircleGeometry = hn, t.ClampToEdgeWrapping = 1001, t.Clock = Nr, t.ClosedSplineCurve3 = To, t.Color = x, t.ColorKeyframeTrack = Pn, t.CompressedTexture = ri, t.CompressedTextureLoader = Hn, t.ConeBufferGeometry = cn, t.ConeGeometry = ln, t.CubeCamera = Y, t.CubeGeometry = ua, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.CubeTexture = mt, t.CubeTextureLoader = jn, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.CubicBezierCurve = Kn, t.CubicBezierCurve3 = tr, t.CubicInterpolant = Tn, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.CullFaceNone = 0, t.Curve = Wn, t.CurvePath = sr, t.CustomBlending = 5, t.CylinderBufferGeometry = an, t.CylinderGeometry = sn, t.Cylindrical = Kr, t.DataTexture = J, t.DataTexture2DArray = gt, t.DataTexture3D = vt, t.DataTextureLoader = Un, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = _l, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.DepthTexture = si, t.DirectionalLight = yr, t.DirectionalLightHelper = mo, t.DirectionalLightShadow = vr, t.DiscreteInterpolant = Mn, t.DodecahedronBufferGeometry = _i, t.DodecahedronGeometry = yi, t.DoubleSide = 2, t.DstAlphaFactor = 206, t.DstColorFactor = 208, t.DynamicBufferAttribute = function(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(t, e).setDynamic(!0)
        }, t.EdgesGeometry = on, t.EdgesHelper = function(t, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Qe(new on(t.geometry), new Ze({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.EllipseCurve = qn, t.EqualDepth = 4, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.Euler = u, t.EventDispatcher = e, t.ExtrudeBufferGeometry = Wi, t.ExtrudeGeometry = Vi, t.Face3 = S, t.Face4 = function(t, e, i, n, r, o, s) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new S(t, e, i, r, o, s)
        }, t.FaceColors = 1, t.FaceNormalsHelper = fo, t.FileLoader = Fn, t.FlatShading = 1, t.Float32Attribute = function(t, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new I(t, e)
        }, t.Float32BufferAttribute = I, t.Float64Attribute = function(t, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new N(t, e)
        }, t.Float64BufferAttribute = N, t.FloatType = 1015, t.Fog = Be, t.FogExp2 = Fe, t.Font = Pr, t.FontLoader = Cr, t.FrontFaceDirectionCCW = 1, t.FrontFaceDirectionCW = 0, t.FrontSide = 0, t.Frustum = K, t.GammaEncoding = 3007, t.Geometry = j, t.GeometryUtils = {
            merge: function(t, e, i) {
                if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh) {
                    e.matrixAutoUpdate && e.updateMatrix();
                    var n = e.matrix;
                    e = e.geometry
                }
                t.merge(e, n, i)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        }, t.GreaterDepth = 6, t.GreaterEqualDepth = 5, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = ho, t.Group = Oe, t.HalfFloatType = 1016, t.HemisphereLight = hr, t.HemisphereLightHelper = lo, t.HemisphereLightProbe = kr, t.IcosahedronBufferGeometry = vi, t.IcosahedronGeometry = gi, t.ImageBitmapLoader = Er, t.ImageLoader = Gn, t.ImageUtils = ko, t.ImmediateRenderObject = io, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Tr, t.InstancedBufferGeometry = br, t.InstancedInterleavedBuffer = $r, t.InstancedMesh = Ye, t.Int16Attribute = function(t, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new L(t, e)
        }, t.Int16BufferAttribute = L, t.Int32Attribute = function(t, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new k(t, e)
        }, t.Int32BufferAttribute = k, t.Int8Attribute = function(t, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new P(t, e)
        }, t.Int8BufferAttribute = P, t.IntType = 1013, t.InterleavedBuffer = He, t.InterleavedBufferAttribute = Ue, t.Interpolant = bn, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.InvertStencilOp = 5386, t.JSONLoader = function() {
            console.error("THREE.JSONLoader has been removed.")
        }, t.KeepStencilOp = 7680, t.KeyframeTrack = En, t.LOD = We, t.LatheBufferGeometry = tn, t.LatheGeometry = Ki, t.Layers = d, t.LensFlare = function() {
            console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
        }, t.LessDepth = 2, t.LessEqualDepth = 3, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = cr, t.LightProbe = Or, t.LightProbeHelper = co, t.LightShadow = ur, t.Line = Je, t.Line3 = eo, t.LineBasicMaterial = Ze, t.LineCurve = er, t.LineCurve3 = ir, t.LineDashedMaterial = wn, t.LineLoop = Ke, t.LinePieces = 1, t.LineSegments = Qe, t.LineStrip = 0, t.LinearEncoding = 3e3, t.LinearFilter = 1006, t.LinearInterpolant = Sn, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = 1008, t.LinearMipmapNearestFilter = 1007, t.LinearToneMapping = 1, t.Loader = zn, t.LoaderUtils = El, t.LoadingManager = Nn, t.LogLuvEncoding = 3003, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = 1025, t.LuminanceFormat = 1024, t.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }, t.Material = M, t.MaterialLoader = wr, t.Math = Po, t.Matrix3 = o, t.Matrix4 = h, t.MaxEquation = 104, t.Mesh = H, t.MeshBasicMaterial = E, t.MeshDepthMaterial = Se, t.MeshDistanceMaterial = Me, t.MeshFaceMaterial = function(t) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
        }, t.MeshLambertMaterial = _n, t.MeshMatcapMaterial = xn, t.MeshNormalMaterial = yn, t.MeshPhongMaterial = gn, t.MeshPhysicalMaterial = mn, t.MeshStandardMaterial = fn, t.MeshToonMaterial = vn, t.MinEquation = 103, t.MirroredRepeatWrapping = 1002, t.MixOperation = 1, t.MultiMaterial = function(t) {
            return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                return t.slice()
            }, t
        }, t.MultiplyBlending = 4, t.MultiplyOperation = 0, t.NearestFilter = 1003, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = 1005, t.NearestMipmapNearestFilter = 1004, t.NeverDepth = 0, t.NeverStencilFunc = 512, t.NoBlending = 0, t.NoColors = 0, t.NoToneMapping = 0, t.NormalBlending = 1, t.NotEqualDepth = 7, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = Cn, t.Object3D = p, t.ObjectLoader = Mr, t.ObjectSpaceNormalMap = 1, t.OctahedronBufferGeometry = mi, t.OctahedronGeometry = fi, t.OneFactor = 201, t.OneMinusDstAlphaFactor = 207, t.OneMinusDstColorFactor = 209, t.OneMinusSrcAlphaFactor = 205, t.OneMinusSrcColorFactor = 203, t.OrthographicCamera = gr, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.ParametricBufferGeometry = ci, t.ParametricGeometry = li, t.Particle = function(t) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new je(t)
        }, t.ParticleBasicMaterial = function(t) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ti(t)
        }, t.ParticleSystem = function(t, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new ei(t, e)
        }, t.ParticleSystemMaterial = function(t) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ti(t)
        }, t.Path = ar, t.PerspectiveCamera = $, t.Plane = Q, t.PlaneBufferGeometry = nt, t.PlaneGeometry = it, t.PlaneHelper = xo, t.PointCloud = function(t, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new ei(t, e)
        }, t.PointCloudMaterial = function(t) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ti(t)
        }, t.PointLight = mr, t.PointLightHelper = so, t.Points = ei, t.PointsMaterial = ti, t.PolarGridHelper = uo, t.PolyhedronBufferGeometry = ui, t.PolyhedronGeometry = hi, t.PositionalAudio = Br, t.PositionalAudioHelper = po, t.PropertyBinding = jr, t.PropertyMixer = Ur, t.QuadraticBezierCurve = nr, t.QuadraticBezierCurve3 = rr, t.Quaternion = n, t.QuaternionKeyframeTrack = Ln, t.QuaternionLinearInterpolant = Rn, t.REVISION = "109", t.RGBADepthPacking = 3201, t.RGBAFormat = 1023, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_PVRTC_2BPPV1_Format = 35843, t.RGBA_PVRTC_4BPPV1_Format = 35842, t.RGBA_S3TC_DXT1_Format = 33777, t.RGBA_S3TC_DXT3_Format = 33778, t.RGBA_S3TC_DXT5_Format = 33779, t.RGBDEncoding = 3006, t.RGBEEncoding = 3002, t.RGBEFormat = 1023, t.RGBFormat = 1022, t.RGBM16Encoding = 3005, t.RGBM7Encoding = 3004, t.RGB_ETC1_Format = 36196, t.RGB_PVRTC_2BPPV1_Format = 35841, t.RGB_PVRTC_4BPPV1_Format = 35840, t.RGB_S3TC_DXT1_Format = 33776, t.RawShaderMaterial = pn, t.Ray = y, t.Raycaster = Yr, t.RectAreaLight = xr, t.RectAreaLightHelper = ao, t.RedFormat = 1028, t.ReinhardToneMapping = 2, t.RepeatWrapping = 1e3, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = 102, t.RingBufferGeometry = Qi, t.RingGeometry = Ji, t.Scene = f, t.SceneUtils = {
            createMultiMaterialObject: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            },
            detach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            },
            attach: function() {
                console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
            }
        }, t.ShaderChunk = _a, t.ShaderLib = wa, t.ShaderMaterial = q, t.ShadowMaterial = dn, t.Shape = lr, t.ShapeBufferGeometry = nn, t.ShapeGeometry = en, t.ShapePath = Ar, t.ShapeUtils = pl, t.ShortType = 1011, t.Skeleton = Xe, t.SkeletonHelper = oo, t.SkinnedMesh = qe, t.SmoothShading = 2, t.Sphere = v, t.SphereBufferGeometry = Zi, t.SphereGeometry = Yi, t.Spherical = Qr, t.SphericalHarmonics3 = Lr, t.SphericalReflectionMapping = 305, t.Spline = Mo, t.SplineCurve = or, t.SplineCurve3 = So, t.SpotLight = pr, t.SpotLightHelper = ro, t.SpotLightShadow = dr, t.Sprite = je, t.SpriteMaterial = Ge, t.SrcAlphaFactor = 204, t.SrcAlphaSaturateFactor = 210, t.SrcColorFactor = 202, t.StereoCamera = Ir, t.StringKeyframeTrack = On, t.SubtractEquation = 101, t.SubtractiveBlending = 3, t.TOUCH = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }, t.TangentSpaceNormalMap = 0, t.TetrahedronBufferGeometry = pi, t.TetrahedronGeometry = di, t.TextBufferGeometry = $i, t.TextGeometry = Xi, t.Texture = s, t.TextureLoader = Vn, t.TorusBufferGeometry = Mi, t.TorusGeometry = Si, t.TorusKnotBufferGeometry = Ti, t.TorusKnotGeometry = bi, t.Triangle = _, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = wi, t.TubeGeometry = xi, t.UVMapping = 300, t.Uint16Attribute = function(t, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new O(t, e)
        }, t.Uint16BufferAttribute = O, t.Uint32Attribute = function(t, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new D(t, e)
        }, t.Uint32BufferAttribute = D, t.Uint8Attribute = function(t, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new C(t, e)
        }, t.Uint8BufferAttribute = C, t.Uint8ClampedAttribute = function(t, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new R(t, e)
        }, t.Uint8ClampedBufferAttribute = R, t.Uncharted2ToneMapping = 3, t.Uniform = Xr, t.UniformsLib = xa, t.UniformsUtils = pa, t.UnsignedByteType = 1009, t.UnsignedInt248Type = 1020, t.UnsignedIntType = 1014, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedShortType = 1012, t.VSMShadowMap = 3, t.Vector2 = i, t.Vector3 = r, t.Vector4 = a, t.VectorKeyframeTrack = kn, t.Vertex = function(t, e, i) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(t, e, i)
        }, t.VertexColors = 2, t.VertexNormalsHelper = no, t.VideoTexture = ni, t.WebGLMultisampleRenderTarget = c, t.WebGLRenderTarget = l, t.WebGLRenderTargetCube = Z, t.WebGLRenderer = ze, t.WebGLUtils = Ce, t.WireframeGeometry = ai, t.WireframeHelper = function(t, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Qe(new ai(t.geometry), new Ze({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.WrapAroundEnding = 2402, t.XHRLoader = function(t) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fn(t)
        }, t.ZeroCurvatureEnding = 2400, t.ZeroFactor = 200, t.ZeroSlopeEnding = 2401, t.ZeroStencilOp = 0, t.sRGBEncoding = 3001, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }),
    function(t) {
        "function" == typeof define && define.amd ? define(["jquery"], t) : "object" == typeof module && module.exports ? module.exports = function(e, i) {
            return void 0 === i && (i = "undefined" != typeof window ? require("jquery") : require("jquery")(e)), t(i), i
        } : t(jQuery)
    }(function(t) {
        return t.fn.tilt = function(e) {
            const i = function() {
                    this.ticking || (requestAnimationFrame(c.bind(this)), this.ticking = !0)
                },
                n = function() {
                    void 0 !== this.timeout && clearTimeout(this.timeout), t(this).css({
                        transition: `${this.settings.speed}ms ${this.settings.easing}`
                    }), this.settings.glare && this.glareElement.css({
                        transition: `opacity ${this.settings.speed}ms ${this.settings.easing}`
                    }), this.timeout = setTimeout(() => {
                        t(this).css({
                            transition: ""
                        }), this.settings.glare && this.glareElement.css({
                            transition: ""
                        })
                    }, this.settings.speed)
                },
                r = function(e) {
                    this.ticking = !1, t(this).css({
                        "will-change": "transform"
                    }), n.call(this), t(this).trigger("tilt.mouseEnter")
                },
                o = function(e) {
                    return void 0 === e && (e = {
                        pageX: t(this).offset().left + t(this).outerWidth() / 2,
                        pageY: t(this).offset().top + t(this).outerHeight() / 2
                    }), {
                        x: e.pageX,
                        y: e.pageY
                    }
                },
                s = function(t) {
                    this.mousePositions = o(t), i.call(this)
                },
                a = function() {
                    n.call(this), this.reset = !0, i.call(this), t(this).trigger("tilt.mouseLeave")
                },
                l = function() {
                    const e = t(this).outerWidth(),
                        i = t(this).outerHeight(),
                        n = t(this).offset().left,
                        r = t(this).offset().top,
                        o = (this.mousePositions.x - n) / e,
                        s = (this.mousePositions.y - r) / i;
                    return {
                        tiltX: (this.settings.maxTilt / 2 - o * this.settings.maxTilt).toFixed(2),
                        tiltY: (s * this.settings.maxTilt - this.settings.maxTilt / 2).toFixed(2),
                        percentageX: 100 * o,
                        percentageY: 100 * s,
                        angle: Math.atan2(this.mousePositions.x - (n + e / 2), -(this.mousePositions.y - (r + i / 2))) * (180 / Math.PI)
                    }
                },
                c = function() {
                    if (this.transforms = l.call(this), this.reset) return this.reset = !1, t(this).css("transform", `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg)`), void(this.settings.glare && (this.glareElement.css("transform", "rotate(180deg) translate(-50%, -50%)"), this.glareElement.css("opacity", "0")));
                    t(this).css("transform", `perspective(${this.settings.perspective}px) rotateX(${"x"===this.settings.disableAxis?0:this.transforms.tiltY}deg) rotateY(${"y"===this.settings.disableAxis?0:this.transforms.tiltX}deg) scale3d(${this.settings.scale},${this.settings.scale},${this.settings.scale})`), this.settings.glare && (this.glareElement.css("transform", `rotate(${this.transforms.angle}deg) translate(-50%, -50%)`), this.glareElement.css("opacity", `${this.transforms.percentageY*this.settings.maxGlare/100}`)), t(this).trigger("change", [this.transforms]), this.ticking = !1
                },
                h = function() {
                    this.glareElement.css({
                        width: `${2*t(this).outerWidth()}`,
                        height: `${2*t(this).outerWidth()}`
                    })
                };
            return t.fn.tilt.destroy = function() {
                t(this).each(function() {
                    t(this).find(".js-tilt-glare").remove(), t(this).css({
                        "will-change": "",
                        transform: ""
                    }), t(this).off("mousemove mouseenter mouseleave")
                })
            }, t.fn.tilt.getValues = function() {
                const e = [];
                return t(this).each(function() {
                    this.mousePositions = o.call(this), e.push(l.call(this))
                }), e
            }, t.fn.tilt.reset = function() {
                t(this).each(function() {
                    this.mousePositions = o.call(this), this.settings = t(this).data("settings"), a.call(this), setTimeout(() => {
                        this.reset = !1
                    }, this.settings.transition)
                })
            }, this.each(function() {
                this.settings = t.extend({
                    maxTilt: t(this).is("[data-tilt-max]") ? t(this).data("tilt-max") : 20,
                    perspective: t(this).is("[data-tilt-perspective]") ? t(this).data("tilt-perspective") : 300,
                    easing: t(this).is("[data-tilt-easing]") ? t(this).data("tilt-easing") : "cubic-bezier(.03,.98,.52,.99)",
                    scale: t(this).is("[data-tilt-scale]") ? t(this).data("tilt-scale") : "1",
                    speed: t(this).is("[data-tilt-speed]") ? t(this).data("tilt-speed") : "400",
                    transition: !t(this).is("[data-tilt-transition]") || t(this).data("tilt-transition"),
                    disableAxis: t(this).is("[data-tilt-disable-axis]") ? t(this).data("tilt-disable-axis") : null,
                    axis: t(this).is("[data-tilt-axis]") ? t(this).data("tilt-axis") : null,
                    reset: !t(this).is("[data-tilt-reset]") || t(this).data("tilt-reset"),
                    glare: !!t(this).is("[data-tilt-glare]") && t(this).data("tilt-glare"),
                    maxGlare: t(this).is("[data-tilt-maxglare]") ? t(this).data("tilt-maxglare") : 1
                }, e), null !== this.settings.axis && (console.warn("Tilt.js: the axis setting has been renamed to disableAxis. See https://github.com/gijsroge/tilt.js/pull/26 for more information"), this.settings.disableAxis = this.settings.axis), this.init = (() => {
                    t(this).data("settings", this.settings), this.settings.glare && function() {
                            const e = this.settings.glarePrerender;
                            if (e || t(this).append('<div class="js-tilt-glare"><div class="js-tilt-glare-inner"></div></div>'), this.glareElementWrapper = t(this).find(".js-tilt-glare"), this.glareElement = t(this).find(".js-tilt-glare-inner"), e) return;
                            this.glareElementWrapper.css({
                                position: "absolute",
                                top: "0",
                                left: "0",
                                width: "100%",
                                height: "100%"
                            }).css({
                                overflow: "hidden",
                                "pointer-events": "none"
                            }), this.glareElement.css({
                                position: "absolute",
                                top: "50%",
                                left: "50%",
                                "background-image": "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
                                width: `${2*t(this).outerWidth()}`,
                                height: `${2*t(this).outerWidth()}`,
                                transform: "rotate(180deg) translate(-50%, -50%)",
                                "transform-origin": "0% 0%",
                                opacity: "0"
                            })
                        }.call(this),
                        function() {
                            t(this).on("mousemove", s), t(this).on("mouseenter", r), this.settings.reset && t(this).on("mouseleave", a), this.settings.glare && t(window).on("resize", h.bind(this))
                        }.call(this)
                }), this.init()
            })
        }, t("[data-tilt]").tilt(), !0
    });
var WheelIndicator = function() {
    function t(t) {
        var r = {
            callback: function() {},
            elem: document,
            preventMouse: !0
        };
        this.eventWheel = "onwheel" in document ? "wheel" : "mousewheel", this._options = n(r, t), this._deltaArray = [0, 0, 0], this._isAcceleration = !1, this._isStopped = !0, this._direction = "", this._timer = "", this._isWorking = !0;
        var o, s, a, l = this;
        this._wheelHandler = function(t) {
            l._isWorking && (function(t) {
                var n = this,
                    r = i(t);
                if (0 === r) return;
                var o, s = r > 0 ? "down" : "up",
                    a = n._deltaArray.length,
                    l = !1,
                    c = 0;
                for (clearTimeout(n._timer), n._timer = setTimeout(function() {
                        n._deltaArray = [0, 0, 0], n._isStopped = !0, n._direction = s
                    }, 150), o = 0; o < a; o++) 0 !== n._deltaArray[o] && (n._deltaArray[o] > 0 ? ++c : --c);
                Math.abs(c) === a && (c > 0 ? "down" : "up") !== n._direction && (l = !0, n._direction = s);
                n._isStopped || (l ? (n._isAcceleration = !0, e.call(this, t)) : Math.abs(c) === a && function(t) {
                    var n = Math.abs(this._deltaArray[0]),
                        r = Math.abs(this._deltaArray[1]),
                        o = Math.abs(this._deltaArray[2]),
                        s = Math.abs(i(t));
                    s > o && o > r && r > n && (this._isAcceleration || (e.call(this, t), this._isAcceleration = !0));
                    s < o && o <= r && (this._isAcceleration = !1)
                }.call(this, t));
                n._isStopped && (n._isStopped = !1, n._isAcceleration = !0, n._direction = s, e.call(this, t));
                n._deltaArray.shift(), n._deltaArray.push(r)
            }.call(l, t), l._options.preventMouse && function(t) {
                (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1
            }(t))
        }, o = this._options.elem, s = this.eventWheel, a = this._wheelHandler, o.addEventListener ? o.addEventListener(s, a, !1) : o.attachEvent && o.attachEvent("on" + s, a)
    }

    function e(t) {
        t.direction = this._direction, this._options.callback(t)
    }
    t.prototype = {
        constructor: t,
        turnOn: function() {
            return this._isWorking = !0, this
        },
        turnOff: function() {
            return this._isWorking = !1, this
        },
        setOptions: function(t) {
            return this._options = n(this._options, t), this
        },
        getOption: function(t) {
            var e = this._options[t];
            if (void 0 !== e) return e;
            throw new Error("Unknown option")
        },
        destroy: function() {
            var t, e, i;
            return t = this._options.elem, e = this.eventWheel, i = this._wheelHandler, t.removeEventListener ? t.removeEventListener(e, i, !1) : t.detachEvent && t.detachEvent("on" + e, i), this
        }
    };
    var i = function(t) {
        return (i = t.wheelDelta && !t.deltaY ? function(t) {
            return -1 * t.wheelDelta
        } : function(t) {
            return t.deltaY
        })(t)
    };

    function n(t, e) {
        var i, n = {};
        for (i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
        for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);
        return n
    }
    return t
}();
"object" == typeof exports && (module.exports = WheelIndicator), jQuery(document).ready(function(t) {
    function e() {
        t("#values_heading").length > 0 && (t(window).width() >= 768 ? t("#values_heading").stick_in_parent({
            offset_top: 50
        }) : t("#values_heading").trigger("sticky_kit:detach"))
    }

    function i() {
        if (t(window).width() >= 992) {
            if (!t("body").hasClass("single-post") && t(".latest-news").length) {
                null == controller ? controller = new ScrollMagic.Controller : (controller.destroy(!0), controller = null, controller = new ScrollMagic.Controller);
                var e = 1;
                t(".latest-news__grid .news-card").each(function(t, i) {
                    var n;
                    n = e % 2 == 0 ? -80 : 80;
                    new ScrollMagic.Scene({
                        triggerElement: ".latest-news__grid",
                        triggerHook: "onCenter",
                        duration: "250%"
                    }).setTween(i, 1, {
                        y: n
                    }).addTo(controller);
                    e++
                })
            }
        } else controller && (controller.destroy(!0), controller = null)
    }

    function n() {
        if (t(window).width() >= 992) {
            if (t("body").hasClass("home")) {
                null == controllerHome ? controllerHome = new ScrollMagic.Controller : (controllerHome.destroy(!0), controllerHome = null, controllerHome = new ScrollMagic.Controller);
                new ScrollMagic.Scene({
                    triggerElement: ".about-us__text",
                    triggerHook: "onCenter",
                    duration: "100%"
                }).setTween(TweenMax.fromTo(t(".about-us__text"), 1, {
                    y: 150
                }, {
                    y: 0
                })).addTo(controllerHome), new ScrollMagic.Scene({
                    triggerElement: ".services__mission",
                    triggerHook: "onEnter",
                    duration: "100%"
                }).setTween(TweenMax.fromTo(t(".services__mission"), 1, {
                    y: 150
                }, {
                    y: 0
                })).addTo(controllerHome)
            }
        } else controllerHome && (controllerHome.destroy(!0), controllerHome = null)
    }

    function r() {
        if (t(window).width() >= 992) {
            if (t("body").hasClass("page-id-482")) {
                null == controllerHome ? controllerHome = new ScrollMagic.Controller : (controllerHome.destroy(!0), controllerHome = null, controllerHome = new ScrollMagic.Controller);
                new ScrollMagic.Scene({
                    triggerElement: ".clients__logos",
                    triggerHook: "onEnter",
                    duration: "100%"
                }).setTween(TweenMax.fromTo(t(".clients__logos"), 1, {
                    y: 150
                }, {
                    y: 0
                })).addTo(controllerHome)
            }
        } else controllerHome && (controllerHome.destroy(!0), controllerHome = null)
    }

    function o() {
        if (t(window).width() >= 992) {
            if (t("body").hasClass("page-id-480")) {
                null == controllerHome ? controllerHome = new ScrollMagic.Controller : (controllerHome.destroy(!0), controllerHome = null, controllerHome = new ScrollMagic.Controller);
                new ScrollMagic.Scene({
                    triggerElement: ".testimonial__block",
                    triggerHook: "onEnter",
                    duration: "100%"
                }).setTween(TweenMax.fromTo(t(".testimonial__block"), 1, {
                    y: 150
                }, {
                    y: 0
                })).addTo(controller)
            }
        } else controllerHome && (controllerHome.destroy(!0), controllerHome = null)
    }

    function s() {
        if (navigator.userAgent.match(/(iPod|iPhone|iPad)/) && window.innerHeight > window.innerWidth) {
            var e = t(window).innerHeight();
            navigator.userAgent.match(/iPad/i) && t("body").hasClass("single-case-studies") ? t(".masthead").css("height", "") : t(".masthead").css("height", e), t(".home .hp-masthead").css("height", e)
        } else t(".masthead").css("height", ""), t(".home .hp-masthead").css("height", "")
    }
    t(".hp-masthead__a").addClass("hp-masthead__a--scaled"), document.addEventListener("touchstart", function() {}, !0), controller = new ScrollMagic.Controller, controllerHome = new ScrollMagic.Controller, controllerCaseStudy = new ScrollMagic.Controller, t("p").each(function() {
        var e = t(this);
        0 == e.html().replace(/\s|&nbsp;/g, "").length && e.remove()
    }), t(".masthead").next("div, section").addClass("coloured"), t(".wpcf7").on("wpcf7:invalid", function(e) {
        t("html, body").animate({
            scrollTop: t(".wpcf7-not-valid").first().offset().top - 150
        }, 1e3)
    }), t(".animate").each(function(e, i) {
        new Waypoint({
            element: i,
            handler: function(e) {
                "down" === e && t(this.element).addClass("inview")
            },
            offset: "90%"
        })
    }), t(".process-strip").on("click", function() {
        t(this).find("p").slideToggle(), t(this).toggleClass("process-strip--active"), t(".process-strip p").not(t(this).find("p")).slideUp(), t(".process-strip").not(t(this)).removeClass("process-strip--active")
    }), t(".nav li").hover(function() {
        t(this).find("> a").addClass("hover"), t(".nav").addClass("nav--hovered")
    }, function() {
        t(this).find("> a").removeClass("hover"), t(".nav").removeClass("nav--hovered")
    }), t(".menu-toggle").on("click", function() {
        t(this).toggleClass("menu-toggle--active"), t(".navigation").toggleClass("navigation--active"), t("html, body").toggleClass("navopen"), t(".discuss-project").toggleClass("discuss-project--compact"), t(".header__circle").toggleClass("header__circle--active")
    }), t(window).scroll(function() {
        var e = t(window).scrollTop();
        e >= 80 ? (t(".discuss-project").addClass("discuss-project--compact"), t(".header").addClass("header--compact")) : (t(".discuss-project").removeClass("discuss-project--compact"), t(".header").removeClass("header--compact"));
        var i = t(window).height(),
            n = (t(window).width(), e / 3);
        e < i && t(".masthead__image").css("transform", "translate3d(0px," + n + "px, 0px)")
    });
    var a = t(".team__slider").slick({
        infinite: !1,
        slidesToShow: 6,
        slidesToScroll: 1,
        prevArrow: t(".prev"),
        nextArrow: t(".next"),
        responsive: [{
            breakpoint: 2200,
            settings: {
                slidesToShow: 5,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 1600,
            settings: {
                slidesToShow: 4,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 1200,
            settings: {
                slidesToShow: 3,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 768,
            settings: {
                slidesToShow: 2,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 480,
            settings: {
                slidesToShow: 1,
                slidesToScroll: 1
            }
        }]
    });
    if (t(window).width() >= 1024 && a.length) new WheelIndicator({
        elem: document.querySelector(".team__slider .slick-track"),
        callback: function(t) {
            "down" == t.direction ? a.slick("slickNext") : a.slick("slickPrev")
        }
    });
    a = t(".results__stats").slick({
        infinite: !1,
        slidesToShow: 4,
        slidesToScroll: 1,
        autoplay: !0,
        autoplaySpeed: 2e3,
        prevArrow: !1,
        nextArrow: !1,
        responsive: [{
            breakpoint: 768,
            settings: {
                slidesToShow: 3,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 520,
            settings: {
                slidesToShow: 2,
                slidesToScroll: 1
            }
        }, {
            breakpoint: 400,
            settings: {
                slidesToShow: 1,
                slidesToScroll: 1
            }
        }]
    });
    t(".project-card").each(function() {
        t(this).waypoint({
            handler: function(e) {
                t(this.element).addClass("project-card--active")
            },
            offset: "80%"
        })
    }), setTimeout(function() {
        Array.from(document.querySelectorAll(".project-card")).forEach(t => {
            const e = Array.from(t.querySelectorAll("img"));
            new hoverEffect({
                parent: t,
                intensity: t.dataset.intensity || void 0,
                speedIn: t.dataset.speedin || void 0,
                speedOut: t.dataset.speedout || void 0,
                easing: t.dataset.easing || void 0,
                hover: t.dataset.hover || void 0,
                image1: e[0],
                image2: e[1],
                displacementImage: globalObject.imagesUrl + "displacements/1.jpg",
                coverImage: !0
            })
        })
    }, 200);
    var l = function(t) {
        document.getElementsByClassName("navigation")[0].contains(t.target) || t.preventDefault()
    };
    if (navigator.userAgent.match(/(iPod|iPhone|iPad)/) && window.innerHeight > window.innerWidth) {
        document.body.style.overflow = "hidden", document.addEventListener("touchmove", l, !1), document.getElementsByClassName("navigation")[0].addEventListener("touchmove", function(t) {
            var e = this.scrollTop,
                i = this.scrollHeight,
                n = e + this.offsetHeight;
            0 === e && n === i ? t.preventDefault() : 0 === e ? this.scrollTop = 1 : n === i && (this.scrollTop = e - 1)
        });
        let t = .01 * window.innerHeight;
        document.documentElement.style.setProperty("--vh", `${t}px`), window.addEventListener("resize", () => {
            let t = .01 * window.innerHeight;
            document.documentElement.style.setProperty("--vh", `${t}px`)
        })
    }
    i(), e(), n(), s(), r(), o(), t(window).resize(function() {
        i(), e(), n(), s(), r(), o()
    })
});